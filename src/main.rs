#![feature(c_variadic)]
#![feature(extern_types)]


use ::libc;
extern "C" {
    pub type sqlite3;
    pub type sqlite3_mutex;
    pub type sqlite3_api_routines;
    pub type sqlite3_stmt;
    pub type sqlite3_value;
    pub type sqlite3_context;
    pub type sqlite3_str;
    pub type sqlite3_pcache;
    pub type sqlite3_backup;
    pub type __dirstream;
    pub type internal_state;
    fn strtol(
        _: *const libc::c_char,
        _: *mut *mut libc::c_char,
        _: libc::c_int,
    ) -> libc::c_long;
    fn strtod(_: *const libc::c_char, _: *mut *mut libc::c_char) -> libc::c_double;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn atexit(__func: Option::<unsafe extern "C" fn() -> ()>) -> libc::c_int;
    fn exit(_: libc::c_int) -> !;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memmove(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memcmp(
        _: *const libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strcpy(_: *mut libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_ulong,
    ) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn _IO_putc(__c: libc::c_int, __fp: *mut _IO_FILE) -> libc::c_int;
    static mut stdin: *mut _IO_FILE;
    static mut stdout: *mut _IO_FILE;
    static mut stderr: *mut _IO_FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn rewind(__stream: *mut FILE);
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn fseek(
        __stream: *mut FILE,
        __off: libc::c_long,
        __whence: libc::c_int,
    ) -> libc::c_int;
    fn fgets(
        __s: *mut libc::c_char,
        __n: libc::c_int,
        __stream: *mut FILE,
    ) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn __assert_fail(
        __assertion: *const libc::c_char,
        __file: *const libc::c_char,
        __line: libc::c_uint,
        __function: *const libc::c_char,
    ) -> !;
    fn sqlite3_libversion() -> *const libc::c_char;
    fn sqlite3_sourceid() -> *const libc::c_char;
    fn sqlite3_libversion_number() -> libc::c_int;
    fn sqlite3_close(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_exec(
        _: *mut sqlite3,
        sql: *const libc::c_char,
        callback_0: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *mut *mut libc::c_char,
                *mut *mut libc::c_char,
            ) -> libc::c_int,
        >,
        _: *mut libc::c_void,
        errmsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_initialize() -> libc::c_int;
    fn sqlite3_config(_: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_db_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_total_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_interrupt(_: *mut sqlite3);
    fn sqlite3_complete(sql: *const libc::c_char) -> libc::c_int;
    fn sqlite3_busy_timeout(_: *mut sqlite3, ms: libc::c_int) -> libc::c_int;
    fn sqlite3_mprintf(_: *const libc::c_char, _: ...) -> *mut libc::c_char;
    fn sqlite3_vmprintf(
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_snprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ...
    ) -> *mut libc::c_char;
    fn sqlite3_vsnprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::core::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_malloc(_: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_malloc64(_: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_realloc(_: *mut libc::c_void, _: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_realloc64(_: *mut libc::c_void, _: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_free(_: *mut libc::c_void);
    fn sqlite3_randomness(N: libc::c_int, P: *mut libc::c_void);
    fn sqlite3_set_authorizer(
        _: *mut sqlite3,
        xAuth: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *const libc::c_char,
                *const libc::c_char,
                *const libc::c_char,
                *const libc::c_char,
            ) -> libc::c_int,
        >,
        pUserData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_trace_v2(
        _: *mut sqlite3,
        uMask: libc::c_uint,
        xCallback: Option::<
            unsafe extern "C" fn(
                libc::c_uint,
                *mut libc::c_void,
                *mut libc::c_void,
                *mut libc::c_void,
            ) -> libc::c_int,
        >,
        pCtx: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_progress_handler(
        _: *mut sqlite3,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
        _: *mut libc::c_void,
    );
    fn sqlite3_open(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
    ) -> libc::c_int;
    fn sqlite3_open_v2(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
        flags: libc::c_int,
        zVfs: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_extended_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_errmsg(_: *mut sqlite3) -> *const libc::c_char;
    fn sqlite3_error_offset(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_limit(
        _: *mut sqlite3,
        id: libc::c_int,
        newVal: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_prepare_v2(
        db: *mut sqlite3,
        zSql: *const libc::c_char,
        nByte: libc::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const libc::c_char;
    fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut libc::c_char;
    fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_stmt_explain(pStmt: *mut sqlite3_stmt, eMode: libc::c_int) -> libc::c_int;
    fn sqlite3_bind_blob(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_void,
        n: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_double(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: libc::c_double,
    ) -> libc::c_int;
    fn sqlite3_bind_int(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_bind_int64(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: sqlite3_int64,
    ) -> libc::c_int;
    fn sqlite3_bind_null(_: *mut sqlite3_stmt, _: libc::c_int) -> libc::c_int;
    fn sqlite3_bind_text(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_value(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const sqlite3_value,
    ) -> libc::c_int;
    fn sqlite3_bind_parameter_count(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_parameter_name(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_bind_parameter_index(
        _: *mut sqlite3_stmt,
        zName: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_clear_bindings(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_name(_: *mut sqlite3_stmt, N: libc::c_int) -> *const libc::c_char;
    fn sqlite3_column_decltype(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_step(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_blob(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *const libc::c_void;
    fn sqlite3_column_double(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_double;
    fn sqlite3_column_int(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_int64(_: *mut sqlite3_stmt, iCol: libc::c_int) -> sqlite3_int64;
    fn sqlite3_column_text(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *const libc::c_uchar;
    fn sqlite3_column_value(
        _: *mut sqlite3_stmt,
        iCol: libc::c_int,
    ) -> *mut sqlite3_value;
    fn sqlite3_column_bytes(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_type(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_create_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xFunc: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xStep: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_create_window_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xStep: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
        xValue: Option::<unsafe extern "C" fn(*mut sqlite3_context) -> ()>,
        xInverse: Option::<
            unsafe extern "C" fn(
                *mut sqlite3_context,
                libc::c_int,
                *mut *mut sqlite3_value,
            ) -> (),
        >,
        xDestroy: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_value_blob(_: *mut sqlite3_value) -> *const libc::c_void;
    fn sqlite3_value_double(_: *mut sqlite3_value) -> libc::c_double;
    fn sqlite3_value_int(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_int64(_: *mut sqlite3_value) -> sqlite3_int64;
    fn sqlite3_value_text(_: *mut sqlite3_value) -> *const libc::c_uchar;
    fn sqlite3_value_bytes(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_type(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_dup(_: *const sqlite3_value) -> *mut sqlite3_value;
    fn sqlite3_value_free(_: *mut sqlite3_value);
    fn sqlite3_aggregate_context(
        _: *mut sqlite3_context,
        nBytes: libc::c_int,
    ) -> *mut libc::c_void;
    fn sqlite3_user_data(_: *mut sqlite3_context) -> *mut libc::c_void;
    fn sqlite3_context_db_handle(_: *mut sqlite3_context) -> *mut sqlite3;
    fn sqlite3_get_auxdata(_: *mut sqlite3_context, N: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_set_auxdata(
        _: *mut sqlite3_context,
        N: libc::c_int,
        _: *mut libc::c_void,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob64(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: sqlite3_uint64,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_double(_: *mut sqlite3_context, _: libc::c_double);
    fn sqlite3_result_error(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
    );
    fn sqlite3_result_error_nomem(_: *mut sqlite3_context);
    fn sqlite3_result_error_code(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int64(_: *mut sqlite3_context, _: sqlite3_int64);
    fn sqlite3_result_null(_: *mut sqlite3_context);
    fn sqlite3_result_text(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_text64(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: sqlite3_uint64,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
        encoding: libc::c_uchar,
    );
    fn sqlite3_result_text16le(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_text16be(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_value(_: *mut sqlite3_context, _: *mut sqlite3_value);
    fn sqlite3_result_zeroblob(_: *mut sqlite3_context, n: libc::c_int);
    fn sqlite3_create_collation(
        _: *mut sqlite3,
        zName: *const libc::c_char,
        eTextRep: libc::c_int,
        pArg: *mut libc::c_void,
        xCompare: Option::<
            unsafe extern "C" fn(
                *mut libc::c_void,
                libc::c_int,
                *const libc::c_void,
                libc::c_int,
                *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
    fn sqlite3_sleep(_: libc::c_int) -> libc::c_int;
    fn sqlite3_get_autocommit(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_db_handle(_: *mut sqlite3_stmt) -> *mut sqlite3;
    fn sqlite3_db_readonly(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_txn_state(_: *mut sqlite3, zSchema: *const libc::c_char) -> libc::c_int;
    fn sqlite3_table_column_metadata(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
        zTableName: *const libc::c_char,
        zColumnName: *const libc::c_char,
        pzDataType: *mut *const libc::c_char,
        pzCollSeq: *mut *const libc::c_char,
        pNotNull: *mut libc::c_int,
        pPrimaryKey: *mut libc::c_int,
        pAutoinc: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_load_extension(
        db: *mut sqlite3,
        zFile: *const libc::c_char,
        zProc: *const libc::c_char,
        pzErrMsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_enable_load_extension(
        db: *mut sqlite3,
        onoff: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_create_module(
        db: *mut sqlite3,
        zName: *const libc::c_char,
        p: *const sqlite3_module,
        pClientData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_declare_vtab(_: *mut sqlite3, zSQL: *const libc::c_char) -> libc::c_int;
    fn sqlite3_overload_function(
        _: *mut sqlite3,
        zFuncName: *const libc::c_char,
        nArg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_vfs_find(zVfsName: *const libc::c_char) -> *mut sqlite3_vfs;
    fn sqlite3_vfs_register(_: *mut sqlite3_vfs, makeDflt: libc::c_int) -> libc::c_int;
    fn sqlite3_mutex_alloc(_: libc::c_int) -> *mut sqlite3_mutex;
    fn sqlite3_mutex_enter(_: *mut sqlite3_mutex);
    fn sqlite3_mutex_leave(_: *mut sqlite3_mutex);
    fn sqlite3_file_control(
        _: *mut sqlite3,
        zDbName: *const libc::c_char,
        op: libc::c_int,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_test_control(op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_keyword_count() -> libc::c_int;
    fn sqlite3_keyword_name(
        _: libc::c_int,
        _: *mut *const libc::c_char,
        _: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_keyword_check(_: *const libc::c_char, _: libc::c_int) -> libc::c_int;
    fn sqlite3_str_new(_: *mut sqlite3) -> *mut sqlite3_str;
    fn sqlite3_str_finish(_: *mut sqlite3_str) -> *mut libc::c_char;
    fn sqlite3_str_appendf(_: *mut sqlite3_str, zFormat: *const libc::c_char, _: ...);
    fn sqlite3_str_append(_: *mut sqlite3_str, zIn: *const libc::c_char, N: libc::c_int);
    fn sqlite3_str_appendall(_: *mut sqlite3_str, zIn: *const libc::c_char);
    fn sqlite3_status64(
        op: libc::c_int,
        pCurrent: *mut sqlite3_int64,
        pHighwater: *mut sqlite3_int64,
        resetFlag: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_db_status(
        _: *mut sqlite3,
        op: libc::c_int,
        pCur: *mut libc::c_int,
        pHiwtr: *mut libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_stmt_status(
        _: *mut sqlite3_stmt,
        op: libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_backup_init(
        pDest: *mut sqlite3,
        zDestName: *const libc::c_char,
        pSource: *mut sqlite3,
        zSourceName: *const libc::c_char,
    ) -> *mut sqlite3_backup;
    fn sqlite3_backup_step(p: *mut sqlite3_backup, nPage: libc::c_int) -> libc::c_int;
    fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> libc::c_int;
    fn sqlite3_stricmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn sqlite3_strnicmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_strglob(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_strlike(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
        cEsc: libc::c_uint,
    ) -> libc::c_int;
    fn sqlite3_vtab_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_vtab_on_conflict(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_vtab_nochange(_: *mut sqlite3_context) -> libc::c_int;
    fn sqlite3_vtab_collation(
        _: *mut sqlite3_index_info,
        _: libc::c_int,
    ) -> *const libc::c_char;
    fn sqlite3_deserialize(
        db: *mut sqlite3,
        zSchema: *const libc::c_char,
        pData: *mut libc::c_uchar,
        szDb: sqlite3_int64,
        szBuf: sqlite3_int64,
        mFlags: libc::c_uint,
    ) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const __int32_t;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn raise(__sig: libc::c_int) -> libc::c_int;
    fn getpwuid(__uid: __uid_t) -> *mut passwd;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn chdir(__path: *const libc::c_char) -> libc::c_int;
    fn getpid() -> __pid_t;
    fn getuid() -> __uid_t;
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
    fn readlink(
        __path: *const libc::c_char,
        __buf: *mut libc::c_char,
        __len: size_t,
    ) -> ssize_t;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn opendir(__name: *const libc::c_char) -> *mut DIR;
    fn closedir(__dirp: *mut DIR) -> libc::c_int;
    fn readdir(__dirp: *mut DIR) -> *mut dirent;
    fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn __lxstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn readline(_: *const libc::c_char) -> *mut libc::c_char;
    fn rl_completion_matches(
        _: *const libc::c_char,
        _: Option::<rl_compentry_func_t>,
    ) -> *mut *mut libc::c_char;
    static mut rl_attempted_completion_function: Option::<rl_completion_func_t>;
    static mut rl_attempted_completion_over: libc::c_int;
    fn add_history(_: *const libc::c_char);
    fn stifle_history(_: libc::c_int);
    fn read_history(_: *const libc::c_char) -> libc::c_int;
    fn write_history(_: *const libc::c_char) -> libc::c_int;
    fn time(__timer: *mut time_t) -> time_t;
    fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
    fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
    fn zlibVersion() -> *const libc::c_char;
    fn deflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn deflateEnd(strm: z_streamp) -> libc::c_int;
    fn inflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn inflateEnd(strm: z_streamp) -> libc::c_int;
    fn deflateBound(strm: z_streamp, sourceLen: uLong) -> uLong;
    fn compress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn compressBound(sourceLen: uLong) -> uLong;
    fn uncompress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
    fn inflateInit2_(
        strm: z_streamp,
        windowBits: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    fn deflateInit2_(
        strm: z_streamp,
        level: libc::c_int,
        method: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type u32_0 = libc::c_uint;
pub type u16_0 = libc::c_ushort;
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: __off64_t,
    pub __pad1: *mut libc::c_void,
    pub __pad2: *mut libc::c_void,
    pub __pad3: *mut libc::c_void,
    pub __pad4: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: libc::c_int,
}
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type sqlite_int64 = libc::c_longlong;
pub type sqlite_uint64 = libc::c_ulonglong;
pub type sqlite3_int64 = sqlite_int64;
pub type sqlite3_uint64 = sqlite_uint64;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_file {
    pub pMethods: *const sqlite3_io_methods,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_io_methods {
    pub iVersion: libc::c_int,
    pub xClose: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int>,
    pub xRead: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            *mut libc::c_void,
            libc::c_int,
            sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xWrite: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            *const libc::c_void,
            libc::c_int,
            sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xTruncate: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, sqlite3_int64) -> libc::c_int,
    >,
    pub xSync: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xFileSize: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xLock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xUnlock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xCheckReservedLock: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, *mut libc::c_int) -> libc::c_int,
    >,
    pub xFileControl: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xSectorSize: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int>,
    pub xDeviceCharacteristics: Option::<
        unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
    >,
    pub xShmMap: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            libc::c_int,
            libc::c_int,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xShmLock: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xShmBarrier: Option::<unsafe extern "C" fn(*mut sqlite3_file) -> ()>,
    pub xShmUnmap: Option::<
        unsafe extern "C" fn(*mut sqlite3_file, libc::c_int) -> libc::c_int,
    >,
    pub xFetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            sqlite3_int64,
            libc::c_int,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xUnfetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_file,
            sqlite3_int64,
            *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
pub type sqlite3_filename = *const libc::c_char;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vfs {
    pub iVersion: libc::c_int,
    pub szOsFile: libc::c_int,
    pub mxPathname: libc::c_int,
    pub pNext: *mut sqlite3_vfs,
    pub zName: *const libc::c_char,
    pub pAppData: *mut libc::c_void,
    pub xOpen: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            sqlite3_filename,
            *mut sqlite3_file,
            libc::c_int,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub xDelete: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xAccess: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
            *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub xFullPathname: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xDlOpen: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *const libc::c_char) -> *mut libc::c_void,
    >,
    pub xDlError: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int, *mut libc::c_char) -> (),
    >,
    pub xDlSym: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *mut libc::c_void,
            *const libc::c_char,
        ) -> Option::<unsafe extern "C" fn() -> ()>,
    >,
    pub xDlClose: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_void) -> (),
    >,
    pub xRandomness: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xSleep: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int) -> libc::c_int,
    >,
    pub xCurrentTime: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_double) -> libc::c_int,
    >,
    pub xGetLastError: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            libc::c_int,
            *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xCurrentTimeInt64: Option::<
        unsafe extern "C" fn(*mut sqlite3_vfs, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xSetSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
            sqlite3_syscall_ptr,
        ) -> libc::c_int,
    >,
    pub xGetSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
        ) -> sqlite3_syscall_ptr,
    >,
    pub xNextSystemCall: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vfs,
            *const libc::c_char,
        ) -> *const libc::c_char,
    >,
}
pub type sqlite3_syscall_ptr = Option::<unsafe extern "C" fn() -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_mem_methods {
    pub xMalloc: Option::<unsafe extern "C" fn(libc::c_int) -> *mut libc::c_void>,
    pub xFree: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub xRealloc: Option::<
        unsafe extern "C" fn(*mut libc::c_void, libc::c_int) -> *mut libc::c_void,
    >,
    pub xSize: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xRoundup: Option::<unsafe extern "C" fn(libc::c_int) -> libc::c_int>,
    pub xInit: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xShutdown: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub pAppData: *mut libc::c_void,
}
pub type sqlite3_destructor_type = Option::<
    unsafe extern "C" fn(*mut libc::c_void) -> (),
>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab {
    pub pModule: *const sqlite3_module,
    pub nRef: libc::c_int,
    pub zErrMsg: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_module {
    pub iVersion: libc::c_int,
    pub xCreate: Option::<
        unsafe extern "C" fn(
            *mut sqlite3,
            *mut libc::c_void,
            libc::c_int,
            *const *const libc::c_char,
            *mut *mut sqlite3_vtab,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xConnect: Option::<
        unsafe extern "C" fn(
            *mut sqlite3,
            *mut libc::c_void,
            libc::c_int,
            *const *const libc::c_char,
            *mut *mut sqlite3_vtab,
            *mut *mut libc::c_char,
        ) -> libc::c_int,
    >,
    pub xBestIndex: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, *mut sqlite3_index_info) -> libc::c_int,
    >,
    pub xDisconnect: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xDestroy: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xOpen: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            *mut *mut sqlite3_vtab_cursor,
        ) -> libc::c_int,
    >,
    pub xClose: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xFilter: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab_cursor,
            libc::c_int,
            *const libc::c_char,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> libc::c_int,
    >,
    pub xNext: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xEof: Option::<unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int>,
    pub xColumn: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab_cursor,
            *mut sqlite3_context,
            libc::c_int,
        ) -> libc::c_int,
    >,
    pub xRowid: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab_cursor, *mut sqlite3_int64) -> libc::c_int,
    >,
    pub xUpdate: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            libc::c_int,
            *mut *mut sqlite3_value,
            *mut sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xBegin: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xSync: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xCommit: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xRollback: Option::<unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int>,
    pub xFindFunction: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_vtab,
            libc::c_int,
            *const libc::c_char,
            *mut Option::<
                unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
            >,
            *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xRename: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, *const libc::c_char) -> libc::c_int,
    >,
    pub xSavepoint: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xRelease: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xRollbackTo: Option::<
        unsafe extern "C" fn(*mut sqlite3_vtab, libc::c_int) -> libc::c_int,
    >,
    pub xShadowName: Option::<unsafe extern "C" fn(*const libc::c_char) -> libc::c_int>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab_cursor {
    pub pVtab: *mut sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_info {
    pub nConstraint: libc::c_int,
    pub aConstraint: *mut sqlite3_index_constraint,
    pub nOrderBy: libc::c_int,
    pub aOrderBy: *mut sqlite3_index_orderby,
    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
    pub idxNum: libc::c_int,
    pub idxStr: *mut libc::c_char,
    pub needToFreeIdxStr: libc::c_int,
    pub orderByConsumed: libc::c_int,
    pub estimatedCost: libc::c_double,
    pub estimatedRows: sqlite3_int64,
    pub idxFlags: libc::c_int,
    pub colUsed: sqlite3_uint64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint_usage {
    pub argvIndex: libc::c_int,
    pub omit: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_orderby {
    pub iColumn: libc::c_int,
    pub desc: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint {
    pub iColumn: libc::c_int,
    pub op: libc::c_uchar,
    pub usable: libc::c_uchar,
    pub iTermOffset: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_pcache_page {
    pub pBuf: *mut libc::c_void,
    pub pExtra: *mut libc::c_void,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_pcache_methods2 {
    pub iVersion: libc::c_int,
    pub pArg: *mut libc::c_void,
    pub xInit: Option::<unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int>,
    pub xShutdown: Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
    pub xCreate: Option::<
        unsafe extern "C" fn(
            libc::c_int,
            libc::c_int,
            libc::c_int,
        ) -> *mut sqlite3_pcache,
    >,
    pub xCachesize: Option::<
        unsafe extern "C" fn(*mut sqlite3_pcache, libc::c_int) -> (),
    >,
    pub xPagecount: Option::<unsafe extern "C" fn(*mut sqlite3_pcache) -> libc::c_int>,
    pub xFetch: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_pcache,
            libc::c_uint,
            libc::c_int,
        ) -> *mut sqlite3_pcache_page,
    >,
    pub xUnpin: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_pcache,
            *mut sqlite3_pcache_page,
            libc::c_int,
        ) -> (),
    >,
    pub xRekey: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_pcache,
            *mut sqlite3_pcache_page,
            libc::c_uint,
            libc::c_uint,
        ) -> (),
    >,
    pub xTruncate: Option::<
        unsafe extern "C" fn(*mut sqlite3_pcache, libc::c_uint) -> (),
    >,
    pub xDestroy: Option::<unsafe extern "C" fn(*mut sqlite3_pcache) -> ()>,
    pub xShrink: Option::<unsafe extern "C" fn(*mut sqlite3_pcache) -> ()>,
}
pub type i64_0 = sqlite3_int64;
pub type u64_0 = sqlite3_uint64;
pub type u8_0 = libc::c_uchar;
pub type C2RustUnnamed = libc::c_uint;
pub const _ISalnum: C2RustUnnamed = 8;
pub const _ISpunct: C2RustUnnamed = 4;
pub const _IScntrl: C2RustUnnamed = 2;
pub const _ISblank: C2RustUnnamed = 1;
pub const _ISgraph: C2RustUnnamed = 32768;
pub const _ISprint: C2RustUnnamed = 16384;
pub const _ISspace: C2RustUnnamed = 8192;
pub const _ISxdigit: C2RustUnnamed = 4096;
pub const _ISdigit: C2RustUnnamed = 2048;
pub const _ISalpha: C2RustUnnamed = 1024;
pub const _ISlower: C2RustUnnamed = 512;
pub const _ISupper: C2RustUnnamed = 256;
pub type __sighandler_t = Option::<unsafe extern "C" fn(libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct passwd {
    pub pw_name: *mut libc::c_char,
    pub pw_passwd: *mut libc::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut libc::c_char,
    pub pw_dir: *mut libc::c_char,
    pub pw_shell: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dirent {
    pub d_ino: __ino64_t,
    pub d_off: __off64_t,
    pub d_reclen: libc::c_ushort,
    pub d_type: libc::c_uchar,
    pub d_name: [libc::c_char; 256],
}
pub type DIR = __dirstream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type rl_compentry_func_t = unsafe extern "C" fn(
    *const libc::c_char,
    libc::c_int,
) -> *mut libc::c_char;
pub type rl_completion_func_t = unsafe extern "C" fn(
    *const libc::c_char,
    libc::c_int,
    libc::c_int,
) -> *mut *mut libc::c_char;
pub type __rusage_who = libc::c_int;
pub const RUSAGE_CHILDREN: __rusage_who = -1;
pub const RUSAGE_SELF: __rusage_who = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub c2rust_unnamed: C2RustUnnamed_13,
    pub c2rust_unnamed_0: C2RustUnnamed_12,
    pub c2rust_unnamed_1: C2RustUnnamed_11,
    pub c2rust_unnamed_2: C2RustUnnamed_10,
    pub c2rust_unnamed_3: C2RustUnnamed_9,
    pub c2rust_unnamed_4: C2RustUnnamed_8,
    pub c2rust_unnamed_5: C2RustUnnamed_7,
    pub c2rust_unnamed_6: C2RustUnnamed_6,
    pub c2rust_unnamed_7: C2RustUnnamed_5,
    pub c2rust_unnamed_8: C2RustUnnamed_4,
    pub c2rust_unnamed_9: C2RustUnnamed_3,
    pub c2rust_unnamed_10: C2RustUnnamed_2,
    pub c2rust_unnamed_11: C2RustUnnamed_1,
    pub c2rust_unnamed_12: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub ru_nivcsw: libc::c_long,
    pub __ru_nivcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub ru_nvcsw: libc::c_long,
    pub __ru_nvcsw_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub ru_nsignals: libc::c_long,
    pub __ru_nsignals_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub ru_msgrcv: libc::c_long,
    pub __ru_msgrcv_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub ru_msgsnd: libc::c_long,
    pub __ru_msgsnd_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub ru_oublock: libc::c_long,
    pub __ru_oublock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub ru_inblock: libc::c_long,
    pub __ru_inblock_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub ru_nswap: libc::c_long,
    pub __ru_nswap_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub ru_majflt: libc::c_long,
    pub __ru_majflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub ru_minflt: libc::c_long,
    pub __ru_minflt_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub ru_isrss: libc::c_long,
    pub __ru_isrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub ru_idrss: libc::c_long,
    pub __ru_idrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_12 {
    pub ru_ixrss: libc::c_long,
    pub __ru_ixrss_word: __syscall_slong_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub ru_maxrss: libc::c_long,
    pub __ru_maxrss_word: __syscall_slong_t,
}
pub type __rusage_who_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DynaPrompt {
    pub dynamicPrompt: [libc::c_char; 20],
    pub acAwait: [libc::c_char; 2],
    pub inParenLevel: libc::c_int,
    pub zScannerAwaits: *mut libc::c_char,
}
pub type t_DynaPromptRef = *mut DynaPrompt;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub zSuffix: *mut libc::c_char,
    pub iMult: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellText {
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SHA3Context {
    pub u: C2RustUnnamed_15,
    pub nRate: libc::c_uint,
    pub nLoaded: libc::c_uint,
    pub ixMask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub s: [u64_0; 25],
    pub x: [libc::c_uchar; 1600],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Decimal {
    pub sign: libc::c_char,
    pub oom: libc::c_char,
    pub isNull: libc::c_char,
    pub isInit: libc::c_char,
    pub nDigit: libc::c_int,
    pub nFrac: libc::c_int,
    pub a: *mut libc::c_schar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub zFuncName: *const libc::c_char,
    pub nArg: libc::c_int,
    pub iArg: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub zFName: *mut libc::c_char,
    pub nArg: libc::c_int,
    pub iAux: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SequenceSpec {
    pub iBase: sqlite3_int64,
    pub iTerm: sqlite3_int64,
    pub iStep: sqlite3_int64,
    pub uSeqIndexMax: sqlite3_uint64,
    pub uSeqIndexNow: sqlite3_uint64,
    pub iValueNow: sqlite3_int64,
    pub isNotEOF: u8_0,
    pub isReversing: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct series_cursor {
    pub base: sqlite3_vtab_cursor,
    pub ss: SequenceSpec,
}
pub type ReStateNumber = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReStateSet {
    pub nState: libc::c_uint,
    pub aState: *mut ReStateNumber,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReInput {
    pub z: *const libc::c_uchar,
    pub i: libc::c_int,
    pub mx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReCompiled {
    pub sIn: ReInput,
    pub zErr: *const libc::c_char,
    pub aOp: *mut libc::c_char,
    pub aArg: *mut libc::c_int,
    pub xNextChar: Option::<unsafe extern "C" fn(*mut ReInput) -> libc::c_uint>,
    pub zInit: [libc::c_uchar; 12],
    pub nInit: libc::c_int,
    pub nState: libc::c_uint,
    pub nAlloc: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_cursor {
    pub base: sqlite3_vtab_cursor,
    pub nLvl: libc::c_int,
    pub iLvl: libc::c_int,
    pub aLvl: *mut FsdirLevel,
    pub zBase: *const libc::c_char,
    pub nBase: libc::c_int,
    pub sStat: stat,
    pub zPath: *mut libc::c_char,
    pub iRowid: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FsdirLevel {
    pub pDir: *mut DIR,
    pub zDir: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_tab {
    pub base: sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_vtab {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_cursor {
    pub base: sqlite3_vtab_cursor,
    pub db: *mut sqlite3,
    pub nPrefix: libc::c_int,
    pub nLine: libc::c_int,
    pub zPrefix: *mut libc::c_char,
    pub zLine: *mut libc::c_char,
    pub zCurrentRow: *const libc::c_char,
    pub szRow: libc::c_int,
    pub pStmt: *mut sqlite3_stmt,
    pub iRowid: sqlite3_int64,
    pub ePhase: libc::c_int,
    pub j: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ApndFile {
    pub base: sqlite3_file,
    pub iPgOne: sqlite3_int64,
    pub iMark: sqlite3_int64,
}
pub type Byte = libc::c_uchar;
pub type uInt = libc::c_uint;
pub type uLong = libc::c_ulong;
pub type Bytef = Byte;
pub type uLongf = uLong;
pub type voidpf = *mut libc::c_void;
pub type alloc_func = Option::<unsafe extern "C" fn(voidpf, uInt, uInt) -> voidpf>;
pub type free_func = Option::<unsafe extern "C" fn(voidpf, voidpf) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut libc::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: libc::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileEOCD {
    pub iDisk: u16_0,
    pub iFirstDisk: u16_0,
    pub nEntry: u16_0,
    pub nEntryTotal: u16_0,
    pub nSize: u32_0,
    pub iOffset: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCDS {
    pub iVersionMadeBy: u16_0,
    pub iVersionExtract: u16_0,
    pub flags: u16_0,
    pub iCompression: u16_0,
    pub mTime: u16_0,
    pub mDate: u16_0,
    pub crc32: u32_0,
    pub szCompressed: u32_0,
    pub szUncompressed: u32_0,
    pub nFile: u16_0,
    pub nExtra: u16_0,
    pub nComment: u16_0,
    pub iDiskStart: u16_0,
    pub iInternalAttr: u16_0,
    pub iExternalAttr: u32_0,
    pub iOffset: u32_0,
    pub zFile: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileLFH {
    pub iVersionExtract: u16_0,
    pub flags: u16_0,
    pub iCompression: u16_0,
    pub mTime: u16_0,
    pub mDate: u16_0,
    pub crc32: u32_0,
    pub szCompressed: u32_0,
    pub szUncompressed: u32_0,
    pub nFile: u16_0,
    pub nExtra: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileEntry {
    pub cds: ZipfileCDS,
    pub mUnixTime: u32_0,
    pub aExtra: *mut u8_0,
    pub iDataOff: i64_0,
    pub aData: *mut u8_0,
    pub pNext: *mut ZipfileEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCsr {
    pub base: sqlite3_vtab_cursor,
    pub iId: i64_0,
    pub bEof: u8_0,
    pub bNoop: u8_0,
    pub pFile: *mut FILE,
    pub iNextOff: i64_0,
    pub eocd: ZipfileEOCD,
    pub pFreeEntry: *mut ZipfileEntry,
    pub pCurrent: *mut ZipfileEntry,
    pub pCsrNext: *mut ZipfileCsr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileTab {
    pub base: sqlite3_vtab,
    pub zFile: *mut libc::c_char,
    pub db: *mut sqlite3,
    pub aBuffer: *mut u8_0,
    pub pCsrList: *mut ZipfileCsr,
    pub iNextCsrid: i64_0,
    pub pFirstEntry: *mut ZipfileEntry,
    pub pLastEntry: *mut ZipfileEntry,
    pub pWriteFd: *mut FILE,
    pub szCurrent: i64_0,
    pub szOrig: i64_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileBuffer {
    pub a: *mut u8_0,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCtx {
    pub nEntry: libc::c_int,
    pub body: ZipfileBuffer,
    pub cds: ZipfileBuffer,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3expert {
    pub iSample: libc::c_int,
    pub db: *mut sqlite3,
    pub dbm: *mut sqlite3,
    pub dbv: *mut sqlite3,
    pub pTable: *mut IdxTable,
    pub pScan: *mut IdxScan,
    pub pWrite: *mut IdxWrite,
    pub pStatement: *mut IdxStatement,
    pub bRun: libc::c_int,
    pub pzErrmsg: *mut *mut libc::c_char,
    pub rc: libc::c_int,
    pub hIdx: IdxHash,
    pub zCandidates: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHash {
    pub pFirst: *mut IdxHashEntry,
    pub aHash: [*mut IdxHashEntry; 1023],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHashEntry {
    pub zKey: *mut libc::c_char,
    pub zVal: *mut libc::c_char,
    pub zVal2: *mut libc::c_char,
    pub pHashNext: *mut IdxHashEntry,
    pub pNext: *mut IdxHashEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxStatement {
    pub iId: libc::c_int,
    pub zSql: *mut libc::c_char,
    pub zIdx: *mut libc::c_char,
    pub zEQP: *mut libc::c_char,
    pub pNext: *mut IdxStatement,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxWrite {
    pub pTab: *mut IdxTable,
    pub eOp: libc::c_int,
    pub pNext: *mut IdxWrite,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxTable {
    pub nCol: libc::c_int,
    pub zName: *mut libc::c_char,
    pub aCol: *mut IdxColumn,
    pub pNext: *mut IdxTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxColumn {
    pub zName: *mut libc::c_char,
    pub zColl: *mut libc::c_char,
    pub iPk: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxScan {
    pub pTab: *mut IdxTable,
    pub iDb: libc::c_int,
    pub covering: i64_0,
    pub pOrder: *mut IdxConstraint,
    pub pEq: *mut IdxConstraint,
    pub pRange: *mut IdxConstraint,
    pub pNextScan: *mut IdxScan,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxConstraint {
    pub zColl: *mut libc::c_char,
    pub bRange: libc::c_int,
    pub iCol: libc::c_int,
    pub bFlag: libc::c_int,
    pub bDesc: libc::c_int,
    pub pNext: *mut IdxConstraint,
    pub pLink: *mut IdxConstraint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertCsr {
    pub base: sqlite3_vtab_cursor,
    pub pData: *mut sqlite3_stmt,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertVtab {
    pub base: sqlite3_vtab,
    pub pTab: *mut IdxTable,
    pub pExpert: *mut sqlite3expert,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemCtx {
    pub nSlot: libc::c_int,
    pub aSlot: [IdxRemSlot; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemSlot {
    pub eType: libc::c_int,
    pub iVal: i64_0,
    pub rVal: libc::c_double,
    pub nByte: libc::c_int,
    pub n: libc::c_int,
    pub z: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxSampleCtx {
    pub iTarget: libc::c_int,
    pub target: libc::c_double,
    pub nRow: libc::c_double,
    pub nRet: libc::c_double,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_recover {
    pub dbIn: *mut sqlite3,
    pub zDb: *mut libc::c_char,
    pub zUri: *mut libc::c_char,
    pub pSqlCtx: *mut libc::c_void,
    pub xSql: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int,
    >,
    pub zStateDb: *mut libc::c_char,
    pub zLostAndFound: *mut libc::c_char,
    pub bFreelistCorrupt: libc::c_int,
    pub bRecoverRowid: libc::c_int,
    pub bSlowIndexes: libc::c_int,
    pub pgsz: libc::c_int,
    pub detected_pgsz: libc::c_int,
    pub nReserve: libc::c_int,
    pub pPage1Disk: *mut u8_0,
    pub pPage1Cache: *mut u8_0,
    pub errCode: libc::c_int,
    pub zErrMsg: *mut libc::c_char,
    pub eState: libc::c_int,
    pub bCloseTransaction: libc::c_int,
    pub w1: RecoverStateW1,
    pub laf: RecoverStateLAF,
    pub dbOut: *mut sqlite3,
    pub pGetPage: *mut sqlite3_stmt,
    pub pTblList: *mut RecoverTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverTable {
    pub iRoot: u32_0,
    pub zTab: *mut libc::c_char,
    pub nCol: libc::c_int,
    pub aCol: *mut RecoverColumn,
    pub bIntkey: libc::c_int,
    pub iRowidBind: libc::c_int,
    pub pNext: *mut RecoverTable,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverColumn {
    pub iField: libc::c_int,
    pub iBind: libc::c_int,
    pub bIPK: libc::c_int,
    pub zCol: *mut libc::c_char,
    pub eHidden: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverStateLAF {
    pub pUsed: *mut RecoverBitmap,
    pub nPg: i64_0,
    pub pAllAndParent: *mut sqlite3_stmt,
    pub pMapInsert: *mut sqlite3_stmt,
    pub pMaxField: *mut sqlite3_stmt,
    pub pUsedPages: *mut sqlite3_stmt,
    pub pFindRoot: *mut sqlite3_stmt,
    pub pInsert: *mut sqlite3_stmt,
    pub pAllPage: *mut sqlite3_stmt,
    pub pPageData: *mut sqlite3_stmt,
    pub apVal: *mut *mut sqlite3_value,
    pub nMaxField: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverBitmap {
    pub nPg: i64_0,
    pub aElem: [u32_0; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverStateW1 {
    pub pTbls: *mut sqlite3_stmt,
    pub pSel: *mut sqlite3_stmt,
    pub pInsert: *mut sqlite3_stmt,
    pub nInsert: libc::c_int,
    pub pTab: *mut RecoverTable,
    pub nMax: libc::c_int,
    pub apVal: *mut *mut sqlite3_value,
    pub nVal: libc::c_int,
    pub bHaveRowid: libc::c_int,
    pub iRowid: i64_0,
    pub iPrevPage: i64_0,
    pub iPrevCell: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverGlobal {
    pub pMethods: *const sqlite3_io_methods,
    pub p: *mut sqlite3_recover,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Func {
    pub zName: *const libc::c_char,
    pub nArg: libc::c_int,
    pub xFunc: Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbdataCursor {
    pub base: sqlite3_vtab_cursor,
    pub pStmt: *mut sqlite3_stmt,
    pub iPgno: libc::c_int,
    pub aPage: *mut u8_0,
    pub nPage: libc::c_int,
    pub nCell: libc::c_int,
    pub iCell: libc::c_int,
    pub bOnePage: libc::c_int,
    pub szDb: libc::c_int,
    pub iRowid: sqlite3_int64,
    pub pRec: *mut u8_0,
    pub nRec: sqlite3_int64,
    pub nHdr: sqlite3_int64,
    pub iField: libc::c_int,
    pub pHdrPtr: *mut u8_0,
    pub pPtr: *mut u8_0,
    pub enc: u32_0,
    pub iIntkey: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbdataTable {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
    pub pStmt: *mut sqlite3_stmt,
    pub bPtr: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertInfo {
    pub pExpert: *mut sqlite3expert,
    pub bVerbose: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraphRow {
    pub iEqpId: libc::c_int,
    pub iParentId: libc::c_int,
    pub pNext: *mut EQPGraphRow,
    pub zText: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraph {
    pub pRow: *mut EQPGraphRow,
    pub pLast: *mut EQPGraphRow,
    pub zPrefix: [libc::c_char; 100],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ColModeOpts {
    pub iWrap: libc::c_int,
    pub bQuote: u8_0,
    pub bWordWrap: u8_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellState {
    pub db: *mut sqlite3,
    pub autoExplain: u8_0,
    pub autoEQP: u8_0,
    pub autoEQPtest: u8_0,
    pub autoEQPtrace: u8_0,
    pub scanstatsOn: u8_0,
    pub openMode: u8_0,
    pub doXdgOpen: u8_0,
    pub nEqpLevel: u8_0,
    pub eTraceType: u8_0,
    pub bSafeMode: u8_0,
    pub bSafeModePersist: u8_0,
    pub cmOpts: ColModeOpts,
    pub statsOn: libc::c_uint,
    pub mEqpLines: libc::c_uint,
    pub inputNesting: libc::c_int,
    pub outCount: libc::c_int,
    pub cnt: libc::c_int,
    pub lineno: libc::c_int,
    pub openFlags: libc::c_int,
    pub in_0: *mut FILE,
    pub out: *mut FILE,
    pub traceOut: *mut FILE,
    pub nErr: libc::c_int,
    pub mode: libc::c_int,
    pub modePrior: libc::c_int,
    pub cMode: libc::c_int,
    pub normalMode: libc::c_int,
    pub writableSchema: libc::c_int,
    pub showHeader: libc::c_int,
    pub nCheck: libc::c_int,
    pub nProgress: libc::c_uint,
    pub mxProgress: libc::c_uint,
    pub flgProgress: libc::c_uint,
    pub shellFlgs: libc::c_uint,
    pub priorShFlgs: libc::c_uint,
    pub szMax: sqlite3_int64,
    pub zDestTable: *mut libc::c_char,
    pub zTempFile: *mut libc::c_char,
    pub zTestcase: [libc::c_char; 30],
    pub colSeparator: [libc::c_char; 20],
    pub rowSeparator: [libc::c_char; 20],
    pub colSepPrior: [libc::c_char; 20],
    pub rowSepPrior: [libc::c_char; 20],
    pub colWidth: *mut libc::c_int,
    pub actualWidth: *mut libc::c_int,
    pub nWidth: libc::c_int,
    pub nullValue: [libc::c_char; 20],
    pub outfile: [libc::c_char; 4096],
    pub pStmt: *mut sqlite3_stmt,
    pub pLog: *mut FILE,
    pub aAuxDb: [AuxDb; 5],
    pub pAuxDb: *mut AuxDb,
    pub aiIndent: *mut libc::c_int,
    pub nIndent: libc::c_int,
    pub iIndent: libc::c_int,
    pub zNonce: *mut libc::c_char,
    pub sGraph: EQPGraph,
    pub expert: ExpertInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AuxDb {
    pub db: *mut sqlite3,
    pub zDbFilename: *const libc::c_char,
    pub zFreeOnClose: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub zPattern: *const libc::c_char,
    pub zDesc: *const libc::c_char,
}
pub const HW_SummaryOnly: HelpWanted = 1;
pub type HelpWanted = libc::c_uint;
pub const HW_Undoc: HelpWanted = 2;
pub const HW_NoCull: HelpWanted = 0;
pub const HH_Summary: HelpHave = 1;
pub type HelpHave = libc::c_uint;
pub const HH_More: HelpHave = 0;
pub const HH_Undoc: HelpHave = 2;
pub type QuickScanState = libc::c_uint;
pub const QSS_Start: QuickScanState = 0;
pub const QSS_ScanMask: QuickScanState = 768;
pub const QSS_CharMask: QuickScanState = 255;
pub const QSS_EndingSemi: QuickScanState = 512;
pub const QSS_HasDark: QuickScanState = 256;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub unSafe: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub zLimitName: *const libc::c_char,
    pub limitCode: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ImportCtx {
    pub zFile: *const libc::c_char,
    pub in_0: *mut FILE,
    pub xCloser: Option::<unsafe extern "C" fn(*mut FILE) -> libc::c_int>,
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
    pub nLine: libc::c_int,
    pub nRow: libc::c_int,
    pub nErr: libc::c_int,
    pub bNotFirst: libc::c_int,
    pub cTerm: libc::c_int,
    pub cColSep: libc::c_int,
    pub cRowSep: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
    pub zName: *const libc::c_char,
    pub zSql: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub zName: *const libc::c_char,
    pub ofst: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbConfigChoices {
    pub zName: *const libc::c_char,
    pub op: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArCommand {
    pub eCmd: u8_0,
    pub bVerbose: u8_0,
    pub bZip: u8_0,
    pub bDryRun: u8_0,
    pub bAppend: u8_0,
    pub bGlob: u8_0,
    pub fromCmdLine: u8_0,
    pub nArg: libc::c_int,
    pub zSrcTable: *mut libc::c_char,
    pub zFile: *const libc::c_char,
    pub zDir: *const libc::c_char,
    pub azArg: *mut *mut libc::c_char,
    pub p: *mut ShellState,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArSwitch {
    pub zLong: *const libc::c_char,
    pub cShort: libc::c_char,
    pub eSwitch: u8_0,
    pub bArg: u8_0,
}
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    return if __c >= -(128 as libc::c_int) && __c < 256 as libc::c_int {
        *(*__ctype_tolower_loc()).offset(__c as isize)
    } else {
        __c
    };
}
#[inline]
unsafe extern "C" fn stat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    return __xstat(1 as libc::c_int, __path, __statbuf);
}
#[inline]
unsafe extern "C" fn lstat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    return __lxstat(1 as libc::c_int, __path, __statbuf);
}
static mut enableTimer: libc::c_int = 0 as libc::c_int;
unsafe extern "C" fn cli_strcmp(
    mut a: *const libc::c_char,
    mut b: *const libc::c_char,
) -> libc::c_int {
    if a.is_null() {
        a = b"\0" as *const u8 as *const libc::c_char;
    }
    if b.is_null() {
        b = b"\0" as *const u8 as *const libc::c_char;
    }
    return strcmp(a, b);
}
unsafe extern "C" fn cli_strncmp(
    mut a: *const libc::c_char,
    mut b: *const libc::c_char,
    n: size_t,
) -> libc::c_int {
    if a.is_null() {
        a = b"\0" as *const u8 as *const libc::c_char;
    }
    if b.is_null() {
        b = b"\0" as *const u8 as *const libc::c_char;
    }
    return strncmp(a, b, n);
}
unsafe extern "C" fn timeOfDay() -> sqlite3_int64 {
    static mut clockVfs: *mut sqlite3_vfs = 0 as *const sqlite3_vfs as *mut sqlite3_vfs;
    let mut t: sqlite3_int64 = 0;
    if clockVfs.is_null() {
        clockVfs = sqlite3_vfs_find(0 as *const libc::c_char);
    }
    if clockVfs.is_null() {
        return 0 as libc::c_int as sqlite3_int64;
    }
    if (*clockVfs).iVersion >= 2 as libc::c_int
        && ((*clockVfs).xCurrentTimeInt64).is_some()
    {
        ((*clockVfs).xCurrentTimeInt64)
            .expect("non-null function pointer")(clockVfs, &mut t);
    } else {
        let mut r: libc::c_double = 0.;
        ((*clockVfs).xCurrentTime).expect("non-null function pointer")(clockVfs, &mut r);
        t = (r * 86400000.0f64) as sqlite3_int64;
    }
    return t;
}
static mut sBegin: rusage = rusage {
    ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
    ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
    c2rust_unnamed: C2RustUnnamed_13 { ru_maxrss: 0 },
    c2rust_unnamed_0: C2RustUnnamed_12 { ru_ixrss: 0 },
    c2rust_unnamed_1: C2RustUnnamed_11 { ru_idrss: 0 },
    c2rust_unnamed_2: C2RustUnnamed_10 { ru_isrss: 0 },
    c2rust_unnamed_3: C2RustUnnamed_9 { ru_minflt: 0 },
    c2rust_unnamed_4: C2RustUnnamed_8 { ru_majflt: 0 },
    c2rust_unnamed_5: C2RustUnnamed_7 { ru_nswap: 0 },
    c2rust_unnamed_6: C2RustUnnamed_6 { ru_inblock: 0 },
    c2rust_unnamed_7: C2RustUnnamed_5 { ru_oublock: 0 },
    c2rust_unnamed_8: C2RustUnnamed_4 { ru_msgsnd: 0 },
    c2rust_unnamed_9: C2RustUnnamed_3 { ru_msgrcv: 0 },
    c2rust_unnamed_10: C2RustUnnamed_2 { ru_nsignals: 0 },
    c2rust_unnamed_11: C2RustUnnamed_1 { ru_nvcsw: 0 },
    c2rust_unnamed_12: C2RustUnnamed_0 { ru_nivcsw: 0 },
};
static mut iBegin: sqlite3_int64 = 0;
unsafe extern "C" fn beginTimer() {
    if enableTimer != 0 {
        getrusage(RUSAGE_SELF as libc::c_int, &mut sBegin);
        iBegin = timeOfDay();
    }
}
unsafe extern "C" fn timeDiff(
    pStart: *mut timeval,
    pEnd: *mut timeval,
) -> libc::c_double {
    return ((*pEnd).tv_usec - (*pStart).tv_usec) as libc::c_double * 0.000001f64
        + ((*pEnd).tv_sec - (*pStart).tv_sec) as libc::c_double;
}
unsafe extern "C" fn endTimer() {
    if enableTimer != 0 {
        let iEnd: sqlite3_int64 = timeOfDay();
        let mut sEnd: rusage = rusage {
            ru_utime: timeval { tv_sec: 0, tv_usec: 0 },
            ru_stime: timeval { tv_sec: 0, tv_usec: 0 },
            c2rust_unnamed: C2RustUnnamed_13 { ru_maxrss: 0 },
            c2rust_unnamed_0: C2RustUnnamed_12 { ru_ixrss: 0 },
            c2rust_unnamed_1: C2RustUnnamed_11 { ru_idrss: 0 },
            c2rust_unnamed_2: C2RustUnnamed_10 { ru_isrss: 0 },
            c2rust_unnamed_3: C2RustUnnamed_9 { ru_minflt: 0 },
            c2rust_unnamed_4: C2RustUnnamed_8 { ru_majflt: 0 },
            c2rust_unnamed_5: C2RustUnnamed_7 { ru_nswap: 0 },
            c2rust_unnamed_6: C2RustUnnamed_6 { ru_inblock: 0 },
            c2rust_unnamed_7: C2RustUnnamed_5 { ru_oublock: 0 },
            c2rust_unnamed_8: C2RustUnnamed_4 { ru_msgsnd: 0 },
            c2rust_unnamed_9: C2RustUnnamed_3 { ru_msgrcv: 0 },
            c2rust_unnamed_10: C2RustUnnamed_2 { ru_nsignals: 0 },
            c2rust_unnamed_11: C2RustUnnamed_1 { ru_nvcsw: 0 },
            c2rust_unnamed_12: C2RustUnnamed_0 { ru_nivcsw: 0 },
        };
        getrusage(RUSAGE_SELF as libc::c_int, &mut sEnd);
        printf(
            b"Run Time: real %.3f user %f sys %f\n\0" as *const u8
                as *const libc::c_char,
            (iEnd - iBegin) as libc::c_double * 0.001f64,
            timeDiff(&mut sBegin.ru_utime, &mut sEnd.ru_utime),
            timeDiff(&mut sBegin.ru_stime, &mut sEnd.ru_stime),
        );
    }
}
static mut bail_on_error: libc::c_int = 0 as libc::c_int;
static mut stdin_is_interactive: libc::c_int = 1 as libc::c_int;
static mut stdout_is_console: libc::c_int = 1 as libc::c_int;
static mut globalDb: *mut sqlite3 = 0 as *const sqlite3 as *mut sqlite3;
static mut seenInterrupt: libc::c_int = 0 as libc::c_int;
static mut Argv0: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
static mut mainPrompt: [libc::c_char; 20] = [0; 20];
static mut continuePrompt: [libc::c_char; 20] = [0; 20];
unsafe extern "C" fn shell_strncpy(
    dest: *mut libc::c_char,
    src: *const libc::c_char,
    n: size_t,
) -> *mut libc::c_char {
    let mut i: size_t = 0;
    i = 0 as libc::c_int as size_t;
    while i < n.wrapping_sub(1 as libc::c_int as libc::c_ulong)
        && *src.offset(i as isize) as libc::c_int != 0 as libc::c_int
    {
        *dest.offset(i as isize) = *src.offset(i as isize);
        i = i.wrapping_add(1);
        i;
    }
    *dest.offset(i as isize) = 0 as libc::c_int as libc::c_char;
    return dest;
}
static mut dynPrompt: DynaPrompt = {
    let init = DynaPrompt {
        dynamicPrompt: [
            0 as libc::c_int as libc::c_char,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ],
        acAwait: [0 as libc::c_int as libc::c_char, 0],
        inParenLevel: 0 as libc::c_int,
        zScannerAwaits: 0 as *const libc::c_char as *mut libc::c_char,
    };
    init
};
unsafe extern "C" fn trackParenLevel(p: *mut DynaPrompt, ni: libc::c_int) {
    (*p).inParenLevel += ni;
    if ni == 0 as libc::c_int {
        (*p).inParenLevel = 0 as libc::c_int;
    }
    (*p).zScannerAwaits = 0 as *mut libc::c_char;
}
unsafe extern "C" fn setLexemeOpen(
    p: *mut DynaPrompt,
    s: *mut libc::c_char,
    c: libc::c_char,
) {
    if !s.is_null() || c as libc::c_int == 0 as libc::c_int {
        (*p).zScannerAwaits = s;
        (*p).acAwait[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    } else {
        (*p).acAwait[0 as libc::c_int as usize] = c;
        (*p).zScannerAwaits = ((*p).acAwait).as_mut_ptr();
    };
}
unsafe extern "C" fn dynamicContinuePrompt() -> *mut libc::c_char {
    if continuePrompt[0 as libc::c_int as usize] as libc::c_int == 0 as libc::c_int
        || (dynPrompt.zScannerAwaits).is_null()
            && dynPrompt.inParenLevel == 0 as libc::c_int
    {
        return continuePrompt.as_mut_ptr()
    } else if !(dynPrompt.zScannerAwaits).is_null() {
        let ncp: size_t = strlen(continuePrompt.as_mut_ptr());
        let mut ndp: size_t = strlen(dynPrompt.zScannerAwaits);
        if ndp > ncp.wrapping_sub(3 as libc::c_int as libc::c_ulong) {
            return continuePrompt.as_mut_ptr();
        }
        strcpy((dynPrompt.dynamicPrompt).as_mut_ptr(), dynPrompt.zScannerAwaits);
        while ndp < 3 as libc::c_int as libc::c_ulong {
            let fresh0 = ndp;
            ndp = ndp.wrapping_add(1);
            dynPrompt.dynamicPrompt[fresh0 as usize] = ' ' as i32 as libc::c_char;
        }
        shell_strncpy(
            (dynPrompt.dynamicPrompt).as_mut_ptr().offset(3 as libc::c_int as isize),
            continuePrompt.as_mut_ptr().offset(3 as libc::c_int as isize),
            (20 as libc::c_int - 4 as libc::c_int) as size_t,
        );
    } else {
        if dynPrompt.inParenLevel > 9 as libc::c_int {
            shell_strncpy(
                (dynPrompt.dynamicPrompt).as_mut_ptr(),
                b"(..\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as size_t,
            );
        } else if dynPrompt.inParenLevel < 0 as libc::c_int {
            shell_strncpy(
                (dynPrompt.dynamicPrompt).as_mut_ptr(),
                b")x!\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as size_t,
            );
        } else {
            shell_strncpy(
                (dynPrompt.dynamicPrompt).as_mut_ptr(),
                b"(x.\0" as *const u8 as *const libc::c_char,
                4 as libc::c_int as size_t,
            );
            dynPrompt
                .dynamicPrompt[2 as libc::c_int
                as usize] = ('0' as i32 + dynPrompt.inParenLevel) as libc::c_char;
        }
        shell_strncpy(
            (dynPrompt.dynamicPrompt).as_mut_ptr().offset(3 as libc::c_int as isize),
            continuePrompt.as_mut_ptr().offset(3 as libc::c_int as isize),
            (20 as libc::c_int - 4 as libc::c_int) as size_t,
        );
    }
    return (dynPrompt.dynamicPrompt).as_mut_ptr();
}
unsafe extern "C" fn shell_out_of_memory() {
    fprintf(stderr, b"Error: out of memory\n\0" as *const u8 as *const libc::c_char);
    exit(1 as libc::c_int);
}
unsafe extern "C" fn shell_check_oom(p: *const libc::c_void) {
    if p.is_null() {
        shell_out_of_memory();
    }
}
unsafe extern "C" fn utf8_width_print(
    pOut: *mut FILE,
    w: libc::c_int,
    mut zUtf: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let aw: libc::c_int = if w < 0 as libc::c_int { -w } else { w };
    if zUtf.is_null() {
        zUtf = b"\0" as *const u8 as *const libc::c_char;
    }
    n = 0 as libc::c_int;
    i = n;
    while *zUtf.offset(i as isize) != 0 {
        if *zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
            != 0x80 as libc::c_int
        {
            n += 1;
            n;
            if n == aw {
                loop {
                    i += 1;
                    i;
                    if !(*zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                        == 0x80 as libc::c_int)
                    {
                        break;
                    }
                }
                break;
            }
        }
        i += 1;
        i;
    }
    if n >= aw {
        fprintf(pOut, b"%.*s\0" as *const u8 as *const libc::c_char, i, zUtf);
    } else if w < 0 as libc::c_int {
        fprintf(
            pOut,
            b"%*s%s\0" as *const u8 as *const libc::c_char,
            aw - n,
            b"\0" as *const u8 as *const libc::c_char,
            zUtf,
        );
    } else {
        fprintf(
            pOut,
            b"%s%*s\0" as *const u8 as *const libc::c_char,
            zUtf,
            aw - n,
            b"\0" as *const u8 as *const libc::c_char,
        );
    };
}
unsafe extern "C" fn isNumber(
    mut z: *const libc::c_char,
    realnum: *mut libc::c_int,
) -> libc::c_int {
    if *z as libc::c_int == '-' as i32 || *z as libc::c_int == '+' as i32 {
        z = z.offset(1);
        z;
    }
    if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
    {
        return 0 as libc::c_int;
    }
    z = z.offset(1);
    z;
    if !realnum.is_null() {
        *realnum = 0 as libc::c_int;
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        z = z.offset(1);
        z;
    }
    if *z as libc::c_int == '.' as i32 {
        z = z.offset(1);
        z;
        if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            return 0 as libc::c_int;
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1);
            z;
        }
        if !realnum.is_null() {
            *realnum = 1 as libc::c_int;
        }
    }
    if *z as libc::c_int == 'e' as i32 || *z as libc::c_int == 'E' as i32 {
        z = z.offset(1);
        z;
        if *z as libc::c_int == '+' as i32 || *z as libc::c_int == '-' as i32 {
            z = z.offset(1);
            z;
        }
        if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            return 0 as libc::c_int;
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1);
            z;
        }
        if !realnum.is_null() {
            *realnum = 1 as libc::c_int;
        }
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn strlen30(z: *const libc::c_char) -> libc::c_int {
    let mut z2: *const libc::c_char = z;
    while *z2 != 0 {
        z2 = z2.offset(1);
        z2;
    }
    return 0x3fffffff as libc::c_int & z2.offset_from(z) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn strlenChar(mut z: *const libc::c_char) -> libc::c_int {
    let mut n: libc::c_int = 0 as libc::c_int;
    while *z != 0 {
        let fresh1 = z;
        z = z.offset(1);
        if 0xc0 as libc::c_int & *fresh1 as libc::c_int != 0x80 as libc::c_int {
            n += 1;
            n;
        }
    }
    return n;
}
unsafe extern "C" fn openChrSource(zFile: *const libc::c_char) -> *mut FILE {
    let mut x: stat = {
        let init = stat {
            st_dev: 0 as libc::c_int as __dev_t,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
            st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
            st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
            __glibc_reserved: [0; 3],
        };
        init
    };
    let rc: libc::c_int = stat(zFile, &mut x);
    if rc != 0 as libc::c_int {
        return 0 as *mut FILE;
    }
    if x.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o10000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o20000 as libc::c_int as libc::c_uint
    {
        return fopen(zFile, b"rb\0" as *const u8 as *const libc::c_char)
    } else {
        return 0 as *mut FILE
    };
}
unsafe extern "C" fn local_getline(
    mut zLine: *mut libc::c_char,
    in_0: *mut FILE,
) -> *mut libc::c_char {
    let mut nLine: libc::c_int = if zLine.is_null() {
        0 as libc::c_int
    } else {
        100 as libc::c_int
    };
    let mut n: libc::c_int = 0 as libc::c_int;
    loop {
        if n + 100 as libc::c_int > nLine {
            nLine = nLine * 2 as libc::c_int + 100 as libc::c_int;
            zLine = realloc(zLine as *mut libc::c_void, nLine as libc::c_ulong)
                as *mut libc::c_char;
            shell_check_oom(zLine as *const libc::c_void);
        }
        if (fgets(&mut *zLine.offset(n as isize), nLine - n, in_0)).is_null() {
            if n == 0 as libc::c_int {
                free(zLine as *mut libc::c_void);
                return 0 as *mut libc::c_char;
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        } else {
            while *zLine.offset(n as isize) != 0 {
                n += 1;
                n;
            }
            if !(n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\n' as i32)
            {
                continue;
            }
            n -= 1;
            n;
            if n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\r' as i32
            {
                n -= 1;
                n;
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        }
    }
    return zLine;
}
unsafe extern "C" fn one_input_line(
    in_0: *mut FILE,
    zPrior: *mut libc::c_char,
    isContinuation: libc::c_int,
) -> *mut libc::c_char {
    let mut zPrompt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zResult: *mut libc::c_char = 0 as *mut libc::c_char;
    if !in_0.is_null() {
        zResult = local_getline(zPrior, in_0);
    } else {
        zPrompt = if isContinuation != 0 {
            dynamicContinuePrompt()
        } else {
            mainPrompt.as_mut_ptr()
        };
        free(zPrior as *mut libc::c_void);
        zResult = readline(zPrompt);
        while zResult.is_null() {
            sqlite3_sleep(50 as libc::c_int);
            if seenInterrupt == 0 as libc::c_int {
                break;
            }
            zResult = readline(b"\0" as *const u8 as *const libc::c_char);
        }
        if !zResult.is_null() && *zResult as libc::c_int != 0 {
            add_history(zResult);
        }
    }
    return zResult;
}
unsafe extern "C" fn hexDigitValue(c: libc::c_char) -> libc::c_int {
    if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
        return c as libc::c_int - '0' as i32;
    }
    if c as libc::c_int >= 'a' as i32 && c as libc::c_int <= 'f' as i32 {
        return c as libc::c_int - 'a' as i32 + 10 as libc::c_int;
    }
    if c as libc::c_int >= 'A' as i32 && c as libc::c_int <= 'F' as i32 {
        return c as libc::c_int - 'A' as i32 + 10 as libc::c_int;
    }
    return -(1 as libc::c_int);
}
unsafe extern "C" fn integerValue(mut zArg: *const libc::c_char) -> sqlite3_int64 {
    let mut v: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    static mut aMult: [C2RustUnnamed_14; 9] = [
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"KiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"MiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"GiB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"KB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"MB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"GB\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"K\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"M\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_14 {
                zSuffix: b"G\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut isNeg: libc::c_int = 0 as libc::c_int;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        isNeg = 1 as libc::c_int;
        zArg = zArg.offset(1);
        zArg;
    } else if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32 {
        zArg = zArg.offset(1);
        zArg;
    }
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        let mut x: libc::c_int = 0;
        zArg = zArg.offset(2 as libc::c_int as isize);
        loop {
            x = hexDigitValue(*zArg.offset(0 as libc::c_int as isize));
            if !(x >= 0 as libc::c_int) {
                break;
            }
            v = (v << 4 as libc::c_int) + x as libc::c_longlong;
            zArg = zArg.offset(1);
            zArg;
        }
    } else {
        while *(*__ctype_b_loc())
            .offset(
                *zArg.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                    as isize,
            ) as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            v = v * 10 as libc::c_int as libc::c_longlong
                + *zArg.offset(0 as libc::c_int as isize) as libc::c_longlong
                - '0' as i32 as libc::c_longlong;
            zArg = zArg.offset(1);
            zArg;
        }
    }
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<[C2RustUnnamed_14; 9]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_14>() as libc::c_ulong)
            as libc::c_int
    {
        if sqlite3_stricmp(aMult[i as usize].zSuffix, zArg) == 0 as libc::c_int {
            v *= aMult[i as usize].iMult as libc::c_longlong;
            break;
        } else {
            i += 1;
            i;
        }
    }
    return if isNeg != 0 { -v } else { v };
}
unsafe extern "C" fn initText(p: *mut ShellText) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ShellText>() as libc::c_ulong,
    );
}
unsafe extern "C" fn freeText(p: *mut ShellText) {
    free((*p).z as *mut libc::c_void);
    initText(p);
}
unsafe extern "C" fn appendText(
    p: *mut ShellText,
    zAppend: *const libc::c_char,
    quote: libc::c_char,
) {
    let mut len: i64_0 = 0;
    let mut i: i64_0 = 0;
    let nAppend: i64_0 = strlen30(zAppend) as i64_0;
    len = nAppend + (*p).n as libc::c_longlong + 1 as libc::c_int as libc::c_longlong;
    if quote != 0 {
        len += 2 as libc::c_int as libc::c_longlong;
        i = 0 as libc::c_int as i64_0;
        while i < nAppend {
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                len += 1;
                len;
            }
            i += 1;
            i;
        }
    }
    if ((*p).z).is_null()
        || (*p).n as libc::c_longlong + len >= (*p).nAlloc as libc::c_longlong
    {
        (*p)
            .nAlloc = (((*p).nAlloc * 2 as libc::c_int) as libc::c_longlong + len
            + 20 as libc::c_int as libc::c_longlong) as libc::c_int;
        (*p)
            .z = realloc((*p).z as *mut libc::c_void, (*p).nAlloc as libc::c_ulong)
            as *mut libc::c_char;
        shell_check_oom((*p).z as *const libc::c_void);
    }
    if quote != 0 {
        let mut zCsr: *mut libc::c_char = ((*p).z).offset((*p).n as isize);
        let fresh2 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh2 = quote;
        i = 0 as libc::c_int as i64_0;
        while i < nAppend {
            let fresh3 = zCsr;
            zCsr = zCsr.offset(1);
            *fresh3 = *zAppend.offset(i as isize);
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                let fresh4 = zCsr;
                zCsr = zCsr.offset(1);
                *fresh4 = quote;
            }
            i += 1;
            i;
        }
        let fresh5 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh5 = quote;
        (*p).n = zCsr.offset_from((*p).z) as libc::c_long as libc::c_int;
        *zCsr = '\0' as i32 as libc::c_char;
    } else {
        memcpy(
            ((*p).z).offset((*p).n as isize) as *mut libc::c_void,
            zAppend as *const libc::c_void,
            nAppend as libc::c_ulong,
        );
        (*p).n = ((*p).n as libc::c_longlong + nAppend) as libc::c_int;
        *((*p).z).offset((*p).n as isize) = '\0' as i32 as libc::c_char;
    };
}
unsafe extern "C" fn quoteChar(zName: *const libc::c_char) -> libc::c_char {
    let mut i: libc::c_int = 0;
    if zName.is_null() {
        return '"' as i32 as libc::c_char;
    }
    if *(*__ctype_b_loc())
        .offset(
            *zName.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                as isize,
        ) as libc::c_int & _ISalpha as libc::c_int as libc::c_ushort as libc::c_int == 0
        && *zName.offset(0 as libc::c_int as isize) as libc::c_int != '_' as i32
    {
        return '"' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while *zName.offset(i as isize) != 0 {
        if *(*__ctype_b_loc())
            .offset(*zName.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
            == 0 && *zName.offset(i as isize) as libc::c_int != '_' as i32
        {
            return '"' as i32 as libc::c_char;
        }
        i += 1;
        i;
    }
    return (if sqlite3_keyword_check(zName, i) != 0 {
        '"' as i32
    } else {
        0 as libc::c_int
    }) as libc::c_char;
}
unsafe extern "C" fn shellFakeSchema(
    db: *mut sqlite3,
    zSchema: *const libc::c_char,
    zName: *const libc::c_char,
) -> *mut libc::c_char {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: ShellText = ShellText {
        z: 0 as *mut libc::c_char,
        n: 0,
        nAlloc: 0,
    };
    let mut cQuote: libc::c_char = 0;
    let mut zDiv: *mut libc::c_char = b"(\0" as *const u8 as *const libc::c_char
        as *mut libc::c_char;
    let mut nRow: libc::c_int = 0 as libc::c_int;
    zSql = sqlite3_mprintf(
        b"PRAGMA \"%w\".table_info=%Q;\0" as *const u8 as *const libc::c_char,
        if !zSchema.is_null() {
            zSchema
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        },
        zName,
    );
    shell_check_oom(zSql as *const libc::c_void);
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    initText(&mut s);
    if !zSchema.is_null() {
        cQuote = quoteChar(zSchema);
        if cQuote as libc::c_int != 0
            && sqlite3_stricmp(zSchema, b"temp\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            cQuote = 0 as libc::c_int as libc::c_char;
        }
        appendText(&mut s, zSchema, cQuote);
        appendText(
            &mut s,
            b".\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    cQuote = quoteChar(zName);
    appendText(&mut s, zName, cQuote);
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        let mut zCol: *const libc::c_char = sqlite3_column_text(pStmt, 1 as libc::c_int)
            as *const libc::c_char;
        nRow += 1;
        nRow;
        appendText(&mut s, zDiv, 0 as libc::c_int as libc::c_char);
        zDiv = b",\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        if zCol.is_null() {
            zCol = b"\0" as *const u8 as *const libc::c_char;
        }
        cQuote = quoteChar(zCol);
        appendText(&mut s, zCol, cQuote);
    }
    appendText(
        &mut s,
        b")\0" as *const u8 as *const libc::c_char,
        0 as libc::c_int as libc::c_char,
    );
    sqlite3_finalize(pStmt);
    if nRow == 0 as libc::c_int {
        freeText(&mut s);
        s.z = 0 as *mut libc::c_char;
    }
    return s.z;
}
unsafe extern "C" fn shellStrtod(
    pCtx: *mut sqlite3_context,
    _nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    let z: *mut libc::c_char = sqlite3_value_text(
        *apVal.offset(0 as libc::c_int as isize),
    ) as *mut libc::c_char;
    if z.is_null() {
        return;
    }
    sqlite3_result_double(pCtx, strtod(z, 0 as *mut *mut libc::c_char));
}
unsafe extern "C" fn shellDtostr(
    pCtx: *mut sqlite3_context,
    nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    let r: libc::c_double = sqlite3_value_double(
        *apVal.offset(0 as libc::c_int as isize),
    );
    let mut n: libc::c_int = if nVal >= 2 as libc::c_int {
        sqlite3_value_int(*apVal.offset(1 as libc::c_int as isize))
    } else {
        26 as libc::c_int
    };
    let mut z: [libc::c_char; 400] = [0; 400];
    if n < 1 as libc::c_int {
        n = 1 as libc::c_int;
    }
    if n > 350 as libc::c_int {
        n = 350 as libc::c_int;
    }
    sprintf(z.as_mut_ptr(), b"%#+.*e\0" as *const u8 as *const libc::c_char, n, r);
    sqlite3_result_text(
        pCtx,
        z.as_mut_ptr(),
        -(1 as libc::c_int),
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn shellModuleSchema(
    pCtx: *mut sqlite3_context,
    _nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
    zName = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    zFake = if !zName.is_null() {
        shellFakeSchema(sqlite3_context_db_handle(pCtx), 0 as *const libc::c_char, zName)
    } else {
        0 as *mut libc::c_char
    };
    if !zFake.is_null() {
        sqlite3_result_text(
            pCtx,
            sqlite3_mprintf(b"/* %s */\0" as *const u8 as *const libc::c_char, zFake),
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
        free(zFake as *mut libc::c_void);
    }
}
unsafe extern "C" fn shellAddSchemaName(
    pCtx: *mut sqlite3_context,
    _nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    static mut aPrefix: [*const libc::c_char; 6] = [
        b"TABLE\0" as *const u8 as *const libc::c_char,
        b"INDEX\0" as *const u8 as *const libc::c_char,
        b"UNIQUE INDEX\0" as *const u8 as *const libc::c_char,
        b"VIEW\0" as *const u8 as *const libc::c_char,
        b"TRIGGER\0" as *const u8 as *const libc::c_char,
        b"VIRTUAL TABLE\0" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0 as libc::c_int;
    let zIn: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    let zSchema: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(1 as libc::c_int as isize),
    ) as *const libc::c_char;
    let zName: *const libc::c_char = sqlite3_value_text(
        *apVal.offset(2 as libc::c_int as isize),
    ) as *const libc::c_char;
    let db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    if !zIn.is_null()
        && cli_strncmp(
            zIn,
            b"CREATE \0" as *const u8 as *const libc::c_char,
            7 as libc::c_int as size_t,
        ) == 0 as libc::c_int
    {
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            let n: libc::c_int = strlen30(aPrefix[i as usize]);
            if cli_strncmp(
                zIn.offset(7 as libc::c_int as isize),
                aPrefix[i as usize],
                n as size_t,
            ) == 0 as libc::c_int
                && *zIn.offset((n + 7 as libc::c_int) as isize) as libc::c_int
                    == ' ' as i32
            {
                let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
                if !zSchema.is_null() {
                    let cQuote: libc::c_char = quoteChar(zSchema);
                    if cQuote as libc::c_int != 0
                        && sqlite3_stricmp(
                            zSchema,
                            b"temp\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                    {
                        z = sqlite3_mprintf(
                            b"%.*s \"%w\".%s\0" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%.*s %s.%s\0" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        );
                    }
                }
                if !zName.is_null()
                    && *(aPrefix[i as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_int == 'V' as i32
                    && {
                        zFake = shellFakeSchema(db, zSchema, zName);
                        !zFake.is_null()
                    }
                {
                    if z.is_null() {
                        z = sqlite3_mprintf(
                            b"%s\n/* %s */\0" as *const u8 as *const libc::c_char,
                            zIn,
                            zFake,
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%z\n/* %s */\0" as *const u8 as *const libc::c_char,
                            z,
                            zFake,
                        );
                    }
                    free(zFake as *mut libc::c_void);
                }
                if !z.is_null() {
                    sqlite3_result_text(
                        pCtx,
                        z,
                        -(1 as libc::c_int),
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    return;
                }
            }
            i += 1;
            i;
        }
    }
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
static mut memtraceBase: sqlite3_mem_methods = sqlite3_mem_methods {
    xMalloc: None,
    xFree: None,
    xRealloc: None,
    xSize: None,
    xRoundup: None,
    xInit: None,
    xShutdown: None,
    pAppData: 0 as *const libc::c_void as *mut libc::c_void,
};
static mut memtraceOut: *mut FILE = 0 as *const FILE as *mut FILE;
unsafe extern "C" fn memtraceMalloc(n: libc::c_int) -> *mut libc::c_void {
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: allocate %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xRoundup).expect("non-null function pointer")(n),
        );
    }
    return (memtraceBase.xMalloc).expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceFree(p: *mut libc::c_void) {
    if p.is_null() {
        return;
    }
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: free %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xSize).expect("non-null function pointer")(p),
        );
    }
    (memtraceBase.xFree).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRealloc(
    p: *mut libc::c_void,
    n: libc::c_int,
) -> *mut libc::c_void {
    if p.is_null() {
        return memtraceMalloc(n);
    }
    if n == 0 as libc::c_int {
        memtraceFree(p);
        return 0 as *mut libc::c_void;
    }
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: resize %d -> %d bytes\n\0" as *const u8 as *const libc::c_char,
            (memtraceBase.xSize).expect("non-null function pointer")(p),
            (memtraceBase.xRoundup).expect("non-null function pointer")(n),
        );
    }
    return (memtraceBase.xRealloc).expect("non-null function pointer")(p, n);
}
unsafe extern "C" fn memtraceSize(p: *mut libc::c_void) -> libc::c_int {
    return (memtraceBase.xSize).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRoundup(n: libc::c_int) -> libc::c_int {
    return (memtraceBase.xRoundup).expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceInit(p: *mut libc::c_void) -> libc::c_int {
    return (memtraceBase.xInit).expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceShutdown(p: *mut libc::c_void) {
    (memtraceBase.xShutdown).expect("non-null function pointer")(p);
}
static mut ersaztMethods: sqlite3_mem_methods = unsafe {
    {
        let init = sqlite3_mem_methods {
            xMalloc: Some(
                memtraceMalloc as unsafe extern "C" fn(libc::c_int) -> *mut libc::c_void,
            ),
            xFree: Some(memtraceFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
            xRealloc: Some(
                memtraceRealloc
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                    ) -> *mut libc::c_void,
            ),
            xSize: Some(
                memtraceSize as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xRoundup: Some(
                memtraceRoundup as unsafe extern "C" fn(libc::c_int) -> libc::c_int,
            ),
            xInit: Some(
                memtraceInit as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xShutdown: Some(
                memtraceShutdown as unsafe extern "C" fn(*mut libc::c_void) -> (),
            ),
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3MemTraceActivate(out: *mut FILE) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (memtraceBase.xMalloc).is_none() {
        rc = sqlite3_config(
            5 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            rc = sqlite3_config(
                4 as libc::c_int,
                &mut ersaztMethods as *mut sqlite3_mem_methods,
            );
        }
    }
    memtraceOut = out;
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3MemTraceDeactivate() -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (memtraceBase.xMalloc).is_some() {
        rc = sqlite3_config(
            4 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            memset(
                &mut memtraceBase as *mut sqlite3_mem_methods as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sqlite3_mem_methods>() as libc::c_ulong,
            );
        }
    }
    memtraceOut = 0 as *mut FILE;
    return rc;
}
static mut pcacheBase: sqlite3_pcache_methods2 = sqlite3_pcache_methods2 {
    iVersion: 0,
    pArg: 0 as *const libc::c_void as *mut libc::c_void,
    xInit: None,
    xShutdown: None,
    xCreate: None,
    xCachesize: None,
    xPagecount: None,
    xFetch: None,
    xUnpin: None,
    xRekey: None,
    xTruncate: None,
    xDestroy: None,
    xShrink: None,
};
static mut pcachetraceOut: *mut FILE = 0 as *const FILE as *mut FILE;
unsafe extern "C" fn pcachetraceInit(pArg: *mut libc::c_void) -> libc::c_int {
    let mut nRes: libc::c_int = 0;
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xInit(%p)\n\0" as *const u8 as *const libc::c_char,
            pArg,
        );
    }
    nRes = (pcacheBase.xInit).expect("non-null function pointer")(pArg);
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xInit(%p) -> %d\n\0" as *const u8 as *const libc::c_char,
            pArg,
            nRes,
        );
    }
    return nRes;
}
unsafe extern "C" fn pcachetraceShutdown(pArg: *mut libc::c_void) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xShutdown(%p)\n\0" as *const u8 as *const libc::c_char,
            pArg,
        );
    }
    (pcacheBase.xShutdown).expect("non-null function pointer")(pArg);
}
unsafe extern "C" fn pcachetraceCreate(
    szPage: libc::c_int,
    szExtra: libc::c_int,
    bPurge: libc::c_int,
) -> *mut sqlite3_pcache {
    let mut pRes: *mut sqlite3_pcache = 0 as *mut sqlite3_pcache;
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xCreate(%d,%d,%d)\n\0" as *const u8 as *const libc::c_char,
            szPage,
            szExtra,
            bPurge,
        );
    }
    pRes = (pcacheBase.xCreate)
        .expect("non-null function pointer")(szPage, szExtra, bPurge);
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xCreate(%d,%d,%d) -> %p\n\0" as *const u8
                as *const libc::c_char,
            szPage,
            szExtra,
            bPurge,
            pRes,
        );
    }
    return pRes;
}
unsafe extern "C" fn pcachetraceCachesize(
    p: *mut sqlite3_pcache,
    nCachesize: libc::c_int,
) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xCachesize(%p, %d)\n\0" as *const u8 as *const libc::c_char,
            p,
            nCachesize,
        );
    }
    (pcacheBase.xCachesize).expect("non-null function pointer")(p, nCachesize);
}
unsafe extern "C" fn pcachetracePagecount(p: *mut sqlite3_pcache) -> libc::c_int {
    let mut nRes: libc::c_int = 0;
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xPagecount(%p)\n\0" as *const u8 as *const libc::c_char,
            p,
        );
    }
    nRes = (pcacheBase.xPagecount).expect("non-null function pointer")(p);
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xPagecount(%p) -> %d\n\0" as *const u8 as *const libc::c_char,
            p,
            nRes,
        );
    }
    return nRes;
}
unsafe extern "C" fn pcachetraceFetch(
    p: *mut sqlite3_pcache,
    key: libc::c_uint,
    crFg: libc::c_int,
) -> *mut sqlite3_pcache_page {
    let mut pRes: *mut sqlite3_pcache_page = 0 as *mut sqlite3_pcache_page;
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xFetch(%p,%u,%d)\n\0" as *const u8 as *const libc::c_char,
            p,
            key,
            crFg,
        );
    }
    pRes = (pcacheBase.xFetch).expect("non-null function pointer")(p, key, crFg);
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xFetch(%p,%u,%d) -> %p\n\0" as *const u8
                as *const libc::c_char,
            p,
            key,
            crFg,
            pRes,
        );
    }
    return pRes;
}
unsafe extern "C" fn pcachetraceUnpin(
    p: *mut sqlite3_pcache,
    pPg: *mut sqlite3_pcache_page,
    bDiscard: libc::c_int,
) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xUnpin(%p, %p, %d)\n\0" as *const u8 as *const libc::c_char,
            p,
            pPg,
            bDiscard,
        );
    }
    (pcacheBase.xUnpin).expect("non-null function pointer")(p, pPg, bDiscard);
}
unsafe extern "C" fn pcachetraceRekey(
    p: *mut sqlite3_pcache,
    pPg: *mut sqlite3_pcache_page,
    oldKey: libc::c_uint,
    newKey: libc::c_uint,
) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xRekey(%p, %p, %u, %u)\n\0" as *const u8
                as *const libc::c_char,
            p,
            pPg,
            oldKey,
            newKey,
        );
    }
    (pcacheBase.xRekey).expect("non-null function pointer")(p, pPg, oldKey, newKey);
}
unsafe extern "C" fn pcachetraceTruncate(
    p: *mut sqlite3_pcache,
    n: libc::c_uint,
) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xTruncate(%p, %u)\n\0" as *const u8 as *const libc::c_char,
            p,
            n,
        );
    }
    (pcacheBase.xTruncate).expect("non-null function pointer")(p, n);
}
unsafe extern "C" fn pcachetraceDestroy(p: *mut sqlite3_pcache) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xDestroy(%p)\n\0" as *const u8 as *const libc::c_char,
            p,
        );
    }
    (pcacheBase.xDestroy).expect("non-null function pointer")(p);
}
unsafe extern "C" fn pcachetraceShrink(p: *mut sqlite3_pcache) {
    if !pcachetraceOut.is_null() {
        fprintf(
            pcachetraceOut,
            b"PCACHETRACE: xShrink(%p)\n\0" as *const u8 as *const libc::c_char,
            p,
        );
    }
    (pcacheBase.xShrink).expect("non-null function pointer")(p);
}
static mut ersaztPcacheMethods: sqlite3_pcache_methods2 = unsafe {
    {
        let init = sqlite3_pcache_methods2 {
            iVersion: 0 as libc::c_int,
            pArg: 0 as *const libc::c_void as *mut libc::c_void,
            xInit: Some(
                pcachetraceInit as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
            ),
            xShutdown: Some(
                pcachetraceShutdown as unsafe extern "C" fn(*mut libc::c_void) -> (),
            ),
            xCreate: Some(
                pcachetraceCreate
                    as unsafe extern "C" fn(
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                    ) -> *mut sqlite3_pcache,
            ),
            xCachesize: Some(
                pcachetraceCachesize
                    as unsafe extern "C" fn(*mut sqlite3_pcache, libc::c_int) -> (),
            ),
            xPagecount: Some(
                pcachetracePagecount
                    as unsafe extern "C" fn(*mut sqlite3_pcache) -> libc::c_int,
            ),
            xFetch: Some(
                pcachetraceFetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_pcache,
                        libc::c_uint,
                        libc::c_int,
                    ) -> *mut sqlite3_pcache_page,
            ),
            xUnpin: Some(
                pcachetraceUnpin
                    as unsafe extern "C" fn(
                        *mut sqlite3_pcache,
                        *mut sqlite3_pcache_page,
                        libc::c_int,
                    ) -> (),
            ),
            xRekey: Some(
                pcachetraceRekey
                    as unsafe extern "C" fn(
                        *mut sqlite3_pcache,
                        *mut sqlite3_pcache_page,
                        libc::c_uint,
                        libc::c_uint,
                    ) -> (),
            ),
            xTruncate: Some(
                pcachetraceTruncate
                    as unsafe extern "C" fn(*mut sqlite3_pcache, libc::c_uint) -> (),
            ),
            xDestroy: Some(
                pcachetraceDestroy as unsafe extern "C" fn(*mut sqlite3_pcache) -> (),
            ),
            xShrink: Some(
                pcachetraceShrink as unsafe extern "C" fn(*mut sqlite3_pcache) -> (),
            ),
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3PcacheTraceActivate(out: *mut FILE) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (pcacheBase.xFetch).is_none() {
        rc = sqlite3_config(
            19 as libc::c_int,
            &mut pcacheBase as *mut sqlite3_pcache_methods2,
        );
        if rc == 0 as libc::c_int {
            rc = sqlite3_config(
                18 as libc::c_int,
                &mut ersaztPcacheMethods as *mut sqlite3_pcache_methods2,
            );
        }
    }
    pcachetraceOut = out;
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3PcacheTraceDeactivate() -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (pcacheBase.xFetch).is_some() {
        rc = sqlite3_config(
            18 as libc::c_int,
            &mut pcacheBase as *mut sqlite3_pcache_methods2,
        );
        if rc == 0 as libc::c_int {
            memset(
                &mut pcacheBase as *mut sqlite3_pcache_methods2 as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<sqlite3_pcache_methods2>() as libc::c_ulong,
            );
        }
    }
    pcachetraceOut = 0 as *mut FILE;
    return rc;
}
unsafe extern "C" fn KeccakF1600Step(p: *mut SHA3Context) {
    let mut i: libc::c_int = 0;
    let mut b0: u64_0 = 0;
    let mut b1: u64_0 = 0;
    let mut b2: u64_0 = 0;
    let mut b3: u64_0 = 0;
    let mut b4: u64_0 = 0;
    let mut c0: u64_0 = 0;
    let mut c1: u64_0 = 0;
    let mut c2: u64_0 = 0;
    let mut c3: u64_0 = 0;
    let mut c4: u64_0 = 0;
    let mut d0: u64_0 = 0;
    let mut d1: u64_0 = 0;
    let mut d2: u64_0 = 0;
    let mut d3: u64_0 = 0;
    let mut d4: u64_0 = 0;
    static mut RC: [u64_0; 24] = [
        0x1 as libc::c_ulonglong,
        0x8082 as libc::c_ulonglong,
        0x800000000000808a as libc::c_ulonglong,
        0x8000000080008000 as libc::c_ulonglong,
        0x808b as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008009 as libc::c_ulonglong,
        0x8a as libc::c_ulonglong,
        0x88 as libc::c_ulonglong,
        0x80008009 as libc::c_ulonglong,
        0x8000000a as libc::c_ulonglong,
        0x8000808b as libc::c_ulonglong,
        0x800000000000008b as libc::c_ulonglong,
        0x8000000000008089 as libc::c_ulonglong,
        0x8000000000008003 as libc::c_ulonglong,
        0x8000000000008002 as libc::c_ulonglong,
        0x8000000000000080 as libc::c_ulonglong,
        0x800a as libc::c_ulonglong,
        0x800000008000000a as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008080 as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008008 as libc::c_ulonglong,
    ];
    i = 0 as libc::c_int;
    while i < 24 as libc::c_int {
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[5 as libc::c_int as usize]
            ^ (*p).u.s[10 as libc::c_int as usize] ^ (*p).u.s[15 as libc::c_int as usize]
            ^ (*p).u.s[20 as libc::c_int as usize];
        c1 = (*p).u.s[1 as libc::c_int as usize] ^ (*p).u.s[6 as libc::c_int as usize]
            ^ (*p).u.s[11 as libc::c_int as usize] ^ (*p).u.s[16 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[2 as libc::c_int as usize] ^ (*p).u.s[7 as libc::c_int as usize]
            ^ (*p).u.s[12 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[22 as libc::c_int as usize];
        c3 = (*p).u.s[3 as libc::c_int as usize] ^ (*p).u.s[8 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[18 as libc::c_int as usize]
            ^ (*p).u.s[23 as libc::c_int as usize];
        c4 = (*p).u.s[4 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[14 as libc::c_int as usize] ^ (*p).u.s[19 as libc::c_int as usize]
            ^ (*p).u.s[24 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[i as usize];
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[10 as libc::c_int as usize]
            ^ (*p).u.s[20 as libc::c_int as usize] ^ (*p).u.s[5 as libc::c_int as usize]
            ^ (*p).u.s[15 as libc::c_int as usize];
        c1 = (*p).u.s[6 as libc::c_int as usize] ^ (*p).u.s[16 as libc::c_int as usize]
            ^ (*p).u.s[1 as libc::c_int as usize] ^ (*p).u.s[11 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[12 as libc::c_int as usize] ^ (*p).u.s[22 as libc::c_int as usize]
            ^ (*p).u.s[7 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[2 as libc::c_int as usize];
        c3 = (*p).u.s[18 as libc::c_int as usize] ^ (*p).u.s[3 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[23 as libc::c_int as usize]
            ^ (*p).u.s[8 as libc::c_int as usize];
        c4 = (*p).u.s[24 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[19 as libc::c_int as usize] ^ (*p).u.s[4 as libc::c_int as usize]
            ^ (*p).u.s[14 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[(i + 1 as libc::c_int) as usize];
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[20 as libc::c_int as usize]
            ^ (*p).u.s[15 as libc::c_int as usize] ^ (*p).u.s[10 as libc::c_int as usize]
            ^ (*p).u.s[5 as libc::c_int as usize];
        c1 = (*p).u.s[16 as libc::c_int as usize] ^ (*p).u.s[11 as libc::c_int as usize]
            ^ (*p).u.s[6 as libc::c_int as usize] ^ (*p).u.s[1 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[7 as libc::c_int as usize] ^ (*p).u.s[2 as libc::c_int as usize]
            ^ (*p).u.s[22 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[12 as libc::c_int as usize];
        c3 = (*p).u.s[23 as libc::c_int as usize] ^ (*p).u.s[18 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[8 as libc::c_int as usize]
            ^ (*p).u.s[3 as libc::c_int as usize];
        c4 = (*p).u.s[14 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[4 as libc::c_int as usize] ^ (*p).u.s[24 as libc::c_int as usize]
            ^ (*p).u.s[19 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[(i + 2 as libc::c_int) as usize];
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s[0 as libc::c_int as usize] ^ (*p).u.s[15 as libc::c_int as usize]
            ^ (*p).u.s[5 as libc::c_int as usize] ^ (*p).u.s[20 as libc::c_int as usize]
            ^ (*p).u.s[10 as libc::c_int as usize];
        c1 = (*p).u.s[11 as libc::c_int as usize] ^ (*p).u.s[1 as libc::c_int as usize]
            ^ (*p).u.s[16 as libc::c_int as usize] ^ (*p).u.s[6 as libc::c_int as usize]
            ^ (*p).u.s[21 as libc::c_int as usize];
        c2 = (*p).u.s[22 as libc::c_int as usize] ^ (*p).u.s[12 as libc::c_int as usize]
            ^ (*p).u.s[2 as libc::c_int as usize] ^ (*p).u.s[17 as libc::c_int as usize]
            ^ (*p).u.s[7 as libc::c_int as usize];
        c3 = (*p).u.s[8 as libc::c_int as usize] ^ (*p).u.s[23 as libc::c_int as usize]
            ^ (*p).u.s[13 as libc::c_int as usize] ^ (*p).u.s[3 as libc::c_int as usize]
            ^ (*p).u.s[18 as libc::c_int as usize];
        c4 = (*p).u.s[19 as libc::c_int as usize] ^ (*p).u.s[9 as libc::c_int as usize]
            ^ (*p).u.s[24 as libc::c_int as usize] ^ (*p).u.s[14 as libc::c_int as usize]
            ^ (*p).u.s[4 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s[1 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s[1 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s[2 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s[2 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s[3 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s[3 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s[4 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s[4 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[0 as libc::c_int as usize] ^= RC[(i + 3 as libc::c_int) as usize];
        (*p).u.s[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s[5 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s[5 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s[6 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s[6 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s[7 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s[7 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s[8 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s[8 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s[9 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s[10 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s[10 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s[11 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s[11 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s[12 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s[12 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s[13 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s[14 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s[14 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s[15 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s[15 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s[16 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s[16 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s[17 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s[18 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s[18 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s[19 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s[19 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s[20 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s[20 as libc::c_int as usize] ^ d0)
                >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s[21 as libc::c_int as usize] ^ d1)
                >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s[22 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s[22 as libc::c_int as usize] ^ d2)
                >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s[23 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s[23 as libc::c_int as usize] ^ d3)
                >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s[24 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s[24 as libc::c_int as usize] ^ d4)
                >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        i += 4 as libc::c_int;
    }
}
unsafe extern "C" fn SHA3Init(p: *mut SHA3Context, iSize: libc::c_int) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<SHA3Context>() as libc::c_ulong,
    );
    if iSize >= 128 as libc::c_int && iSize <= 512 as libc::c_int {
        (*p)
            .nRate = ((1600 as libc::c_int
            - (iSize + 31 as libc::c_int & !(31 as libc::c_int)) * 2 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint;
    } else {
        (*p)
            .nRate = ((1600 as libc::c_int - 2 as libc::c_int * 256 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint;
    };
}
unsafe extern "C" fn SHA3Update(
    p: *mut SHA3Context,
    aData: *const libc::c_uchar,
    nData: libc::c_uint,
) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if aData.is_null() {
        return;
    }
    if ((*p).nLoaded).wrapping_rem(8 as libc::c_int as libc::c_uint)
        == 0 as libc::c_int as libc::c_uint
        && aData.offset_from(0 as *const libc::c_uchar) as libc::c_long
            & 7 as libc::c_int as libc::c_long == 0 as libc::c_int as libc::c_long
    {
        while i.wrapping_add(7 as libc::c_int as libc::c_uint) < nData {
            (*p)
                .u
                .s[((*p).nLoaded).wrapping_div(8 as libc::c_int as libc::c_uint)
                as usize]
                ^= *(&*aData.offset(i as isize) as *const libc::c_uchar as *mut u64_0);
            (*p).nLoaded = ((*p).nLoaded).wrapping_add(8 as libc::c_int as libc::c_uint);
            if (*p).nLoaded >= (*p).nRate {
                KeccakF1600Step(p);
                (*p).nLoaded = 0 as libc::c_int as libc::c_uint;
            }
            i = i.wrapping_add(8 as libc::c_int as libc::c_uint);
        }
    }
    while i < nData {
        (*p)
            .u
            .x[(*p).nLoaded
            as usize] = ((*p).u.x[(*p).nLoaded as usize] as libc::c_int
            ^ *aData.offset(i as isize) as libc::c_int) as libc::c_uchar;
        (*p).nLoaded = ((*p).nLoaded).wrapping_add(1);
        (*p).nLoaded;
        if (*p).nLoaded == (*p).nRate {
            KeccakF1600Step(p);
            (*p).nLoaded = 0 as libc::c_int as libc::c_uint;
        }
        i = i.wrapping_add(1);
        i;
    }
}
unsafe extern "C" fn SHA3Final(p: *mut SHA3Context) -> *mut libc::c_uchar {
    let mut i: libc::c_uint = 0;
    if (*p).nLoaded == ((*p).nRate).wrapping_sub(1 as libc::c_int as libc::c_uint) {
        let c1: libc::c_uchar = 0x86 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c1, 1 as libc::c_int as libc::c_uint);
    } else {
        let c2: libc::c_uchar = 0x6 as libc::c_int as libc::c_uchar;
        let c3: libc::c_uchar = 0x80 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c2, 1 as libc::c_int as libc::c_uint);
        (*p).nLoaded = ((*p).nRate).wrapping_sub(1 as libc::c_int as libc::c_uint);
        SHA3Update(p, &c3, 1 as libc::c_int as libc::c_uint);
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*p).nRate {
        (*p)
            .u
            .x[i.wrapping_add((*p).nRate)
            as usize] = (*p).u.x[(i ^ (*p).ixMask) as usize];
        i = i.wrapping_add(1);
        i;
    }
    return &mut *((*p).u.x).as_mut_ptr().offset((*p).nRate as isize)
        as *mut libc::c_uchar;
}
unsafe extern "C" fn sha3Func(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: [0; 25] },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let eType: libc::c_int = sqlite3_value_type(
        *argv.offset(0 as libc::c_int as isize),
    );
    let nByte: libc::c_int = sqlite3_value_bytes(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int;
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if eType == 5 as libc::c_int {
        return;
    }
    SHA3Init(&mut cx, iSize);
    if eType == 4 as libc::c_int {
        SHA3Update(
            &mut cx,
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
                as *const libc::c_uchar,
            nByte as libc::c_uint,
        );
    } else {
        SHA3Update(
            &mut cx,
            sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)),
            nByte as libc::c_uint,
        );
    }
    sqlite3_result_blob(
        context,
        SHA3Final(&mut cx) as *const libc::c_void,
        iSize / 8 as libc::c_int,
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn sha3_step_vformat(
    p: *mut SHA3Context,
    zFormat: *const libc::c_char,
    args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    let mut n: libc::c_int = 0;
    let mut zBuf: [libc::c_char; 50] = [0; 50];
    ap = args.clone();
    sqlite3_vsnprintf(
        ::core::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong as libc::c_int,
        zBuf.as_mut_ptr(),
        zFormat,
        ap.as_va_list(),
    );
    n = strlen(zBuf.as_mut_ptr()) as libc::c_int;
    SHA3Update(p, zBuf.as_mut_ptr() as *mut libc::c_uchar, n as libc::c_uint);
}
unsafe extern "C" fn sha3QueryFunc(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let db: *mut sqlite3 = sqlite3_context_db_handle(context);
    let mut zSql: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: [0; 25] },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int;
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if zSql.is_null() {
        return;
    }
    SHA3Init(&mut cx, iSize);
    while *zSql.offset(0 as libc::c_int as isize) != 0 {
        rc = sqlite3_prepare_v2(db, zSql, -(1 as libc::c_int), &mut pStmt, &mut zSql);
        if rc != 0 {
            let zMsg: *mut libc::c_char = sqlite3_mprintf(
                b"error SQL statement [%s]: %s\0" as *const u8 as *const libc::c_char,
                zSql,
                sqlite3_errmsg(db),
            );
            sqlite3_finalize(pStmt);
            sqlite3_result_error(context, zMsg, -(1 as libc::c_int));
            sqlite3_free(zMsg as *mut libc::c_void);
            return;
        }
        if sqlite3_stmt_readonly(pStmt) == 0 {
            let zMsg_0: *mut libc::c_char = sqlite3_mprintf(
                b"non-query: [%s]\0" as *const u8 as *const libc::c_char,
                sqlite3_sql(pStmt),
            );
            sqlite3_finalize(pStmt);
            sqlite3_result_error(context, zMsg_0, -(1 as libc::c_int));
            sqlite3_free(zMsg_0 as *mut libc::c_void);
            return;
        }
        nCol = sqlite3_column_count(pStmt);
        z = sqlite3_sql(pStmt);
        if !z.is_null() {
            n = strlen(z) as libc::c_int;
            sha3_step_vformat(
                &mut cx as *mut SHA3Context,
                b"S%d:\0" as *const u8 as *const libc::c_char,
                n,
            );
            SHA3Update(&mut cx, z as *mut libc::c_uchar, n as libc::c_uint);
        }
        while 100 as libc::c_int == sqlite3_step(pStmt) {
            SHA3Update(
                &mut cx,
                b"R\0" as *const u8 as *const libc::c_char as *const libc::c_uchar,
                1 as libc::c_int as libc::c_uint,
            );
            i = 0 as libc::c_int;
            while i < nCol {
                match sqlite3_column_type(pStmt, i) {
                    5 => {
                        SHA3Update(
                            &mut cx,
                            b"N\0" as *const u8 as *const libc::c_char
                                as *const libc::c_uchar,
                            1 as libc::c_int as libc::c_uint,
                        );
                    }
                    1 => {
                        let mut u: sqlite3_uint64 = 0;
                        let mut j: libc::c_int = 0;
                        let mut x: [libc::c_uchar; 9] = [0; 9];
                        let mut v: sqlite3_int64 = sqlite3_column_int64(pStmt, i);
                        memcpy(
                            &mut u as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut v as *mut sqlite3_int64 as *const libc::c_void,
                            8 as libc::c_int as libc::c_ulong,
                        );
                        j = 8 as libc::c_int;
                        while j >= 1 as libc::c_int {
                            x[j
                                as usize] = (u & 0xff as libc::c_int as libc::c_ulonglong)
                                as libc::c_uchar;
                            u >>= 8 as libc::c_int;
                            j -= 1;
                            j;
                        }
                        x[0 as libc::c_int as usize] = 'I' as i32 as libc::c_uchar;
                        SHA3Update(
                            &mut cx,
                            x.as_mut_ptr(),
                            9 as libc::c_int as libc::c_uint,
                        );
                    }
                    2 => {
                        let mut u_0: sqlite3_uint64 = 0;
                        let mut j_0: libc::c_int = 0;
                        let mut x_0: [libc::c_uchar; 9] = [0; 9];
                        let mut r: libc::c_double = sqlite3_column_double(pStmt, i);
                        memcpy(
                            &mut u_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r as *mut libc::c_double as *const libc::c_void,
                            8 as libc::c_int as libc::c_ulong,
                        );
                        j_0 = 8 as libc::c_int;
                        while j_0 >= 1 as libc::c_int {
                            x_0[j_0
                                as usize] = (u_0 & 0xff as libc::c_int as libc::c_ulonglong)
                                as libc::c_uchar;
                            u_0 >>= 8 as libc::c_int;
                            j_0 -= 1;
                            j_0;
                        }
                        x_0[0 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
                        SHA3Update(
                            &mut cx,
                            x_0.as_mut_ptr(),
                            9 as libc::c_int as libc::c_uint,
                        );
                    }
                    3 => {
                        let n2: libc::c_int = sqlite3_column_bytes(pStmt, i);
                        let z2: *const libc::c_uchar = sqlite3_column_text(pStmt, i);
                        sha3_step_vformat(
                            &mut cx as *mut SHA3Context,
                            b"T%d:\0" as *const u8 as *const libc::c_char,
                            n2,
                        );
                        SHA3Update(&mut cx, z2, n2 as libc::c_uint);
                    }
                    4 => {
                        let n2_0: libc::c_int = sqlite3_column_bytes(pStmt, i);
                        let z2_0: *const libc::c_uchar = sqlite3_column_blob(
                            pStmt,
                            i,
                        ) as *const libc::c_uchar;
                        sha3_step_vformat(
                            &mut cx as *mut SHA3Context,
                            b"B%d:\0" as *const u8 as *const libc::c_char,
                            n2_0,
                        );
                        SHA3Update(&mut cx, z2_0, n2_0 as libc::c_uint);
                    }
                    _ => {}
                }
                i += 1;
                i;
            }
        }
        sqlite3_finalize(pStmt);
    }
    sqlite3_result_blob(
        context,
        SHA3Final(&mut cx) as *const libc::c_void,
        iSize / 8 as libc::c_int,
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_shathree_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sha3\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sha3Func
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3Func
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn uintCollFunc(
    _notUsed: *mut libc::c_void,
    nKey1: libc::c_int,
    pKey1: *const libc::c_void,
    nKey2: libc::c_int,
    pKey2: *const libc::c_void,
) -> libc::c_int {
    let zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut x: libc::c_int = 0;
    while i < nKey1 && j < nKey2 {
        x = *zA.offset(i as isize) as libc::c_int
            - *zB.offset(j as isize) as libc::c_int;
        if *(*__ctype_b_loc()).offset(*zA.offset(i as isize) as libc::c_int as isize)
            as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            let mut k: libc::c_int = 0;
            if *(*__ctype_b_loc()).offset(*zB.offset(j as isize) as libc::c_int as isize)
                as libc::c_int & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return x;
            }
            while i < nKey1 && *zA.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1;
                i;
            }
            while j < nKey2 && *zB.offset(j as isize) as libc::c_int == '0' as i32 {
                j += 1;
                j;
            }
            k = 0 as libc::c_int;
            while i + k < nKey1
                && *(*__ctype_b_loc())
                    .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
                && j + k < nKey2
                && *(*__ctype_b_loc())
                    .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                k += 1;
                k;
            }
            if i + k < nKey1
                && *(*__ctype_b_loc())
                    .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                return 1 as libc::c_int
            } else if j + k < nKey2
                && *(*__ctype_b_loc())
                    .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                return -(1 as libc::c_int)
            } else {
                x = memcmp(
                    zA.offset(i as isize) as *const libc::c_void,
                    zB.offset(j as isize) as *const libc::c_void,
                    k as libc::c_ulong,
                );
                if x != 0 {
                    return x;
                }
                i += k;
                j += k;
            }
        } else if x != 0 {
            return x
        } else {
            i += 1;
            i;
            j += 1;
            j;
        }
    }
    return nKey1 - i - (nKey2 - j);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_uint_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3_create_collation(
        db,
        b"uint\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            uintCollFunc
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *const libc::c_void,
                    libc::c_int,
                    *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
}
unsafe extern "C" fn decimal_clear(p: *mut Decimal) {
    sqlite3_free((*p).a as *mut libc::c_void);
}
unsafe extern "C" fn decimal_free(p: *mut Decimal) {
    if !p.is_null() {
        decimal_clear(p);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn decimalNewFromText(
    zIn: *const libc::c_char,
    n: libc::c_int,
) -> *mut Decimal {
    let current_block: u64;
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut i: libc::c_int = 0;
    let mut iExp: libc::c_int = 0 as libc::c_int;
    p = sqlite3_malloc(::core::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int)
        as *mut Decimal;
    if !p.is_null() {
        (*p).sign = 0 as libc::c_int as libc::c_char;
        (*p).oom = 0 as libc::c_int as libc::c_char;
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        (*p).isNull = 0 as libc::c_int as libc::c_char;
        (*p).nDigit = 0 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
        (*p)
            .a = sqlite3_malloc64((n + 1 as libc::c_int) as sqlite3_uint64)
            as *mut libc::c_schar;
        if !((*p).a).is_null() {
            i = 0 as libc::c_int;
            while *(*__ctype_b_loc())
                .offset(*zIn.offset(i as isize) as libc::c_int as isize) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                i += 1;
                i;
            }
            if *zIn.offset(i as isize) as libc::c_int == '-' as i32 {
                (*p).sign = 1 as libc::c_int as libc::c_char;
                i += 1;
                i;
            } else if *zIn.offset(i as isize) as libc::c_int == '+' as i32 {
                i += 1;
                i;
            }
            while i < n && *zIn.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1;
                i;
            }
            while i < n {
                let c: libc::c_char = *zIn.offset(i as isize);
                if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
                    let fresh6 = (*p).nDigit;
                    (*p).nDigit = (*p).nDigit + 1;
                    *((*p).a)
                        .offset(
                            fresh6 as isize,
                        ) = (c as libc::c_int - '0' as i32) as libc::c_schar;
                } else if c as libc::c_int == '.' as i32 {
                    (*p).nFrac = (*p).nDigit + 1 as libc::c_int;
                } else if c as libc::c_int == 'e' as i32
                    || c as libc::c_int == 'E' as i32
                {
                    let mut j: libc::c_int = i + 1 as libc::c_int;
                    let mut neg: libc::c_int = 0 as libc::c_int;
                    if j >= n {
                        break;
                    }
                    if *zIn.offset(j as isize) as libc::c_int == '-' as i32 {
                        neg = 1 as libc::c_int;
                        j += 1;
                        j;
                    } else if *zIn.offset(j as isize) as libc::c_int == '+' as i32 {
                        j += 1;
                        j;
                    }
                    while j < n && iExp < 1000000 as libc::c_int {
                        if *zIn.offset(j as isize) as libc::c_int >= '0' as i32
                            && *zIn.offset(j as isize) as libc::c_int <= '9' as i32
                        {
                            iExp = iExp * 10 as libc::c_int
                                + *zIn.offset(j as isize) as libc::c_int - '0' as i32;
                        }
                        j += 1;
                        j;
                    }
                    if neg != 0 {
                        iExp = -iExp;
                    }
                    break;
                }
                i += 1;
                i;
            }
            if (*p).nFrac != 0 {
                (*p).nFrac = (*p).nDigit - ((*p).nFrac - 1 as libc::c_int);
            }
            if iExp > 0 as libc::c_int {
                if (*p).nFrac > 0 as libc::c_int {
                    if iExp <= (*p).nFrac {
                        (*p).nFrac -= iExp;
                        iExp = 0 as libc::c_int;
                    } else {
                        iExp -= (*p).nFrac;
                        (*p).nFrac = 0 as libc::c_int;
                    }
                }
                if iExp > 0 as libc::c_int {
                    (*p)
                        .a = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if ((*p).a).is_null() {
                        current_block = 18106337517343732196;
                    } else {
                        memset(
                            ((*p).a).offset((*p).nDigit as isize) as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        current_block = 7419121793134201633;
                    }
                } else {
                    current_block = 7419121793134201633;
                }
            } else if iExp < 0 as libc::c_int {
                let mut nExtra: libc::c_int = 0;
                iExp = -iExp;
                nExtra = (*p).nDigit - (*p).nFrac - 1 as libc::c_int;
                if nExtra != 0 {
                    if nExtra >= iExp {
                        (*p).nFrac += iExp;
                        iExp = 0 as libc::c_int;
                    } else {
                        iExp -= nExtra;
                        (*p).nFrac = (*p).nDigit - 1 as libc::c_int;
                    }
                }
                if iExp > 0 as libc::c_int {
                    (*p)
                        .a = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if ((*p).a).is_null() {
                        current_block = 18106337517343732196;
                    } else {
                        memmove(
                            ((*p).a).offset(iExp as isize) as *mut libc::c_void,
                            (*p).a as *const libc::c_void,
                            (*p).nDigit as libc::c_ulong,
                        );
                        memset(
                            (*p).a as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        (*p).nFrac += iExp;
                        current_block = 7419121793134201633;
                    }
                } else {
                    current_block = 7419121793134201633;
                }
            } else {
                current_block = 7419121793134201633;
            }
            match current_block {
                18106337517343732196 => {}
                _ => return p,
            }
        }
    }
    if !p.is_null() {
        if !((*p).a).is_null() {
            sqlite3_free((*p).a as *mut libc::c_void);
        }
        sqlite3_free(p as *mut libc::c_void);
    }
    return 0 as *mut Decimal;
}
unsafe extern "C" fn decimal_new(
    pCtx: *mut sqlite3_context,
    pIn: *mut sqlite3_value,
    bTextOnly: libc::c_int,
) -> *mut Decimal {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut eType: libc::c_int = sqlite3_value_type(pIn);
    if bTextOnly != 0 && (eType == 2 as libc::c_int || eType == 4 as libc::c_int) {
        eType = 3 as libc::c_int;
    }
    match eType {
        3 | 1 => {
            let zIn: *const libc::c_char = sqlite3_value_text(pIn)
                as *const libc::c_char;
            let n: libc::c_int = sqlite3_value_bytes(pIn);
            p = decimalNewFromText(zIn, n);
            if p.is_null() {
                if !pCtx.is_null() {
                    sqlite3_result_error_nomem(pCtx);
                }
                sqlite3_free(p as *mut libc::c_void);
                return 0 as *mut Decimal;
            }
        }
        2 => {
            p = decimalFromDouble(sqlite3_value_double(pIn));
        }
        4 => {
            let mut x: *const libc::c_uchar = 0 as *const libc::c_uchar;
            let mut i: libc::c_uint = 0;
            let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
            let mut r: libc::c_double = 0.;
            if !(sqlite3_value_bytes(pIn) as libc::c_ulong
                != ::core::mem::size_of::<libc::c_double>() as libc::c_ulong)
            {
                x = sqlite3_value_blob(pIn) as *const libc::c_uchar;
                i = 0 as libc::c_int as libc::c_uint;
                while (i as libc::c_ulong)
                    < ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
                {
                    v = v << 8 as libc::c_int
                        | *x.offset(i as isize) as libc::c_ulonglong;
                    i = i.wrapping_add(1);
                    i;
                }
                memcpy(
                    &mut r as *mut libc::c_double as *mut libc::c_void,
                    &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                    ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
                );
                p = decimalFromDouble(r);
            }
        }
        5 | _ => {}
    }
    return p;
}
unsafe extern "C" fn decimal_result(
    pCtx: *mut sqlite3_context,
    p: *mut Decimal,
) {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if p.is_null() || (*p).oom as libc::c_int != 0 {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    if (*p).isNull != 0 {
        sqlite3_result_null(pCtx);
        return;
    }
    z = sqlite3_malloc((*p).nDigit + 4 as libc::c_int) as *mut libc::c_char;
    if z.is_null() {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    i = 0 as libc::c_int;
    if (*p).nDigit == 0 as libc::c_int
        || (*p).nDigit == 1 as libc::c_int
            && *((*p).a).offset(0 as libc::c_int as isize) as libc::c_int
                == 0 as libc::c_int
    {
        (*p).sign = 0 as libc::c_int as libc::c_char;
    }
    if (*p).sign != 0 {
        *z.offset(0 as libc::c_int as isize) = '-' as i32 as libc::c_char;
        i = 1 as libc::c_int;
    }
    n = (*p).nDigit - (*p).nFrac;
    if n <= 0 as libc::c_int {
        let fresh7 = i;
        i = i + 1;
        *z.offset(fresh7 as isize) = '0' as i32 as libc::c_char;
    }
    j = 0 as libc::c_int;
    while n > 1 as libc::c_int
        && *((*p).a).offset(j as isize) as libc::c_int == 0 as libc::c_int
    {
        j += 1;
        j;
        n -= 1;
        n;
    }
    while n > 0 as libc::c_int {
        let fresh8 = i;
        i = i + 1;
        *z
            .offset(
                fresh8 as isize,
            ) = (*((*p).a).offset(j as isize) as libc::c_int + '0' as i32)
            as libc::c_char;
        j += 1;
        j;
        n -= 1;
        n;
    }
    if (*p).nFrac != 0 {
        let fresh9 = i;
        i = i + 1;
        *z.offset(fresh9 as isize) = '.' as i32 as libc::c_char;
        loop {
            let fresh10 = i;
            i = i + 1;
            *z
                .offset(
                    fresh10 as isize,
                ) = (*((*p).a).offset(j as isize) as libc::c_int + '0' as i32)
                as libc::c_char;
            j += 1;
            j;
            if !(j < (*p).nDigit) {
                break;
            }
        }
    }
    *z.offset(i as isize) = 0 as libc::c_int as libc::c_char;
    sqlite3_result_text(
        pCtx,
        z,
        i,
        Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
    );
}
unsafe extern "C" fn decimal_result_sci(
    pCtx: *mut sqlite3_context,
    p: *mut Decimal,
) {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut nZero: libc::c_int = 0;
    let mut nDigit: libc::c_int = 0;
    let mut nFrac: libc::c_int = 0;
    let mut exp: libc::c_int = 0;
    let mut zero: libc::c_schar = 0;
    let mut a: *mut libc::c_schar = 0 as *mut libc::c_schar;
    if p.is_null() || (*p).oom as libc::c_int != 0 {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    if (*p).isNull != 0 {
        sqlite3_result_null(pCtx);
        return;
    }
    nDigit = (*p).nDigit;
    while nDigit > 0 as libc::c_int
        && *((*p).a).offset((nDigit - 1 as libc::c_int) as isize) as libc::c_int
            == 0 as libc::c_int
    {
        nDigit -= 1;
        nDigit;
    }
    nZero = 0 as libc::c_int;
    while nZero < nDigit
        && *((*p).a).offset(nZero as isize) as libc::c_int == 0 as libc::c_int
    {
        nZero += 1;
        nZero;
    }
    nFrac = (*p).nFrac + (nDigit - (*p).nDigit);
    nDigit -= nZero;
    z = sqlite3_malloc(nDigit + 20 as libc::c_int) as *mut libc::c_char;
    if z.is_null() {
        sqlite3_result_error_nomem(pCtx);
        return;
    }
    if nDigit == 0 as libc::c_int {
        zero = 0 as libc::c_int as libc::c_schar;
        a = &mut zero;
        nDigit = 1 as libc::c_int;
        nFrac = 0 as libc::c_int;
    } else {
        a = &mut *((*p).a).offset(nZero as isize) as *mut libc::c_schar;
    }
    if (*p).sign as libc::c_int != 0 && nDigit > 0 as libc::c_int {
        *z.offset(0 as libc::c_int as isize) = '-' as i32 as libc::c_char;
    } else {
        *z.offset(0 as libc::c_int as isize) = '+' as i32 as libc::c_char;
    }
    *z
        .offset(
            1 as libc::c_int as isize,
        ) = (*a.offset(0 as libc::c_int as isize) as libc::c_int + '0' as i32)
        as libc::c_char;
    *z.offset(2 as libc::c_int as isize) = '.' as i32 as libc::c_char;
    if nDigit == 1 as libc::c_int {
        *z.offset(3 as libc::c_int as isize) = '0' as i32 as libc::c_char;
        i = 4 as libc::c_int;
    } else {
        i = 1 as libc::c_int;
        while i < nDigit {
            *z
                .offset(
                    (2 as libc::c_int + i) as isize,
                ) = (*a.offset(i as isize) as libc::c_int + '0' as i32) as libc::c_char;
            i += 1;
            i;
        }
        i = nDigit + 2 as libc::c_int;
    }
    exp = nDigit - nFrac - 1 as libc::c_int;
    sqlite3_snprintf(
        nDigit + 20 as libc::c_int - i,
        &mut *z.offset(i as isize) as *mut libc::c_char,
        b"e%+03d\0" as *const u8 as *const libc::c_char,
        exp,
    );
    sqlite3_result_text(
        pCtx,
        z,
        -(1 as libc::c_int),
        Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
    );
}
unsafe extern "C" fn decimal_cmp(
    mut pA: *const Decimal,
    mut pB: *const Decimal,
) -> libc::c_int {
    let mut nASig: libc::c_int = 0;
    let mut nBSig: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if (*pA).sign as libc::c_int != (*pB).sign as libc::c_int {
        return if (*pA).sign as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    }
    if (*pA).sign != 0 {
        let pTemp: *const Decimal = pA;
        pA = pB;
        pB = pTemp;
    }
    nASig = (*pA).nDigit - (*pA).nFrac;
    nBSig = (*pB).nDigit - (*pB).nFrac;
    if nASig != nBSig {
        return nASig - nBSig;
    }
    n = (*pA).nDigit;
    if n > (*pB).nDigit {
        n = (*pB).nDigit;
    }
    rc = memcmp(
        (*pA).a as *const libc::c_void,
        (*pB).a as *const libc::c_void,
        n as libc::c_ulong,
    );
    if rc == 0 as libc::c_int {
        rc = (*pA).nDigit - (*pB).nDigit;
    }
    return rc;
}
unsafe extern "C" fn decimalCmpFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = 0 as *mut Decimal;
    let mut pB: *mut Decimal = 0 as *mut Decimal;
    let mut rc: libc::c_int = 0;
    pA = decimal_new(context, *argv.offset(0 as libc::c_int as isize), 1 as libc::c_int);
    if !(pA.is_null() || (*pA).isNull as libc::c_int != 0) {
        pB = decimal_new(
            context,
            *argv.offset(1 as libc::c_int as isize),
            1 as libc::c_int,
        );
        if !(pB.is_null() || (*pB).isNull as libc::c_int != 0) {
            rc = decimal_cmp(pA, pB);
            if rc < 0 as libc::c_int {
                rc = -(1 as libc::c_int);
            } else if rc > 0 as libc::c_int {
                rc = 1 as libc::c_int;
            }
            sqlite3_result_int(context, rc);
        }
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimal_expand(
    p: *mut Decimal,
    nDigit: libc::c_int,
    nFrac: libc::c_int,
) {
    let mut nAddSig: libc::c_int = 0;
    let mut nAddFrac: libc::c_int = 0;
    if p.is_null() {
        return;
    }
    nAddFrac = nFrac - (*p).nFrac;
    nAddSig = nDigit - (*p).nDigit - nAddFrac;
    if nAddFrac == 0 as libc::c_int && nAddSig == 0 as libc::c_int {
        return;
    }
    (*p)
        .a = sqlite3_realloc64(
        (*p).a as *mut libc::c_void,
        (nDigit + 1 as libc::c_int) as sqlite3_uint64,
    ) as *mut libc::c_schar;
    if ((*p).a).is_null() {
        (*p).oom = 1 as libc::c_int as libc::c_char;
        return;
    }
    if nAddSig != 0 {
        memmove(
            ((*p).a).offset(nAddSig as isize) as *mut libc::c_void,
            (*p).a as *const libc::c_void,
            (*p).nDigit as libc::c_ulong,
        );
        memset((*p).a as *mut libc::c_void, 0 as libc::c_int, nAddSig as libc::c_ulong);
        (*p).nDigit += nAddSig;
    }
    if nAddFrac != 0 {
        memset(
            ((*p).a).offset((*p).nDigit as isize) as *mut libc::c_void,
            0 as libc::c_int,
            nAddFrac as libc::c_ulong,
        );
        (*p).nDigit += nAddFrac;
        (*p).nFrac += nAddFrac;
    }
}
unsafe extern "C" fn decimal_add(pA: *mut Decimal, pB: *mut Decimal) {
    let mut nSig: libc::c_int = 0;
    let mut nFrac: libc::c_int = 0;
    let mut nDigit: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    if pA.is_null() {
        return;
    }
    if (*pA).oom as libc::c_int != 0 || pB.is_null() || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
        return;
    }
    if (*pA).isNull as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0 {
        (*pA).isNull = 1 as libc::c_int as libc::c_char;
        return;
    }
    nSig = (*pA).nDigit - (*pA).nFrac;
    if nSig != 0
        && *((*pA).a).offset(0 as libc::c_int as isize) as libc::c_int
            == 0 as libc::c_int
    {
        nSig -= 1;
        nSig;
    }
    if nSig < (*pB).nDigit - (*pB).nFrac {
        nSig = (*pB).nDigit - (*pB).nFrac;
    }
    nFrac = (*pA).nFrac;
    if nFrac < (*pB).nFrac {
        nFrac = (*pB).nFrac;
    }
    nDigit = nSig + nFrac + 1 as libc::c_int;
    decimal_expand(pA, nDigit, nFrac);
    decimal_expand(pB, nDigit, nFrac);
    if (*pA).oom as libc::c_int != 0 || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
    } else if (*pA).sign as libc::c_int == (*pB).sign as libc::c_int {
        let mut carry: libc::c_int = 0 as libc::c_int;
        i = nDigit - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let x: libc::c_int = *((*pA).a).offset(i as isize) as libc::c_int
                + *((*pB).a).offset(i as isize) as libc::c_int + carry;
            if x >= 10 as libc::c_int {
                carry = 1 as libc::c_int;
                *((*pA).a).offset(i as isize) = (x - 10 as libc::c_int) as libc::c_schar;
            } else {
                carry = 0 as libc::c_int;
                *((*pA).a).offset(i as isize) = x as libc::c_schar;
            }
            i -= 1;
            i;
        }
    } else {
        let mut aA: *mut libc::c_schar = 0 as *mut libc::c_schar;
        let mut aB: *mut libc::c_schar = 0 as *mut libc::c_schar;
        let mut borrow: libc::c_int = 0 as libc::c_int;
        rc = memcmp(
            (*pA).a as *const libc::c_void,
            (*pB).a as *const libc::c_void,
            nDigit as libc::c_ulong,
        );
        if rc < 0 as libc::c_int {
            aA = (*pB).a;
            aB = (*pA).a;
            (*pA).sign = ((*pA).sign == 0) as libc::c_int as libc::c_char;
        } else {
            aA = (*pA).a;
            aB = (*pB).a;
        }
        i = nDigit - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let x_0: libc::c_int = *aA.offset(i as isize) as libc::c_int
                - *aB.offset(i as isize) as libc::c_int - borrow;
            if x_0 < 0 as libc::c_int {
                *((*pA).a)
                    .offset(i as isize) = (x_0 + 10 as libc::c_int) as libc::c_schar;
                borrow = 1 as libc::c_int;
            } else {
                *((*pA).a).offset(i as isize) = x_0 as libc::c_schar;
                borrow = 0 as libc::c_int;
            }
            i -= 1;
            i;
        }
    };
}
unsafe extern "C" fn decimalMul(pA: *mut Decimal, pB: *mut Decimal) {
    let mut acc: *mut libc::c_schar = 0 as *mut libc::c_schar;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut minFrac: libc::c_int = 0;
    if !(pA.is_null() || (*pA).oom as libc::c_int != 0
        || (*pA).isNull as libc::c_int != 0 || pB.is_null()
        || (*pB).oom as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0)
    {
        acc = sqlite3_malloc64(
            ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_schar;
        if acc.is_null() {
            (*pA).oom = 1 as libc::c_int as libc::c_char;
        } else {
            memset(
                acc as *mut libc::c_void,
                0 as libc::c_int,
                ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as libc::c_ulong,
            );
            minFrac = (*pA).nFrac;
            if (*pB).nFrac < minFrac {
                minFrac = (*pB).nFrac;
            }
            i = (*pA).nDigit - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let f: libc::c_schar = *((*pA).a).offset(i as isize);
                let mut carry: libc::c_int = 0 as libc::c_int;
                let mut x: libc::c_int = 0;
                j = (*pB).nDigit - 1 as libc::c_int;
                k = i + j + 3 as libc::c_int;
                while j >= 0 as libc::c_int {
                    x = *acc.offset(k as isize) as libc::c_int
                        + f as libc::c_int * *((*pB).a).offset(j as isize) as libc::c_int
                        + carry;
                    *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                    carry = x / 10 as libc::c_int;
                    j -= 1;
                    j;
                    k -= 1;
                    k;
                }
                x = *acc.offset(k as isize) as libc::c_int + carry;
                *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                let ref mut fresh11 = *acc.offset((k - 1 as libc::c_int) as isize);
                *fresh11 = (*fresh11 as libc::c_int + x / 10 as libc::c_int)
                    as libc::c_schar;
                i -= 1;
                i;
            }
            sqlite3_free((*pA).a as *mut libc::c_void);
            (*pA).a = acc;
            acc = 0 as *mut libc::c_schar;
            (*pA).nDigit += (*pB).nDigit + 2 as libc::c_int;
            (*pA).nFrac += (*pB).nFrac;
            (*pA)
                .sign = ((*pA).sign as libc::c_int ^ (*pB).sign as libc::c_int)
                as libc::c_char;
            while (*pA).nFrac > minFrac
                && *((*pA).a).offset(((*pA).nDigit - 1 as libc::c_int) as isize)
                    as libc::c_int == 0 as libc::c_int
            {
                (*pA).nFrac -= 1;
                (*pA).nFrac;
                (*pA).nDigit -= 1;
                (*pA).nDigit;
            }
        }
    }
    sqlite3_free(acc as *mut libc::c_void);
}
unsafe extern "C" fn decimalPow2(mut N: libc::c_int) -> *mut Decimal {
    let current_block: u64;
    let mut pA: *mut Decimal = 0 as *mut Decimal;
    let mut pX: *mut Decimal = 0 as *mut Decimal;
    if !(N < -(20000 as libc::c_int) || N > 20000 as libc::c_int) {
        pA = decimalNewFromText(
            b"1.0\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
        );
        if !(pA.is_null() || (*pA).oom as libc::c_int != 0) {
            if N == 0 as libc::c_int {
                return pA;
            }
            if N > 0 as libc::c_int {
                pX = decimalNewFromText(
                    b"2.0\0" as *const u8 as *const libc::c_char,
                    3 as libc::c_int,
                );
            } else {
                N = -N;
                pX = decimalNewFromText(
                    b"0.5\0" as *const u8 as *const libc::c_char,
                    3 as libc::c_int,
                );
            }
            if !(pX.is_null() || (*pX).oom as libc::c_int != 0) {
                loop {
                    if N & 1 as libc::c_int != 0 {
                        decimalMul(pA, pX);
                        if (*pA).oom != 0 {
                            current_block = 9670842661277613550;
                            break;
                        }
                    }
                    N >>= 1 as libc::c_int;
                    if N == 0 as libc::c_int {
                        current_block = 15976848397966268834;
                        break;
                    }
                    decimalMul(pX, pX);
                }
                match current_block {
                    9670842661277613550 => {}
                    _ => {
                        decimal_free(pX);
                        return pA;
                    }
                }
            }
        }
    }
    decimal_free(pA);
    decimal_free(pX);
    return 0 as *mut Decimal;
}
unsafe extern "C" fn decimalFromDouble(mut r: libc::c_double) -> *mut Decimal {
    let mut m: sqlite3_int64 = 0;
    let mut a: sqlite3_int64 = 0;
    let mut e: libc::c_int = 0;
    let mut isNeg: libc::c_int = 0;
    let mut pA: *mut Decimal = 0 as *mut Decimal;
    let mut pX: *mut Decimal = 0 as *mut Decimal;
    let mut zNum: [libc::c_char; 100] = [0; 100];
    if r < 0.0f64 {
        isNeg = 1 as libc::c_int;
        r = -r;
    } else {
        isNeg = 0 as libc::c_int;
    }
    memcpy(
        &mut a as *mut sqlite3_int64 as *mut libc::c_void,
        &mut r as *mut libc::c_double as *const libc::c_void,
        ::core::mem::size_of::<sqlite3_int64>() as libc::c_ulong,
    );
    if a == 0 as libc::c_int as libc::c_longlong {
        e = 0 as libc::c_int;
        m = 0 as libc::c_int as sqlite3_int64;
    } else {
        e = (a >> 52 as libc::c_int) as libc::c_int;
        m = a
            & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong;
        if e == 0 as libc::c_int {
            m <<= 1 as libc::c_int;
        } else {
            m |= (1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int;
        }
        while e < 1075 as libc::c_int && m > 0 as libc::c_int as libc::c_longlong
            && m & 1 as libc::c_int as libc::c_longlong
                == 0 as libc::c_int as libc::c_longlong
        {
            m >>= 1 as libc::c_int;
            e += 1;
            e;
        }
        if isNeg != 0 {
            m = -m;
        }
        e = e - 1075 as libc::c_int;
        if e > 971 as libc::c_int {
            return 0 as *mut Decimal;
        }
    }
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
        zNum.as_mut_ptr(),
        b"%lld\0" as *const u8 as *const libc::c_char,
        m,
    );
    pA = decimalNewFromText(zNum.as_mut_ptr(), strlen(zNum.as_mut_ptr()) as libc::c_int);
    pX = decimalPow2(e);
    decimalMul(pA, pX);
    decimal_free(pX);
    return pA;
}
unsafe extern "C" fn decimalFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let p: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
    );
    if !p.is_null() {
        if !(sqlite3_user_data(context)).is_null() {
            decimal_result_sci(context, p);
        } else {
            decimal_result(context, p);
        }
        decimal_free(p);
    }
}
unsafe extern "C" fn decimalCollFunc(
    _notUsed: *mut libc::c_void,
    nKey1: libc::c_int,
    pKey1: *const libc::c_void,
    nKey2: libc::c_int,
    pKey2: *const libc::c_void,
) -> libc::c_int {
    let zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let pA: *mut Decimal = decimalNewFromText(zA as *const libc::c_char, nKey1);
    let pB: *mut Decimal = decimalNewFromText(zB as *const libc::c_char, nKey2);
    let mut rc: libc::c_int = 0;
    if pA.is_null() || pB.is_null() {
        rc = 0 as libc::c_int;
    } else {
        rc = decimal_cmp(pA, pB);
    }
    decimal_free(pA);
    decimal_free(pB);
    return rc;
}
unsafe extern "C" fn decimalAddFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        1 as libc::c_int,
    );
    let pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        1 as libc::c_int,
    );
    decimal_add(pA, pB);
    decimal_result(context, pA);
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSubFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        1 as libc::c_int,
    );
    let pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        1 as libc::c_int,
    );
    if !pB.is_null() {
        (*pB).sign = ((*pB).sign == 0) as libc::c_int as libc::c_char;
        decimal_add(pA, pB);
        decimal_result(context, pA);
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSumStep(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::core::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    }
    if (*p).isInit == 0 {
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        (*p).a = sqlite3_malloc(2 as libc::c_int) as *mut libc::c_schar;
        if ((*p).a).is_null() {
            (*p).oom = 1 as libc::c_int as libc::c_char;
        } else {
            *((*p).a)
                .offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_schar;
        }
        (*p).nDigit = 1 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    }
    pArg = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        1 as libc::c_int,
    );
    decimal_add(p, pArg);
    decimal_free(pArg);
}
unsafe extern "C" fn decimalSumInverse(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::core::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    }
    pArg = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        1 as libc::c_int,
    );
    if !pArg.is_null() {
        (*pArg).sign = ((*pArg).sign == 0) as libc::c_int as libc::c_char;
    }
    decimal_add(p, pArg);
    decimal_free(pArg);
}
unsafe extern "C" fn decimalSumValue(context: *mut sqlite3_context) {
    let p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int)
        as *mut Decimal;
    if p.is_null() {
        return;
    }
    decimal_result(context, p);
}
unsafe extern "C" fn decimalSumFinalize(context: *mut sqlite3_context) {
    let p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int)
        as *mut Decimal;
    if p.is_null() {
        return;
    }
    decimal_result(context, p);
    decimal_clear(p);
}
unsafe extern "C" fn decimalMulFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        1 as libc::c_int,
    );
    let pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        1 as libc::c_int,
    );
    if !(pA.is_null() || (*pA).oom as libc::c_int != 0
        || (*pA).isNull as libc::c_int != 0 || pB.is_null()
        || (*pB).oom as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0)
    {
        decimalMul(pA, pB);
        if !((*pA).oom != 0) {
            decimal_result(context, pA);
        }
    }
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalPow2Func(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 1 as libc::c_int {
        let pA: *mut Decimal = decimalPow2(
            sqlite3_value_int(*argv.offset(0 as libc::c_int as isize)),
        );
        decimal_result_sci(context, pA);
        decimal_free(pA);
    }
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_decimal_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    static mut aFunc: [C2RustUnnamed_16; 7] = unsafe {
        [
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal\0" as *const u8 as *const libc::c_char,
                    nArg: 1 as libc::c_int,
                    iArg: 0 as libc::c_int,
                    xFunc: Some(
                        decimalFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_exp\0" as *const u8 as *const libc::c_char,
                    nArg: 1 as libc::c_int,
                    iArg: 1 as libc::c_int,
                    xFunc: Some(
                        decimalFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_cmp\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    iArg: 0 as libc::c_int,
                    xFunc: Some(
                        decimalCmpFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_add\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    iArg: 0 as libc::c_int,
                    xFunc: Some(
                        decimalAddFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_sub\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    iArg: 0 as libc::c_int,
                    xFunc: Some(
                        decimalSubFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_mul\0" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    iArg: 0 as libc::c_int,
                    xFunc: Some(
                        decimalMulFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_pow2\0" as *const u8 as *const libc::c_char,
                    nArg: 1 as libc::c_int,
                    iArg: 0 as libc::c_int,
                    xFunc: Some(
                        decimalPow2Func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while i
        < (::core::mem::size_of::<[C2RustUnnamed_16; 7]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_16>() as libc::c_ulong)
            as libc::c_int as libc::c_uint && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFuncName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            (if aFunc[i as usize].iArg != 0 { db } else { 0 as *mut sqlite3 })
                as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1);
        i;
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_window_function(
            db,
            b"decimal_sum\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalSumStep
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(decimalSumFinalize as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
            Some(decimalSumValue as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
            Some(
                decimalSumInverse
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_collation(
            db,
            b"decimal\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalCollFunc
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_void,
                        libc::c_int,
                        *const libc::c_void,
                    ) -> libc::c_int,
            ),
        );
    }
    return rc;
}
static mut b64DigitValues: [u8_0; 128] = [
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x81 as libc::c_int as u8_0,
    0x81 as libc::c_int as u8_0,
    0x81 as libc::c_int as u8_0,
    0x81 as libc::c_int as u8_0,
    0x81 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x81 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    62 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    63 as libc::c_int as u8_0,
    52 as libc::c_int as u8_0,
    53 as libc::c_int as u8_0,
    54 as libc::c_int as u8_0,
    55 as libc::c_int as u8_0,
    56 as libc::c_int as u8_0,
    57 as libc::c_int as u8_0,
    58 as libc::c_int as u8_0,
    59 as libc::c_int as u8_0,
    60 as libc::c_int as u8_0,
    61 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x80 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0 as libc::c_int as u8_0,
    1 as libc::c_int as u8_0,
    2 as libc::c_int as u8_0,
    3 as libc::c_int as u8_0,
    4 as libc::c_int as u8_0,
    5 as libc::c_int as u8_0,
    6 as libc::c_int as u8_0,
    7 as libc::c_int as u8_0,
    8 as libc::c_int as u8_0,
    9 as libc::c_int as u8_0,
    10 as libc::c_int as u8_0,
    11 as libc::c_int as u8_0,
    12 as libc::c_int as u8_0,
    13 as libc::c_int as u8_0,
    14 as libc::c_int as u8_0,
    15 as libc::c_int as u8_0,
    16 as libc::c_int as u8_0,
    17 as libc::c_int as u8_0,
    18 as libc::c_int as u8_0,
    19 as libc::c_int as u8_0,
    20 as libc::c_int as u8_0,
    21 as libc::c_int as u8_0,
    22 as libc::c_int as u8_0,
    23 as libc::c_int as u8_0,
    24 as libc::c_int as u8_0,
    25 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    26 as libc::c_int as u8_0,
    27 as libc::c_int as u8_0,
    28 as libc::c_int as u8_0,
    29 as libc::c_int as u8_0,
    30 as libc::c_int as u8_0,
    31 as libc::c_int as u8_0,
    32 as libc::c_int as u8_0,
    33 as libc::c_int as u8_0,
    34 as libc::c_int as u8_0,
    35 as libc::c_int as u8_0,
    36 as libc::c_int as u8_0,
    37 as libc::c_int as u8_0,
    38 as libc::c_int as u8_0,
    39 as libc::c_int as u8_0,
    40 as libc::c_int as u8_0,
    41 as libc::c_int as u8_0,
    42 as libc::c_int as u8_0,
    43 as libc::c_int as u8_0,
    44 as libc::c_int as u8_0,
    45 as libc::c_int as u8_0,
    46 as libc::c_int as u8_0,
    47 as libc::c_int as u8_0,
    48 as libc::c_int as u8_0,
    49 as libc::c_int as u8_0,
    50 as libc::c_int as u8_0,
    51 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
    0x82 as libc::c_int as u8_0,
];
static mut b64Numerals: [libc::c_char; 65] = unsafe {
    *::core::mem::transmute::<
        &[u8; 65],
        &[libc::c_char; 65],
    >(b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\0")
};
unsafe extern "C" fn toBase64(
    mut pIn: *mut u8_0,
    mut nbIn: libc::c_int,
    mut pOut: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut nCol: libc::c_int = 0 as libc::c_int;
    while nbIn >= 3 as libc::c_int {
        *pOut
            .offset(
                0 as libc::c_int as isize,
            ) = b64Numerals[(*pIn.offset(0 as libc::c_int as isize) as libc::c_int
            >> 2 as libc::c_int) as u8_0 as usize];
        *pOut
            .offset(
                1 as libc::c_int as isize,
            ) = b64Numerals[(((*pIn.offset(0 as libc::c_int as isize) as libc::c_int)
            << 4 as libc::c_int
            | *pIn.offset(1 as libc::c_int as isize) as libc::c_int >> 4 as libc::c_int)
            & 0x3f as libc::c_int) as u8_0 as usize];
        *pOut
            .offset(
                2 as libc::c_int as isize,
            ) = b64Numerals[((*pIn.offset(1 as libc::c_int as isize) as libc::c_int
            & 0xf as libc::c_int) << 2 as libc::c_int
            | *pIn.offset(2 as libc::c_int as isize) as libc::c_int >> 6 as libc::c_int)
            as u8_0 as usize];
        *pOut
            .offset(
                3 as libc::c_int as isize,
            ) = b64Numerals[(*pIn.offset(2 as libc::c_int as isize) as libc::c_int
            & 0x3f as libc::c_int) as u8_0 as usize];
        pOut = pOut.offset(4 as libc::c_int as isize);
        nbIn -= 3 as libc::c_int;
        pIn = pIn.offset(3 as libc::c_int as isize);
        nCol += 4 as libc::c_int;
        if nCol >= 72 as libc::c_int || nbIn <= 0 as libc::c_int {
            let fresh12 = pOut;
            pOut = pOut.offset(1);
            *fresh12 = '\n' as i32 as libc::c_char;
            nCol = 0 as libc::c_int;
        }
    }
    if nbIn > 0 as libc::c_int {
        let nco: libc::c_schar = (nbIn + 1 as libc::c_int) as libc::c_schar;
        let mut nbe: libc::c_int = 0;
        let fresh13 = pIn;
        pIn = pIn.offset(1);
        let mut qv: libc::c_ulong = *fresh13 as libc::c_ulong;
        nbe = 1 as libc::c_int;
        while nbe < 3 as libc::c_int {
            qv <<= 8 as libc::c_int;
            if nbe < nbIn {
                let fresh14 = pIn;
                pIn = pIn.offset(1);
                qv |= *fresh14 as libc::c_ulong;
            }
            nbe += 1;
            nbe;
        }
        nbe = 3 as libc::c_int;
        while nbe >= 0 as libc::c_int {
            let ce: libc::c_char = (if nbe < nco as libc::c_int {
                b64Numerals[(qv & 0x3f as libc::c_int as libc::c_ulong) as u8_0 as usize]
                    as libc::c_int
            } else {
                '=' as i32
            }) as libc::c_char;
            qv >>= 6 as libc::c_int;
            *pOut.offset(nbe as isize) = ce;
            nbe -= 1;
            nbe;
        }
        pOut = pOut.offset(4 as libc::c_int as isize);
        let fresh15 = pOut;
        pOut = pOut.offset(1);
        *fresh15 = '\n' as i32 as libc::c_char;
    }
    *pOut = 0 as libc::c_int as libc::c_char;
    return pOut;
}
unsafe extern "C" fn skipNonB64(
    mut s: *mut libc::c_char,
    mut nc: libc::c_int,
) -> *mut libc::c_char {
    let mut c: libc::c_char = 0;
    loop {
        let fresh16 = nc;
        nc = nc - 1;
        if !(fresh16 > 0 as libc::c_int
            && {
                c = *s;
                c as libc::c_int != 0
            }
            && !(((if (c as u8_0 as libc::c_int) < 0x80 as libc::c_int {
                b64DigitValues[c as u8_0 as usize] as libc::c_int
            } else {
                0x80 as libc::c_int
            }) as u8_0 as libc::c_int) < 0x80 as libc::c_int))
        {
            break;
        }
        s = s.offset(1);
        s;
    }
    return s;
}
unsafe extern "C" fn fromBase64(
    mut pIn: *mut libc::c_char,
    mut ncIn: libc::c_int,
    mut pOut: *mut u8_0,
) -> *mut u8_0 {
    if ncIn > 0 as libc::c_int
        && *pIn.offset((ncIn - 1 as libc::c_int) as isize) as libc::c_int == '\n' as i32
    {
        ncIn -= 1;
        ncIn;
    }
    while ncIn > 0 as libc::c_int && *pIn as libc::c_int != '=' as i32 {
        static mut nboi: [libc::c_schar; 5] = [
            0 as libc::c_int as libc::c_schar,
            0 as libc::c_int as libc::c_schar,
            1 as libc::c_int as libc::c_schar,
            2 as libc::c_int as libc::c_schar,
            3 as libc::c_int as libc::c_schar,
        ];
        let pUse: *mut libc::c_char = skipNonB64(pIn, ncIn);
        let mut qv: libc::c_ulong = 0 as libc::c_long as libc::c_ulong;
        let mut nti: libc::c_int = 0;
        let mut nbo: libc::c_int = 0;
        let mut nac: libc::c_int = 0;
        ncIn = (ncIn as libc::c_long - pUse.offset_from(pIn) as libc::c_long)
            as libc::c_int;
        pIn = pUse;
        nti = if ncIn > 4 as libc::c_int { 4 as libc::c_int } else { ncIn };
        ncIn -= nti;
        nbo = nboi[nti as usize] as libc::c_int;
        if nbo == 0 as libc::c_int {
            break;
        }
        nac = 0 as libc::c_int;
        while nac < 4 as libc::c_int {
            let c: libc::c_char = (if nac < nti {
                let fresh17 = pIn;
                pIn = pIn.offset(1);
                *fresh17 as libc::c_int
            } else {
                b64Numerals[0 as libc::c_int as usize] as libc::c_int
            }) as libc::c_char;
            let mut bdp: u8_0 = (if (c as u8_0 as libc::c_int) < 0x80 as libc::c_int {
                b64DigitValues[c as u8_0 as usize] as libc::c_int
            } else {
                0x80 as libc::c_int
            }) as u8_0;
            let mut current_block_15: u64;
            match bdp as libc::c_int {
                130 => {
                    ncIn = 0 as libc::c_int;
                    current_block_15 = 9525109725595034018;
                }
                129 => {
                    current_block_15 = 9525109725595034018;
                }
                128 => {
                    current_block_15 = 8403548051123052216;
                }
                _ => {
                    current_block_15 = 12498766310885214632;
                }
            }
            match current_block_15 {
                9525109725595034018 => {
                    nti = nac;
                    current_block_15 = 8403548051123052216;
                }
                _ => {}
            }
            match current_block_15 {
                8403548051123052216 => {
                    bdp = 0 as libc::c_int as u8_0;
                    nbo -= 1;
                    nbo;
                }
                _ => {}
            }
            qv = qv << 6 as libc::c_int | bdp as libc::c_ulong;
            nac += 1;
            nac;
        }
        let mut current_block_21: u64;
        match nbo {
            3 => {
                *pOut
                    .offset(
                        2 as libc::c_int as isize,
                    ) = (qv & 0xff as libc::c_int as libc::c_ulong) as u8_0;
                current_block_21 = 6713575105830551042;
            }
            2 => {
                current_block_21 = 6713575105830551042;
            }
            1 => {
                current_block_21 = 11848553083440969757;
            }
            _ => {
                current_block_21 = 10652014663920648156;
            }
        }
        match current_block_21 {
            6713575105830551042 => {
                *pOut
                    .offset(
                        1 as libc::c_int as isize,
                    ) = (qv >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_ulong)
                    as u8_0;
                current_block_21 = 11848553083440969757;
            }
            _ => {}
        }
        match current_block_21 {
            11848553083440969757 => {
                *pOut
                    .offset(
                        0 as libc::c_int as isize,
                    ) = (qv >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_ulong)
                    as u8_0;
            }
            _ => {}
        }
        pOut = pOut.offset(nbo as isize);
    }
    return pOut;
}
unsafe extern "C" fn base64(
    context: *mut sqlite3_context,
    na: libc::c_int,
    av: *mut *mut sqlite3_value,
) {
    let current_block: u64;
    let mut nb: libc::c_int = 0;
    let mut nc: libc::c_int = 0;
    let nv: libc::c_int = sqlite3_value_bytes(*av.offset(0 as libc::c_int as isize));
    let nvMax: libc::c_int = sqlite3_limit(
        sqlite3_context_db_handle(context),
        0 as libc::c_int,
        -(1 as libc::c_int),
    );
    let mut cBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bBuf: *mut u8_0 = 0 as *mut u8_0;
    if na == 1 as libc::c_int {} else {
        __assert_fail(
            b"na==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            3949 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 54],
                &[libc::c_char; 54],
            >(b"void base64(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_27337: {
        if na == 1 as libc::c_int {} else {
            __assert_fail(
                b"na==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                3949 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 54],
                    &[libc::c_char; 54],
                >(b"void base64(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    match sqlite3_value_type(*av.offset(0 as libc::c_int as isize)) {
        4 => {
            nb = nv;
            nc = 4 as libc::c_int * (nv + 2 as libc::c_int / 3 as libc::c_int);
            nc
                += (nc + (72 as libc::c_int - 1 as libc::c_int)) / 72 as libc::c_int
                    + 1 as libc::c_int;
            if nvMax < nc {
                sqlite3_result_error(
                    context,
                    b"blob expanded to base64 too big\0" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                );
                return;
            }
            bBuf = sqlite3_value_blob(*av.offset(0 as libc::c_int as isize))
                as *mut u8_0;
            if bBuf.is_null() {
                if 7 as libc::c_int
                    == sqlite3_errcode(sqlite3_context_db_handle(context))
                {
                    current_block = 9789715472015171772;
                } else {
                    sqlite3_result_text(
                        context,
                        b"\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        None,
                    );
                    current_block = 8693738493027456495;
                }
            } else {
                cBuf = sqlite3_malloc(nc) as *mut libc::c_char;
                if cBuf.is_null() {
                    current_block = 9789715472015171772;
                } else {
                    nc = (toBase64(bBuf, nb, cBuf)).offset_from(cBuf) as libc::c_long
                        as libc::c_int;
                    sqlite3_result_text(
                        context,
                        cBuf,
                        nc,
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    current_block = 8693738493027456495;
                }
            }
        }
        3 => {
            nc = nv;
            nb = 3 as libc::c_int * ((nv + 3 as libc::c_int) / 4 as libc::c_int);
            if nvMax < nb {
                sqlite3_result_error(
                    context,
                    b"blob from base64 may be too big\0" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                );
                return;
            } else if nb < 1 as libc::c_int {
                nb = 1 as libc::c_int;
            }
            cBuf = sqlite3_value_text(*av.offset(0 as libc::c_int as isize))
                as *mut libc::c_char;
            if cBuf.is_null() {
                if 7 as libc::c_int
                    == sqlite3_errcode(sqlite3_context_db_handle(context))
                {
                    current_block = 9789715472015171772;
                } else {
                    sqlite3_result_zeroblob(context, 0 as libc::c_int);
                    current_block = 8693738493027456495;
                }
            } else {
                bBuf = sqlite3_malloc(nb) as *mut u8_0;
                if bBuf.is_null() {
                    current_block = 9789715472015171772;
                } else {
                    nb = (fromBase64(cBuf, nc, bBuf)).offset_from(bBuf) as libc::c_long
                        as libc::c_int;
                    sqlite3_result_blob(
                        context,
                        bBuf as *const libc::c_void,
                        nb,
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    current_block = 8693738493027456495;
                }
            }
        }
        _ => {
            sqlite3_result_error(
                context,
                b"base64 accepts only blob or text\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    match current_block {
        8693738493027456495 => return,
        _ => {
            sqlite3_result_error(
                context,
                b"base64 OOM\0" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_base64_init(
    db: *mut sqlite3,
    _pzErr: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3_create_function(
        db,
        b"base64\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0x800 as libc::c_int | 0x200000 as libc::c_int | 0x80000 as libc::c_int
            | 1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            base64
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
}
static mut b85_cOffset: [u8_0; 5] = [
    0 as libc::c_int as u8_0,
    '#' as i32 as u8_0,
    0 as libc::c_int as u8_0,
    ('*' as i32 - 4 as libc::c_int) as u8_0,
    0 as libc::c_int as u8_0,
];
unsafe extern "C" fn skipNonB85(
    mut s: *mut libc::c_char,
    mut nc: libc::c_int,
) -> *mut libc::c_char {
    let mut c: libc::c_char = 0;
    loop {
        let fresh18 = nc;
        nc = nc - 1;
        if !(fresh18 > 0 as libc::c_int
            && {
                c = *s;
                c as libc::c_int != 0
            }
            && (c as libc::c_int >= '#' as i32) as libc::c_int
                + (c as libc::c_int > '&' as i32) as libc::c_int
                + (c as libc::c_int >= '*' as i32) as libc::c_int
                + (c as libc::c_int > 'z' as i32) as libc::c_int & 1 as libc::c_int == 0)
        {
            break;
        }
        s = s.offset(1);
        s;
    }
    return s;
}
unsafe extern "C" fn putcs(
    mut pc: *mut libc::c_char,
    mut s: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut c: libc::c_char = 0;
    loop {
        let fresh19 = s;
        s = s.offset(1);
        c = *fresh19;
        if !(c as libc::c_int != 0 as libc::c_int) {
            break;
        }
        let fresh20 = pc;
        pc = pc.offset(1);
        *fresh20 = c;
    }
    return pc;
}
unsafe extern "C" fn toBase85(
    mut pIn: *mut u8_0,
    mut nbIn: libc::c_int,
    mut pOut: *mut libc::c_char,
    pSep: *mut libc::c_char,
) -> *mut libc::c_char {
    let mut nCol: libc::c_int = 0 as libc::c_int;
    while nbIn >= 4 as libc::c_int {
        let mut nco: libc::c_int = 5 as libc::c_int;
        let mut qbv: libc::c_ulong = (*pIn.offset(0 as libc::c_int as isize)
            as libc::c_ulong) << 24 as libc::c_int
            | ((*pIn.offset(1 as libc::c_int as isize) as libc::c_int)
                << 16 as libc::c_int) as libc::c_ulong
            | ((*pIn.offset(2 as libc::c_int as isize) as libc::c_int)
                << 8 as libc::c_int) as libc::c_ulong
            | *pIn.offset(3 as libc::c_int as isize) as libc::c_ulong;
        while nco > 0 as libc::c_int {
            let nqv: libc::c_uint = qbv.wrapping_div(85 as libc::c_ulong)
                as libc::c_uint;
            let dv: libc::c_uchar = qbv
                .wrapping_sub((85 as libc::c_ulong).wrapping_mul(nqv as libc::c_ulong))
                as libc::c_uchar;
            qbv = nqv as libc::c_ulong;
            nco -= 1;
            *pOut
                .offset(
                    nco as isize,
                ) = (if (dv as libc::c_int) < 4 as libc::c_int {
                (dv as libc::c_int + '#' as i32) as libc::c_char as libc::c_int
            } else {
                (dv as libc::c_int - 4 as libc::c_int + '*' as i32) as libc::c_char
                    as libc::c_int
            }) as libc::c_char;
        }
        nbIn -= 4 as libc::c_int;
        pIn = pIn.offset(4 as libc::c_int as isize);
        pOut = pOut.offset(5 as libc::c_int as isize);
        if !pSep.is_null()
            && {
                nCol += 5 as libc::c_int;
                nCol >= 80 as libc::c_int
            }
        {
            pOut = putcs(pOut, pSep);
            nCol = 0 as libc::c_int;
        }
    }
    if nbIn > 0 as libc::c_int {
        let mut nco_0: libc::c_int = nbIn + 1 as libc::c_int;
        let fresh21 = pIn;
        pIn = pIn.offset(1);
        let mut qv: libc::c_ulong = *fresh21 as libc::c_ulong;
        let mut nbe: libc::c_int = 1 as libc::c_int;
        loop {
            let fresh22 = nbe;
            nbe = nbe + 1;
            if !(fresh22 < nbIn) {
                break;
            }
            let fresh23 = pIn;
            pIn = pIn.offset(1);
            qv = qv << 8 as libc::c_int | *fresh23 as libc::c_ulong;
        }
        nCol += nco_0;
        while nco_0 > 0 as libc::c_int {
            let dv_0: u8_0 = qv.wrapping_rem(85 as libc::c_int as libc::c_ulong)
                as u8_0;
            qv = qv.wrapping_div(85 as libc::c_int as libc::c_ulong);
            nco_0 -= 1;
            *pOut
                .offset(
                    nco_0 as isize,
                ) = (if (dv_0 as libc::c_int) < 4 as libc::c_int {
                (dv_0 as libc::c_int + '#' as i32) as libc::c_char as libc::c_int
            } else {
                (dv_0 as libc::c_int - 4 as libc::c_int + '*' as i32) as libc::c_char
                    as libc::c_int
            }) as libc::c_char;
        }
        pOut = pOut.offset((nbIn + 1 as libc::c_int) as isize);
    }
    if !pSep.is_null() && nCol > 0 as libc::c_int {
        pOut = putcs(pOut, pSep);
    }
    *pOut = 0 as libc::c_int as libc::c_char;
    return pOut;
}
unsafe extern "C" fn fromBase85(
    mut pIn: *mut libc::c_char,
    mut ncIn: libc::c_int,
    mut pOut: *mut u8_0,
) -> *mut u8_0 {
    if ncIn > 0 as libc::c_int
        && *pIn.offset((ncIn - 1 as libc::c_int) as isize) as libc::c_int == '\n' as i32
    {
        ncIn -= 1;
        ncIn;
    }
    while ncIn > 0 as libc::c_int {
        static mut nboi: [libc::c_schar; 6] = [
            0 as libc::c_int as libc::c_schar,
            0 as libc::c_int as libc::c_schar,
            1 as libc::c_int as libc::c_schar,
            2 as libc::c_int as libc::c_schar,
            3 as libc::c_int as libc::c_schar,
            4 as libc::c_int as libc::c_schar,
        ];
        let pUse: *mut libc::c_char = skipNonB85(pIn, ncIn);
        let mut qv: libc::c_ulong = 0 as libc::c_long as libc::c_ulong;
        let mut nti: libc::c_int = 0;
        let mut nbo: libc::c_int = 0;
        ncIn = (ncIn as libc::c_long - pUse.offset_from(pIn) as libc::c_long)
            as libc::c_int;
        pIn = pUse;
        nti = if ncIn > 5 as libc::c_int { 5 as libc::c_int } else { ncIn };
        nbo = nboi[nti as usize] as libc::c_int;
        if nbo == 0 as libc::c_int {
            break;
        }
        while nti > 0 as libc::c_int {
            let fresh24 = pIn;
            pIn = pIn.offset(1);
            let c: libc::c_char = *fresh24;
            let cdo: u8_0 = b85_cOffset[((c as libc::c_int >= '#' as i32)
                as libc::c_int + (c as libc::c_int > '&' as i32) as libc::c_int
                + (c as libc::c_int >= '*' as i32) as libc::c_int
                + (c as libc::c_int > 'z' as i32) as libc::c_int) as usize];
            ncIn -= 1;
            ncIn;
            if cdo as libc::c_int == 0 as libc::c_int {
                break;
            }
            qv = (85 as libc::c_int as libc::c_ulong)
                .wrapping_mul(qv)
                .wrapping_add((c as libc::c_int - cdo as libc::c_int) as libc::c_ulong);
            nti -= 1;
            nti;
        }
        nbo -= nti;
        let mut current_block_14: u64;
        match nbo {
            4 => {
                let fresh25 = pOut;
                pOut = pOut.offset(1);
                *fresh25 = (qv >> 24 as libc::c_int
                    & 0xff as libc::c_int as libc::c_ulong) as u8_0;
                current_block_14 = 10809331421524876644;
            }
            3 => {
                current_block_14 = 10809331421524876644;
            }
            2 => {
                current_block_14 = 7801130647513032839;
            }
            1 => {
                current_block_14 = 11358167210899834763;
            }
            0 | _ => {
                current_block_14 = 15904375183555213903;
            }
        }
        match current_block_14 {
            10809331421524876644 => {
                let fresh26 = pOut;
                pOut = pOut.offset(1);
                *fresh26 = (qv >> 16 as libc::c_int
                    & 0xff as libc::c_int as libc::c_ulong) as u8_0;
                current_block_14 = 7801130647513032839;
            }
            _ => {}
        }
        match current_block_14 {
            7801130647513032839 => {
                let fresh27 = pOut;
                pOut = pOut.offset(1);
                *fresh27 = (qv >> 8 as libc::c_int
                    & 0xff as libc::c_int as libc::c_ulong) as u8_0;
                current_block_14 = 11358167210899834763;
            }
            _ => {}
        }
        match current_block_14 {
            11358167210899834763 => {
                let fresh28 = pOut;
                pOut = pOut.offset(1);
                *fresh28 = (qv & 0xff as libc::c_int as libc::c_ulong) as u8_0;
            }
            _ => {}
        }
    }
    return pOut;
}
unsafe extern "C" fn base85(
    context: *mut sqlite3_context,
    na: libc::c_int,
    av: *mut *mut sqlite3_value,
) {
    let current_block: u64;
    let mut nb: libc::c_int = 0;
    let mut nc: libc::c_int = 0;
    let nv: libc::c_int = sqlite3_value_bytes(*av.offset(0 as libc::c_int as isize));
    let nvMax: libc::c_int = sqlite3_limit(
        sqlite3_context_db_handle(context),
        0 as libc::c_int,
        -(1 as libc::c_int),
    );
    let mut cBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bBuf: *mut u8_0 = 0 as *mut u8_0;
    if na == 1 as libc::c_int {} else {
        __assert_fail(
            b"na==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            4325 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 54],
                &[libc::c_char; 54],
            >(b"void base85(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_28451: {
        if na == 1 as libc::c_int {} else {
            __assert_fail(
                b"na==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                4325 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 54],
                    &[libc::c_char; 54],
                >(b"void base85(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    match sqlite3_value_type(*av.offset(0 as libc::c_int as isize)) {
        4 => {
            nb = nv;
            nc = 5 as libc::c_int * (nv / 4 as libc::c_int) + nv % 4 as libc::c_int
                + nv / 64 as libc::c_int + 1 as libc::c_int + 2 as libc::c_int;
            if nvMax < nc {
                sqlite3_result_error(
                    context,
                    b"blob expanded to base85 too big\0" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                );
                return;
            }
            bBuf = sqlite3_value_blob(*av.offset(0 as libc::c_int as isize))
                as *mut u8_0;
            if bBuf.is_null() {
                if 7 as libc::c_int
                    == sqlite3_errcode(sqlite3_context_db_handle(context))
                {
                    current_block = 9586500639934038501;
                } else {
                    sqlite3_result_text(
                        context,
                        b"\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        None,
                    );
                    current_block = 7205609094909031804;
                }
            } else {
                cBuf = sqlite3_malloc(nc) as *mut libc::c_char;
                if cBuf.is_null() {
                    current_block = 9586500639934038501;
                } else {
                    nc = (toBase85(
                        bBuf,
                        nb,
                        cBuf,
                        b"\n\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    ))
                        .offset_from(cBuf) as libc::c_long as libc::c_int;
                    sqlite3_result_text(
                        context,
                        cBuf,
                        nc,
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    current_block = 7205609094909031804;
                }
            }
        }
        3 => {
            nc = nv;
            nb = 4 as libc::c_int * (nv / 5 as libc::c_int) + nv % 5 as libc::c_int;
            if nvMax < nb {
                sqlite3_result_error(
                    context,
                    b"blob from base85 may be too big\0" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                );
                return;
            } else if nb < 1 as libc::c_int {
                nb = 1 as libc::c_int;
            }
            cBuf = sqlite3_value_text(*av.offset(0 as libc::c_int as isize))
                as *mut libc::c_char;
            if cBuf.is_null() {
                if 7 as libc::c_int
                    == sqlite3_errcode(sqlite3_context_db_handle(context))
                {
                    current_block = 9586500639934038501;
                } else {
                    sqlite3_result_zeroblob(context, 0 as libc::c_int);
                    current_block = 7205609094909031804;
                }
            } else {
                bBuf = sqlite3_malloc(nb) as *mut u8_0;
                if bBuf.is_null() {
                    current_block = 9586500639934038501;
                } else {
                    nb = (fromBase85(cBuf, nc, bBuf)).offset_from(bBuf) as libc::c_long
                        as libc::c_int;
                    sqlite3_result_blob(
                        context,
                        bBuf as *const libc::c_void,
                        nb,
                        Some(
                            sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> (),
                        ),
                    );
                    current_block = 7205609094909031804;
                }
            }
        }
        _ => {
            sqlite3_result_error(
                context,
                b"base85 accepts only blob or text.\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    match current_block {
        7205609094909031804 => return,
        _ => {
            sqlite3_result_error(
                context,
                b"base85 OOM\0" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_base85_init(
    db: *mut sqlite3,
    _pzErr: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3_create_function(
        db,
        b"base85\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0x800 as libc::c_int | 0x200000 as libc::c_int | 0x80000 as libc::c_int
            | 1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            base85
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
}
unsafe extern "C" fn ieee754func(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    if argc == 1 as libc::c_int {
        let mut m: sqlite3_int64 = 0;
        let mut a: sqlite3_int64 = 0;
        let mut r: libc::c_double = 0.;
        let mut e: libc::c_int = 0;
        let mut isNeg: libc::c_int = 0;
        let mut zResult: [libc::c_char; 100] = [0; 100];
        if ::core::mem::size_of::<sqlite3_int64>() as libc::c_ulong
            == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {} else {
            __assert_fail(
                b"sizeof(m)==sizeof(r)\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                4601 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 59],
                    &[libc::c_char; 59],
                >(b"void ieee754func(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
        'c_29116: {
            if ::core::mem::size_of::<sqlite3_int64>() as libc::c_ulong
                == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
            {} else {
                __assert_fail(
                    b"sizeof(m)==sizeof(r)\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    4601 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 59],
                        &[libc::c_char; 59],
                    >(b"void ieee754func(sqlite3_context *, int, sqlite3_value **)\0"))
                        .as_ptr(),
                );
            }
        };
        if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 4 as libc::c_int
            && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
                as libc::c_ulong
                == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            let x: *const libc::c_uchar = sqlite3_value_blob(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const libc::c_uchar;
            let mut i: libc::c_uint = 0;
            let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
            i = 0 as libc::c_int as libc::c_uint;
            while (i as libc::c_ulong)
                < ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
            {
                v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
                i = i.wrapping_add(1);
                i;
            }
            memcpy(
                &mut r as *mut libc::c_double as *mut libc::c_void,
                &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
            );
        } else {
            r = sqlite3_value_double(*argv.offset(0 as libc::c_int as isize));
        }
        if r < 0.0f64 {
            isNeg = 1 as libc::c_int;
            r = -r;
        } else {
            isNeg = 0 as libc::c_int;
        }
        memcpy(
            &mut a as *mut sqlite3_int64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::core::mem::size_of::<sqlite3_int64>() as libc::c_ulong,
        );
        if a == 0 as libc::c_int as libc::c_longlong {
            e = 0 as libc::c_int;
            m = 0 as libc::c_int as sqlite3_int64;
        } else {
            e = (a >> 52 as libc::c_int) as libc::c_int;
            m = a
                & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                    - 1 as libc::c_int as libc::c_longlong;
            if e == 0 as libc::c_int {
                m <<= 1 as libc::c_int;
            } else {
                m |= (1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int;
            }
            while e < 1075 as libc::c_int && m > 0 as libc::c_int as libc::c_longlong
                && m & 1 as libc::c_int as libc::c_longlong
                    == 0 as libc::c_int as libc::c_longlong
            {
                m >>= 1 as libc::c_int;
                e += 1;
                e;
            }
            if isNeg != 0 {
                m = -m;
            }
        }
        match *(sqlite3_user_data(context) as *mut libc::c_int) {
            0 => {
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                        as libc::c_int,
                    zResult.as_mut_ptr(),
                    b"ieee754(%lld,%d)\0" as *const u8 as *const libc::c_char,
                    m,
                    e - 1075 as libc::c_int,
                );
                sqlite3_result_text(
                    context,
                    zResult.as_mut_ptr(),
                    -(1 as libc::c_int),
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            }
            1 => {
                sqlite3_result_int64(context, m);
            }
            2 => {
                sqlite3_result_int(context, e - 1075 as libc::c_int);
            }
            _ => {}
        }
    } else {
        let mut m_0: sqlite3_int64 = 0;
        let mut e_0: sqlite3_int64 = 0;
        let mut a_0: sqlite3_int64 = 0;
        let mut r_0: libc::c_double = 0.;
        let mut isNeg_0: libc::c_int = 0 as libc::c_int;
        m_0 = sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize));
        e_0 = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        if e_0 > 10000 as libc::c_int as libc::c_longlong {
            e_0 = 10000 as libc::c_int as sqlite3_int64;
        } else if e_0 < -(10000 as libc::c_int) as libc::c_longlong {
            e_0 = -(10000 as libc::c_int) as sqlite3_int64;
        }
        if m_0 < 0 as libc::c_int as libc::c_longlong {
            isNeg_0 = 1 as libc::c_int;
            m_0 = -m_0;
            if m_0 < 0 as libc::c_int as libc::c_longlong {
                return;
            }
        } else if m_0 == 0 as libc::c_int as libc::c_longlong
            && e_0 > -(1000 as libc::c_int) as libc::c_longlong
            && e_0 < 1000 as libc::c_int as libc::c_longlong
        {
            sqlite3_result_double(context, 0.0f64);
            return;
        }
        while m_0 >> 32 as libc::c_int & 0xffe00000 as libc::c_uint as libc::c_longlong
            != 0
        {
            m_0 >>= 1 as libc::c_int;
            e_0 += 1;
            e_0;
        }
        while m_0 != 0 as libc::c_int as libc::c_longlong
            && m_0 >> 32 as libc::c_int & 0xfff00000 as libc::c_uint as libc::c_longlong
                == 0 as libc::c_int as libc::c_longlong
        {
            m_0 <<= 1 as libc::c_int;
            e_0 -= 1;
            e_0;
        }
        e_0 += 1075 as libc::c_int as libc::c_longlong;
        if e_0 <= 0 as libc::c_int as libc::c_longlong {
            if 1 as libc::c_int as libc::c_longlong - e_0
                >= 64 as libc::c_int as libc::c_longlong
            {
                m_0 = 0 as libc::c_int as sqlite3_int64;
            } else {
                m_0 >>= 1 as libc::c_int as libc::c_longlong - e_0;
            }
            e_0 = 0 as libc::c_int as sqlite3_int64;
        } else if e_0 > 0x7ff as libc::c_int as libc::c_longlong {
            e_0 = 0x7ff as libc::c_int as sqlite3_int64;
        }
        a_0 = m_0
            & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong;
        a_0 |= e_0 << 52 as libc::c_int;
        if isNeg_0 != 0 {
            a_0 = (a_0 as libc::c_ulonglong
                | (1 as libc::c_int as sqlite3_uint64) << 63 as libc::c_int)
                as sqlite3_int64;
        }
        memcpy(
            &mut r_0 as *mut libc::c_double as *mut libc::c_void,
            &mut a_0 as *mut sqlite3_int64 as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r_0);
    };
}
unsafe extern "C" fn ieee754func_from_blob(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int
        && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as libc::c_ulong
            == ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
    {
        let mut r: libc::c_double = 0.;
        let x: *const libc::c_uchar = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const libc::c_uchar;
        let mut i: libc::c_uint = 0;
        let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong)
            < ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
            i = i.wrapping_add(1);
            i;
        }
        memcpy(
            &mut r as *mut libc::c_double as *mut libc::c_void,
            &mut v as *mut sqlite3_uint64 as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r);
    }
}
unsafe extern "C" fn ieee754func_to_blob(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 2 as libc::c_int
        || sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
            == 1 as libc::c_int
    {
        let mut r: libc::c_double = sqlite3_value_double(
            *argv.offset(0 as libc::c_int as isize),
        );
        let mut v: sqlite3_uint64 = 0;
        let mut a: [libc::c_uchar; 8] = [0; 8];
        let mut i: libc::c_uint = 0;
        memcpy(
            &mut v as *mut sqlite3_uint64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        i = 1 as libc::c_int as libc::c_uint;
        while i as libc::c_ulong
            <= ::core::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            a[(::core::mem::size_of::<libc::c_double>() as libc::c_ulong)
                .wrapping_sub(i as libc::c_ulong)
                as usize] = (v & 0xff as libc::c_int as libc::c_ulonglong)
                as libc::c_uchar;
            v >>= 8 as libc::c_int;
            i = i.wrapping_add(1);
            i;
        }
        sqlite3_result_blob(
            context,
            a.as_mut_ptr() as *const libc::c_void,
            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong as libc::c_int,
            ::core::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
    }
}
unsafe extern "C" fn ieee754inc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut r: libc::c_double = 0.;
    let mut N: sqlite3_int64 = 0;
    let mut m1: sqlite3_uint64 = 0;
    let mut m2: sqlite3_uint64 = 0;
    let mut r2: libc::c_double = 0.;
    r = sqlite3_value_double(*argv.offset(0 as libc::c_int as isize));
    N = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
    memcpy(
        &mut m1 as *mut sqlite3_uint64 as *mut libc::c_void,
        &mut r as *mut libc::c_double as *const libc::c_void,
        8 as libc::c_int as libc::c_ulong,
    );
    m2 = m1.wrapping_add(N as libc::c_ulonglong);
    memcpy(
        &mut r2 as *mut libc::c_double as *mut libc::c_void,
        &mut m2 as *mut sqlite3_uint64 as *const libc::c_void,
        8 as libc::c_int as libc::c_ulong,
    );
    sqlite3_result_double(context, r2);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_ieee_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    static mut aFunc: [C2RustUnnamed_17; 7] = unsafe {
        [
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 2 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754_mantissa\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 1 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754_exponent\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 2 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754_to_blob\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_to_blob
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754_from_blob\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_from_blob
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let init = C2RustUnnamed_17 {
                    zFName: b"ieee754_inc\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 2 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754inc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::core::mem::size_of::<[C2RustUnnamed_17; 7]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int,
            &(*aFunc.as_ptr().offset(i as isize)).iAux as *const libc::c_int
                as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1);
        i;
    }
    return rc;
}
unsafe extern "C" fn genSeqMember(
    mut smBase: sqlite3_int64,
    smStep: sqlite3_int64,
    mut ix: sqlite3_uint64,
) -> sqlite3_int64 {
    if ix >= 9223372036854775807 as libc::c_longlong as sqlite3_uint64 {
        ix = (ix as libc::c_ulonglong)
            .wrapping_sub(9223372036854775807 as libc::c_longlong as sqlite3_uint64)
            as sqlite3_uint64 as sqlite3_uint64;
        smBase
            += 9223372036854775807 as libc::c_longlong
                / 2 as libc::c_int as libc::c_longlong * smStep;
        smBase
            += (9223372036854775807 as libc::c_longlong
                - 9223372036854775807 as libc::c_longlong
                    / 2 as libc::c_int as libc::c_longlong) * smStep;
    }
    if ix >= 2 as libc::c_int as libc::c_ulonglong {
        let ix2: sqlite3_int64 = ix as sqlite3_int64
            / 2 as libc::c_int as libc::c_longlong;
        smBase += ix2 * smStep;
        ix = (ix as libc::c_ulonglong).wrapping_sub(ix2 as libc::c_ulonglong)
            as sqlite3_uint64 as sqlite3_uint64;
    }
    return smBase + ix as sqlite3_int64 * smStep;
}
unsafe extern "C" fn setupSequence(pss: *mut SequenceSpec) {
    let mut bSameSigns: libc::c_int = 0;
    (*pss).uSeqIndexMax = 0 as libc::c_int as sqlite3_uint64;
    (*pss).isNotEOF = 0 as libc::c_int as u8_0;
    bSameSigns = (((*pss).iBase < 0 as libc::c_int as libc::c_longlong) as libc::c_int
        == ((*pss).iTerm < 0 as libc::c_int as libc::c_longlong) as libc::c_int)
        as libc::c_int;
    if (*pss).iTerm < (*pss).iBase {
        let mut nuspan: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        if bSameSigns != 0 {
            nuspan = ((*pss).iBase - (*pss).iTerm) as sqlite3_uint64;
        } else {
            nuspan = 1 as libc::c_int as sqlite3_uint64;
            nuspan = (nuspan as libc::c_ulonglong)
                .wrapping_add((*pss).iBase as libc::c_ulonglong) as sqlite3_uint64
                as sqlite3_uint64;
            nuspan = (nuspan as libc::c_ulonglong)
                .wrapping_add(
                    -((*pss).iTerm + 1 as libc::c_int as libc::c_longlong)
                        as libc::c_ulonglong,
                ) as sqlite3_uint64 as sqlite3_uint64;
        }
        if (*pss).iStep < 0 as libc::c_int as libc::c_longlong {
            (*pss).isNotEOF = 1 as libc::c_int as u8_0;
            if nuspan
                == (9223372036854775807 as libc::c_long as libc::c_ulong)
                    .wrapping_mul(2 as libc::c_ulong)
                    .wrapping_add(1 as libc::c_ulong) as libc::c_ulonglong
            {
                (*pss)
                    .uSeqIndexMax = if (*pss).iStep
                    > -(9223372036854775807 as libc::c_longlong) - 1 as libc::c_longlong
                {
                    nuspan.wrapping_div(-(*pss).iStep as libc::c_ulonglong)
                } else {
                    1 as libc::c_int as libc::c_ulonglong
                };
            } else if (*pss).iStep
                > -(9223372036854775807 as libc::c_longlong) - 1 as libc::c_longlong
            {
                (*pss)
                    .uSeqIndexMax = nuspan
                    .wrapping_div(-(*pss).iStep as libc::c_ulonglong);
            }
        }
    } else if (*pss).iTerm > (*pss).iBase {
        let mut puspan: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        if bSameSigns != 0 {
            puspan = ((*pss).iTerm - (*pss).iBase) as sqlite3_uint64;
        } else {
            puspan = 1 as libc::c_int as sqlite3_uint64;
            puspan = (puspan as libc::c_ulonglong)
                .wrapping_add((*pss).iTerm as libc::c_ulonglong) as sqlite3_uint64
                as sqlite3_uint64;
            puspan = (puspan as libc::c_ulonglong)
                .wrapping_add(
                    -((*pss).iBase + 1 as libc::c_int as libc::c_longlong)
                        as libc::c_ulonglong,
                ) as sqlite3_uint64 as sqlite3_uint64;
        }
        if (*pss).iStep > 0 as libc::c_int as libc::c_longlong {
            (*pss).isNotEOF = 1 as libc::c_int as u8_0;
            (*pss).uSeqIndexMax = puspan.wrapping_div((*pss).iStep as libc::c_ulonglong);
        }
    } else if (*pss).iTerm == (*pss).iBase {
        (*pss).isNotEOF = 1 as libc::c_int as u8_0;
        (*pss).uSeqIndexMax = 0 as libc::c_int as sqlite3_uint64;
    }
    (*pss)
        .uSeqIndexNow = if (*pss).isReversing as libc::c_int != 0 {
        (*pss).uSeqIndexMax
    } else {
        0 as libc::c_int as libc::c_ulonglong
    };
    (*pss)
        .iValueNow = if (*pss).isReversing as libc::c_int != 0 {
        genSeqMember((*pss).iBase, (*pss).iStep, (*pss).uSeqIndexMax)
    } else {
        (*pss).iBase
    };
}
unsafe extern "C" fn progressSequence(pss: *mut SequenceSpec) -> libc::c_int {
    if (*pss).isNotEOF == 0 {
        return 0 as libc::c_int;
    }
    if (*pss).isReversing != 0 {
        if (*pss).uSeqIndexNow > 0 as libc::c_int as libc::c_ulonglong {
            (*pss).uSeqIndexNow = ((*pss).uSeqIndexNow).wrapping_sub(1);
            (*pss).uSeqIndexNow;
            (*pss).iValueNow -= (*pss).iStep;
        } else {
            (*pss).isNotEOF = 0 as libc::c_int as u8_0;
        }
    } else if (*pss).uSeqIndexNow < (*pss).uSeqIndexMax {
        (*pss).uSeqIndexNow = ((*pss).uSeqIndexNow).wrapping_add(1);
        (*pss).uSeqIndexNow;
        (*pss).iValueNow += (*pss).iStep;
    } else {
        (*pss).isNotEOF = 0 as libc::c_int as u8_0;
    }
    return (*pss).isNotEOF as libc::c_int;
}
unsafe extern "C" fn seriesConnect(
    db: *mut sqlite3,
    _pUnused: *mut libc::c_void,
    _argcUnused: libc::c_int,
    _argvUnused: *const *const libc::c_char,
    ppVtab: *mut *mut sqlite3_vtab,
    _pzErrUnused: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut sqlite3_vtab = 0 as *mut sqlite3_vtab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(value,start hidden,stop hidden,step hidden)\0" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        *ppVtab = sqlite3_malloc(
            ::core::mem::size_of::<sqlite3_vtab>() as libc::c_ulong as libc::c_int,
        ) as *mut sqlite3_vtab;
        pNew = *ppVtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<sqlite3_vtab>() as libc::c_ulong,
        );
        sqlite3_vtab_config(db, 2 as libc::c_int);
    }
    return rc;
}
unsafe extern "C" fn seriesDisconnect(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesOpen(
    _pUnused: *mut sqlite3_vtab,
    ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = 0 as *mut series_cursor;
    pCur = sqlite3_malloc(
        ::core::mem::size_of::<series_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut series_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<series_cursor>() as libc::c_ulong,
    );
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesClose(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesNext(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut series_cursor = cur as *mut series_cursor;
    progressSequence(&mut (*pCur).ss);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesColumn(
    cur: *mut sqlite3_vtab_cursor,
    ctx: *mut sqlite3_context,
    i: libc::c_int,
) -> libc::c_int {
    let pCur: *mut series_cursor = cur as *mut series_cursor;
    let mut x: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    match i {
        1 => {
            x = (*pCur).ss.iBase;
        }
        2 => {
            x = (*pCur).ss.iTerm;
        }
        3 => {
            x = (*pCur).ss.iStep;
        }
        _ => {
            x = (*pCur).ss.iValueNow;
        }
    }
    sqlite3_result_int64(ctx, x);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesRowid(
    cur: *mut sqlite3_vtab_cursor,
    pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let pCur: *mut series_cursor = cur as *mut series_cursor;
    let n: sqlite3_uint64 = (*pCur).ss.uSeqIndexNow;
    *pRowid = (if n
        < 0xffffffff as libc::c_uint as libc::c_ulonglong
            | (0xffffffff as libc::c_uint as sqlite3_uint64) << 32 as libc::c_int
    {
        n.wrapping_add(1 as libc::c_int as libc::c_ulonglong)
    } else {
        0 as libc::c_int as libc::c_ulonglong
    }) as sqlite3_int64;
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesEof(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut series_cursor = cur as *mut series_cursor;
    return ((*pCur).ss.isNotEOF == 0) as libc::c_int;
}
unsafe extern "C" fn seriesFilter(
    pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    _idxStrUnused: *const libc::c_char,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let pCur: *mut series_cursor = pVtabCursor as *mut series_cursor;
    let mut i: libc::c_int = 0 as libc::c_int;
    if idxNum & 1 as libc::c_int != 0 {
        let fresh29 = i;
        i = i + 1;
        (*pCur).ss.iBase = sqlite3_value_int64(*argv.offset(fresh29 as isize));
    } else {
        (*pCur).ss.iBase = 0 as libc::c_int as sqlite3_int64;
    }
    if idxNum & 2 as libc::c_int != 0 {
        let fresh30 = i;
        i = i + 1;
        (*pCur).ss.iTerm = sqlite3_value_int64(*argv.offset(fresh30 as isize));
    } else {
        (*pCur).ss.iTerm = 0xffffffff as libc::c_uint as sqlite3_int64;
    }
    if idxNum & 4 as libc::c_int != 0 {
        let fresh31 = i;
        i = i + 1;
        (*pCur).ss.iStep = sqlite3_value_int64(*argv.offset(fresh31 as isize));
        if (*pCur).ss.iStep == 0 as libc::c_int as libc::c_longlong {
            (*pCur).ss.iStep = 1 as libc::c_int as sqlite3_int64;
        } else if (*pCur).ss.iStep < 0 as libc::c_int as libc::c_longlong {
            if idxNum & 16 as libc::c_int == 0 as libc::c_int {
                idxNum |= 8 as libc::c_int;
            }
        }
    } else {
        (*pCur).ss.iStep = 1 as libc::c_int as sqlite3_int64;
    }
    i = 0 as libc::c_int;
    while i < argc {
        if sqlite3_value_type(*argv.offset(i as isize)) == 5 as libc::c_int {
            (*pCur).ss.iBase = 1 as libc::c_int as sqlite3_int64;
            (*pCur).ss.iTerm = 0 as libc::c_int as sqlite3_int64;
            (*pCur).ss.iStep = 1 as libc::c_int as sqlite3_int64;
            break;
        } else {
            i += 1;
            i;
        }
    }
    if idxNum & 8 as libc::c_int != 0 {
        (*pCur)
            .ss
            .isReversing = ((*pCur).ss.iStep > 0 as libc::c_int as libc::c_longlong)
            as libc::c_int as u8_0;
    } else {
        (*pCur)
            .ss
            .isReversing = ((*pCur).ss.iStep < 0 as libc::c_int as libc::c_longlong)
            as libc::c_int as u8_0;
    }
    setupSequence(&mut (*pCur).ss);
    return 0 as libc::c_int;
}
unsafe extern "C" fn seriesBestIndex(
    pVTab: *mut sqlite3_vtab,
    pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut idxNum: libc::c_int = 0 as libc::c_int;
    let mut bStartSeen: libc::c_int = 0 as libc::c_int;
    let mut unusableMask: libc::c_int = 0 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut aIdx: [libc::c_int; 3] = [0; 3];
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    if 2 as libc::c_int == 1 as libc::c_int + 1 as libc::c_int {} else {
        __assert_fail(
            b"SERIES_COLUMN_STOP == SERIES_COLUMN_START+1\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            5279 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                .as_ptr(),
        );
    }
    'c_31193: {
        if 2 as libc::c_int == 1 as libc::c_int + 1 as libc::c_int {} else {
            __assert_fail(
                b"SERIES_COLUMN_STOP == SERIES_COLUMN_START+1\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                5279 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 58],
                    &[libc::c_char; 58],
                >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                    .as_ptr(),
            );
        }
    };
    if 3 as libc::c_int == 1 as libc::c_int + 2 as libc::c_int {} else {
        __assert_fail(
            b"SERIES_COLUMN_STEP == SERIES_COLUMN_START+2\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            5280 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                .as_ptr(),
        );
    }
    'c_31155: {
        if 3 as libc::c_int == 1 as libc::c_int + 2 as libc::c_int {} else {
            __assert_fail(
                b"SERIES_COLUMN_STEP == SERIES_COLUMN_START+2\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                5280 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 58],
                    &[libc::c_char; 58],
                >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                    .as_ptr(),
            );
        }
    };
    aIdx[2 as libc::c_int as usize] = -(1 as libc::c_int);
    aIdx[1 as libc::c_int as usize] = aIdx[2 as libc::c_int as usize];
    aIdx[0 as libc::c_int as usize] = aIdx[1 as libc::c_int as usize];
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let mut iCol: libc::c_int = 0;
        let mut iMask: libc::c_int = 0;
        if !((*pConstraint).iColumn < 1 as libc::c_int) {
            iCol = (*pConstraint).iColumn - 1 as libc::c_int;
            if iCol >= 0 as libc::c_int && iCol <= 2 as libc::c_int {} else {
                __assert_fail(
                    b"iCol>=0 && iCol<=2\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    5289 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 58],
                        &[libc::c_char; 58],
                    >(b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0"))
                        .as_ptr(),
                );
            }
            'c_31055: {
                if iCol >= 0 as libc::c_int && iCol <= 2 as libc::c_int {} else {
                    __assert_fail(
                        b"iCol>=0 && iCol<=2\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        5289 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 58],
                            &[libc::c_char; 58],
                        >(
                            b"int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            iMask = (1 as libc::c_int) << iCol;
            if iCol == 0 as libc::c_int {
                bStartSeen = 1 as libc::c_int;
            }
            if (*pConstraint).usable as libc::c_int == 0 as libc::c_int {
                unusableMask |= iMask;
            } else if (*pConstraint).op as libc::c_int == 2 as libc::c_int {
                idxNum |= iMask;
                aIdx[iCol as usize] = i;
            }
        }
        i += 1;
        i;
        pConstraint = pConstraint.offset(1);
        pConstraint;
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        j = aIdx[i as usize];
        if j >= 0 as libc::c_int {
            nArg += 1;
            (*((*pIdxInfo).aConstraintUsage).offset(j as isize)).argvIndex = nArg;
            (*((*pIdxInfo).aConstraintUsage).offset(j as isize))
                .omit = (0 as libc::c_int == 0) as libc::c_int as libc::c_uchar;
        }
        i += 1;
        i;
    }
    if bStartSeen == 0 {
        sqlite3_free((*pVTab).zErrMsg as *mut libc::c_void);
        (*pVTab)
            .zErrMsg = sqlite3_mprintf(
            b"first argument to \"generate_series()\" missing or unusable\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if unusableMask & !idxNum != 0 as libc::c_int {
        return 19 as libc::c_int;
    }
    if idxNum & 3 as libc::c_int == 3 as libc::c_int {
        (*pIdxInfo)
            .estimatedCost = (2 as libc::c_int
            - (idxNum & 4 as libc::c_int != 0 as libc::c_int) as libc::c_int)
            as libc::c_double;
        (*pIdxInfo).estimatedRows = 1000 as libc::c_int as sqlite3_int64;
        if (*pIdxInfo).nOrderBy >= 1 as libc::c_int
            && (*((*pIdxInfo).aOrderBy).offset(0 as libc::c_int as isize)).iColumn
                == 0 as libc::c_int
        {
            if (*((*pIdxInfo).aOrderBy).offset(0 as libc::c_int as isize)).desc != 0 {
                idxNum |= 8 as libc::c_int;
            } else {
                idxNum |= 16 as libc::c_int;
            }
            (*pIdxInfo).orderByConsumed = 1 as libc::c_int;
        }
    } else {
        (*pIdxInfo).estimatedRows = 2147483647 as libc::c_int as sqlite3_int64;
    }
    (*pIdxInfo).idxNum = idxNum;
    return 0 as libc::c_int;
}
static mut seriesModule: sqlite3_module = unsafe {
    {
        let init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                seriesConnect
                    as unsafe extern "C" fn(
                        *mut sqlite3,
                        *mut libc::c_void,
                        libc::c_int,
                        *const *const libc::c_char,
                        *mut *mut sqlite3_vtab,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                seriesBestIndex
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                seriesDisconnect
                    as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                seriesOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                seriesClose
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                seriesFilter
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        libc::c_int,
                        *const libc::c_char,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                seriesNext
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                seriesEof
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                seriesColumn
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite3_context,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                seriesRowid
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3_series_init(
    db: *mut sqlite3,
    pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sqlite3_libversion_number() < 3008012 as libc::c_int && !pzErrMsg.is_null() {
        *pzErrMsg = sqlite3_mprintf(
            b"generate_series() requires SQLite 3.8.12 or later\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    rc = sqlite3_create_module(
        db,
        b"generate_series\0" as *const u8 as *const libc::c_char,
        &mut seriesModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
unsafe extern "C" fn re_add_state(pSet: *mut ReStateSet, newState: libc::c_int) {
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*pSet).nState {
        if *((*pSet).aState).offset(i as isize) as libc::c_int == newState {
            return;
        }
        i = i.wrapping_add(1);
        i;
    }
    let fresh32 = (*pSet).nState;
    (*pSet).nState = ((*pSet).nState).wrapping_add(1);
    *((*pSet).aState).offset(fresh32 as isize) = newState as ReStateNumber;
}
unsafe extern "C" fn re_next_char(p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = 0;
    if (*p).i >= (*p).mx {
        return 0 as libc::c_int as libc::c_uint;
    }
    let fresh33 = (*p).i;
    (*p).i = (*p).i + 1;
    c = *((*p).z).offset(fresh33 as isize) as libc::c_uint;
    if c >= 0x80 as libc::c_int as libc::c_uint {
        if c & 0xe0 as libc::c_int as libc::c_uint == 0xc0 as libc::c_int as libc::c_uint
            && (*p).i < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
        {
            let fresh34 = (*p).i;
            (*p).i = (*p).i + 1;
            c = (c & 0x1f as libc::c_int as libc::c_uint) << 6 as libc::c_int
                | (*((*p).z).offset(fresh34 as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            if c < 0x80 as libc::c_int as libc::c_uint {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else if c & 0xf0 as libc::c_int as libc::c_uint
            == 0xe0 as libc::c_int as libc::c_uint
            && ((*p).i + 1 as libc::c_int) < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            c = (c & 0xf as libc::c_int as libc::c_uint) << 12 as libc::c_int
                | ((*((*p).z).offset((*p).i as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                | (*((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            (*p).i += 2 as libc::c_int;
            if c <= 0x7ff as libc::c_int as libc::c_uint
                || c >= 0xd800 as libc::c_int as libc::c_uint
                    && c <= 0xdfff as libc::c_int as libc::c_uint
            {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else if c & 0xf8 as libc::c_int as libc::c_uint
            == 0xf0 as libc::c_int as libc::c_uint
            && ((*p).i + 2 as libc::c_int) < (*p).mx
            && *((*p).z).offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
            && *((*p).z).offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            c = (c & 0x7 as libc::c_int as libc::c_uint) << 18 as libc::c_int
                | ((*((*p).z).offset((*p).i as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 12 as libc::c_int) as libc::c_uint
                | ((*((*p).z).offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) << 6 as libc::c_int) as libc::c_uint
                | (*((*p).z).offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                    & 0x3f as libc::c_int) as libc::c_uint;
            (*p).i += 3 as libc::c_int;
            if c <= 0xffff as libc::c_int as libc::c_uint
                || c > 0x10ffff as libc::c_int as libc::c_uint
            {
                c = 0xfffd as libc::c_int as libc::c_uint;
            }
        } else {
            c = 0xfffd as libc::c_int as libc::c_uint;
        }
    }
    return c;
}
unsafe extern "C" fn re_next_char_nocase(p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = re_next_char(p);
    if c >= 'A' as i32 as libc::c_uint && c <= 'Z' as i32 as libc::c_uint {
        c = c.wrapping_add(('a' as i32 - 'A' as i32) as libc::c_uint);
    }
    return c;
}
unsafe extern "C" fn re_word_char(c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32 || c >= 'a' as i32 && c <= 'z' as i32
        || c >= 'A' as i32 && c <= 'Z' as i32 || c == '_' as i32) as libc::c_int;
}
unsafe extern "C" fn re_digit_char(c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
unsafe extern "C" fn re_space_char(c: libc::c_int) -> libc::c_int {
    return (c == ' ' as i32 || c == '\t' as i32 || c == '\n' as i32 || c == '\r' as i32
        || c == '\u{b}' as i32 || c == '\u{c}' as i32) as libc::c_int;
}
unsafe extern "C" fn sqlite3re_match(
    pRe: *mut ReCompiled,
    zIn: *const libc::c_uchar,
    nIn: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut aStateSet: [ReStateSet; 2] = [ReStateSet {
        nState: 0,
        aState: 0 as *mut ReStateNumber,
    }; 2];
    let mut pThis: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut pNext: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut aSpace: [ReStateNumber; 100] = [0; 100];
    let mut pToFree: *mut ReStateNumber = 0 as *mut ReStateNumber;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut iSwap: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut c: libc::c_int = 0xfffffff as libc::c_int;
    let mut cPrev: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut in_0: ReInput = ReInput {
        z: 0 as *const libc::c_uchar,
        i: 0,
        mx: 0,
    };
    in_0.z = zIn;
    in_0.i = 0 as libc::c_int;
    in_0
        .mx = if nIn >= 0 as libc::c_int {
        nIn
    } else {
        strlen(zIn as *const libc::c_char) as libc::c_int
    };
    if (*pRe).nInit != 0 {
        let x: libc::c_uchar = (*pRe).zInit[0 as libc::c_int as usize];
        while in_0.i + (*pRe).nInit <= in_0.mx
            && (*zIn.offset(in_0.i as isize) as libc::c_int != x as libc::c_int
                || strncmp(
                    (zIn as *const libc::c_char).offset(in_0.i as isize),
                    ((*pRe).zInit).as_mut_ptr() as *const libc::c_char,
                    (*pRe).nInit as libc::c_ulong,
                ) != 0 as libc::c_int)
        {
            in_0.i += 1;
            in_0.i;
        }
        if in_0.i + (*pRe).nInit > in_0.mx {
            return 0 as libc::c_int;
        }
        c = 0xfffffff as libc::c_int - 1 as libc::c_int;
    }
    if (*pRe).nState as libc::c_ulong
        <= (::core::mem::size_of::<[ReStateNumber; 100]>() as libc::c_ulong)
            .wrapping_div(
                (::core::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                    .wrapping_mul(2 as libc::c_int as libc::c_ulong),
            )
    {
        pToFree = 0 as *mut ReStateNumber;
        aStateSet[0 as libc::c_int as usize].aState = aSpace.as_mut_ptr();
    } else {
        pToFree = sqlite3_malloc64(
            (::core::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                .wrapping_mul((*pRe).nState as libc::c_ulong) as sqlite3_uint64,
        ) as *mut ReStateNumber;
        if pToFree.is_null() {
            return -(1 as libc::c_int);
        }
        aStateSet[0 as libc::c_int as usize].aState = pToFree;
    }
    aStateSet[1 as libc::c_int as usize]
        .aState = &mut *((*aStateSet.as_mut_ptr().offset(0 as libc::c_int as isize))
        .aState)
        .offset((*pRe).nState as isize) as *mut ReStateNumber;
    pNext = &mut *aStateSet.as_mut_ptr().offset(1 as libc::c_int as isize)
        as *mut ReStateSet;
    (*pNext).nState = 0 as libc::c_int as libc::c_uint;
    re_add_state(pNext, 0 as libc::c_int);
    's_107: loop {
        if !(c != 0 as libc::c_int && (*pNext).nState > 0 as libc::c_int as libc::c_uint)
        {
            current_block = 15855550149339537395;
            break;
        }
        cPrev = c;
        c = ((*pRe).xNextChar).expect("non-null function pointer")(&mut in_0)
            as libc::c_int;
        pThis = pNext;
        pNext = &mut *aStateSet.as_mut_ptr().offset(iSwap as isize) as *mut ReStateSet;
        iSwap = (1 as libc::c_int as libc::c_uint).wrapping_sub(iSwap);
        (*pNext).nState = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*pThis).nState {
            let x_0: libc::c_int = *((*pThis).aState).offset(i as isize)
                as libc::c_int;
            match *((*pRe).aOp).offset(x_0 as isize) as libc::c_int {
                1 => {
                    if *((*pRe).aArg).offset(x_0 as isize) == c {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                18 => {
                    if cPrev == 0xfffffff as libc::c_int {
                        re_add_state(pThis, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                2 => {
                    if c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                11 => {
                    if re_word_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                12 => {
                    if re_word_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                13 => {
                    if re_digit_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                14 => {
                    if re_digit_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                15 => {
                    if re_space_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                16 => {
                    if re_space_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                17 => {
                    if re_word_char(c) != re_word_char(cPrev) {
                        re_add_state(pThis, x_0 + 1 as libc::c_int);
                    }
                    current_block = 2232869372362427478;
                }
                3 => {
                    re_add_state(pNext, x_0);
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 2232869372362427478;
                }
                4 => {
                    re_add_state(pThis, x_0 + *((*pRe).aArg).offset(x_0 as isize));
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 2232869372362427478;
                }
                5 => {
                    re_add_state(pThis, x_0 + *((*pRe).aArg).offset(x_0 as isize));
                    current_block = 2232869372362427478;
                }
                6 => {
                    rc = 1 as libc::c_int;
                    current_block = 4073145804989849319;
                    break 's_107;
                }
                8 => {
                    if c == 0 as libc::c_int {
                        current_block = 2232869372362427478;
                    } else {
                        current_block = 3580086814630675314;
                    }
                }
                7 => {
                    current_block = 3580086814630675314;
                }
                _ => {
                    current_block = 2232869372362427478;
                }
            }
            match current_block {
                3580086814630675314 => {
                    let mut j: libc::c_int = 1 as libc::c_int;
                    let n: libc::c_int = *((*pRe).aArg).offset(x_0 as isize);
                    let mut hit: libc::c_int = 0 as libc::c_int;
                    j = 1 as libc::c_int;
                    while j > 0 as libc::c_int && j < n {
                        if *((*pRe).aOp).offset((x_0 + j) as isize) as libc::c_int
                            == 9 as libc::c_int
                        {
                            if *((*pRe).aArg).offset((x_0 + j) as isize) == c {
                                hit = 1 as libc::c_int;
                                j = -(1 as libc::c_int);
                            }
                        } else if *((*pRe).aArg).offset((x_0 + j) as isize) <= c
                            && *((*pRe).aArg)
                                .offset((x_0 + j + 1 as libc::c_int) as isize) >= c
                        {
                            hit = 1 as libc::c_int;
                            j = -(1 as libc::c_int);
                        } else {
                            j += 1;
                            j;
                        }
                        j += 1;
                        j;
                    }
                    if *((*pRe).aOp).offset(x_0 as isize) as libc::c_int
                        == 8 as libc::c_int
                    {
                        hit = (hit == 0) as libc::c_int;
                    }
                    if hit != 0 {
                        re_add_state(pNext, x_0 + n);
                    }
                }
                _ => {}
            }
            i = i.wrapping_add(1);
            i;
        }
    }
    match current_block {
        15855550149339537395 => {
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*pNext).nState {
                let mut x_1: libc::c_int = *((*pNext).aState).offset(i as isize)
                    as libc::c_int;
                while *((*pRe).aOp).offset(x_1 as isize) as libc::c_int
                    == 5 as libc::c_int
                {
                    x_1 += *((*pRe).aArg).offset(x_1 as isize);
                }
                if *((*pRe).aOp).offset(x_1 as isize) as libc::c_int == 6 as libc::c_int
                {
                    rc = 1 as libc::c_int;
                    break;
                } else {
                    i = i.wrapping_add(1);
                    i;
                }
            }
        }
        _ => {}
    }
    sqlite3_free(pToFree as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn re_resize(
    p: *mut ReCompiled,
    N: libc::c_int,
) -> libc::c_int {
    let mut aOp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aArg: *mut libc::c_int = 0 as *mut libc::c_int;
    aOp = sqlite3_realloc64(
        (*p).aOp as *mut libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_char;
    if aOp.is_null() {
        return 1 as libc::c_int;
    }
    (*p).aOp = aOp;
    aArg = sqlite3_realloc64(
        (*p).aArg as *mut libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_int;
    if aArg.is_null() {
        return 1 as libc::c_int;
    }
    (*p).aArg = aArg;
    (*p).nAlloc = N as libc::c_uint;
    return 0 as libc::c_int;
}
unsafe extern "C" fn re_insert(
    p: *mut ReCompiled,
    iBefore: libc::c_int,
    op: libc::c_int,
    arg: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if (*p).nAlloc <= (*p).nState
        && re_resize(
            p,
            ((*p).nAlloc).wrapping_mul(2 as libc::c_int as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return 0 as libc::c_int;
    }
    i = (*p).nState as libc::c_int;
    while i > iBefore {
        *((*p).aOp)
            .offset(i as isize) = *((*p).aOp).offset((i - 1 as libc::c_int) as isize);
        *((*p).aArg)
            .offset(i as isize) = *((*p).aArg).offset((i - 1 as libc::c_int) as isize);
        i -= 1;
        i;
    }
    (*p).nState = ((*p).nState).wrapping_add(1);
    (*p).nState;
    *((*p).aOp).offset(iBefore as isize) = op as libc::c_char;
    *((*p).aArg).offset(iBefore as isize) = arg;
    return iBefore;
}
unsafe extern "C" fn re_append(
    p: *mut ReCompiled,
    op: libc::c_int,
    arg: libc::c_int,
) -> libc::c_int {
    return re_insert(p, (*p).nState as libc::c_int, op, arg);
}
unsafe extern "C" fn re_copy(
    p: *mut ReCompiled,
    iStart: libc::c_int,
    N: libc::c_int,
) {
    if ((*p).nState).wrapping_add(N as libc::c_uint) >= (*p).nAlloc
        && re_resize(
            p,
            ((*p).nAlloc)
                .wrapping_mul(2 as libc::c_int as libc::c_uint)
                .wrapping_add(N as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return;
    }
    memcpy(
        &mut *((*p).aOp).offset((*p).nState as isize) as *mut libc::c_char
            as *mut libc::c_void,
        &mut *((*p).aOp).offset(iStart as isize) as *mut libc::c_char
            as *const libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_char>() as libc::c_ulong),
    );
    memcpy(
        &mut *((*p).aArg).offset((*p).nState as isize) as *mut libc::c_int
            as *mut libc::c_void,
        &mut *((*p).aArg).offset(iStart as isize) as *mut libc::c_int
            as *const libc::c_void,
        (N as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    (*p).nState = ((*p).nState).wrapping_add(N as libc::c_uint);
}
unsafe extern "C" fn re_hex(
    mut c: libc::c_int,
    pV: *mut libc::c_int,
) -> libc::c_int {
    if c >= '0' as i32 && c <= '9' as i32 {
        c -= '0' as i32;
    } else if c >= 'a' as i32 && c <= 'f' as i32 {
        c -= 'a' as i32 - 10 as libc::c_int;
    } else if c >= 'A' as i32 && c <= 'F' as i32 {
        c -= 'A' as i32 - 10 as libc::c_int;
    } else {
        return 0 as libc::c_int
    }
    *pV = *pV * 16 as libc::c_int + (c & 0xff as libc::c_int);
    return 1 as libc::c_int;
}
unsafe extern "C" fn re_esc_char(p: *mut ReCompiled) -> libc::c_uint {
    static mut zEsc: [libc::c_char; 21] = unsafe {
        *::core::mem::transmute::<
            &[u8; 21],
            &[libc::c_char; 21],
        >(b"afnrtv\\()*.+?[$^{|}]\0")
    };
    static mut zTrans: [libc::c_char; 7] = unsafe {
        *::core::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"\x07\x0C\n\r\t\x0B\0")
    };
    let mut i: libc::c_int = 0;
    let mut v: libc::c_int = 0 as libc::c_int;
    let mut c: libc::c_char = 0;
    if (*p).sIn.i >= (*p).sIn.mx {
        return 0 as libc::c_int as libc::c_uint;
    }
    c = *((*p).sIn.z).offset((*p).sIn.i as isize) as libc::c_char;
    if c as libc::c_int == 'u' as i32 && ((*p).sIn.i + 4 as libc::c_int) < (*p).sIn.mx {
        let zIn: *const libc::c_uchar = ((*p).sIn.z).offset((*p).sIn.i as isize);
        if re_hex(*zIn.offset(1 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(2 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(3 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn.offset(4 as libc::c_int as isize) as libc::c_int, &mut v) != 0
        {
            (*p).sIn.i += 5 as libc::c_int;
            return v as libc::c_uint;
        }
    }
    if c as libc::c_int == 'x' as i32 && ((*p).sIn.i + 2 as libc::c_int) < (*p).sIn.mx {
        let zIn_0: *const libc::c_uchar = ((*p).sIn.z).offset((*p).sIn.i as isize);
        if re_hex(*zIn_0.offset(1 as libc::c_int as isize) as libc::c_int, &mut v) != 0
            && re_hex(*zIn_0.offset(2 as libc::c_int as isize) as libc::c_int, &mut v)
                != 0
        {
            (*p).sIn.i += 3 as libc::c_int;
            return v as libc::c_uint;
        }
    }
    i = 0 as libc::c_int;
    while zEsc[i as usize] as libc::c_int != 0
        && zEsc[i as usize] as libc::c_int != c as libc::c_int
    {
        i += 1;
        i;
    }
    if zEsc[i as usize] != 0 {
        if i < 6 as libc::c_int {
            c = zTrans[i as usize];
        }
        (*p).sIn.i += 1;
        (*p).sIn.i;
    } else {
        (*p).zErr = b"unknown \\ escape\0" as *const u8 as *const libc::c_char;
    }
    return c as libc::c_uint;
}
unsafe extern "C" fn rePeek(p: *mut ReCompiled) -> libc::c_uchar {
    return (if (*p).sIn.i < (*p).sIn.mx {
        *((*p).sIn.z).offset((*p).sIn.i as isize) as libc::c_int
    } else {
        0 as libc::c_int
    }) as libc::c_uchar;
}
unsafe extern "C" fn re_subcompile_re(p: *mut ReCompiled) -> *const libc::c_char {
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut iStart: libc::c_int = 0;
    let mut iEnd: libc::c_int = 0;
    let mut iGoto: libc::c_int = 0;
    iStart = (*p).nState as libc::c_int;
    zErr = re_subcompile_string(p);
    if !zErr.is_null() {
        return zErr;
    }
    while rePeek(p) as libc::c_int == '|' as i32 {
        iEnd = (*p).nState as libc::c_int;
        re_insert(p, iStart, 4 as libc::c_int, iEnd + 2 as libc::c_int - iStart);
        iGoto = re_append(p, 5 as libc::c_int, 0 as libc::c_int);
        (*p).sIn.i += 1;
        (*p).sIn.i;
        zErr = re_subcompile_string(p);
        if !zErr.is_null() {
            return zErr;
        }
        *((*p).aArg)
            .offset(
                iGoto as isize,
            ) = ((*p).nState).wrapping_sub(iGoto as libc::c_uint) as libc::c_int;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn re_subcompile_string(
    p: *mut ReCompiled,
) -> *const libc::c_char {
    let mut iPrev: libc::c_int = -(1 as libc::c_int);
    let mut iStart: libc::c_int = 0;
    let mut c: libc::c_uint = 0;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        c = ((*p).xNextChar).expect("non-null function pointer")(&mut (*p).sIn);
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        iStart = (*p).nState as libc::c_int;
        match c {
            124 | 41 => {
                (*p).sIn.i -= 1;
                (*p).sIn.i;
                return 0 as *const libc::c_char;
            }
            40 => {
                zErr = re_subcompile_re(p);
                if !zErr.is_null() {
                    return zErr;
                }
                if rePeek(p) as libc::c_int != ')' as i32 {
                    return b"unmatched '('\0" as *const u8 as *const libc::c_char;
                }
                (*p).sIn.i += 1;
                (*p).sIn.i;
            }
            46 => {
                if rePeek(p) as libc::c_int == '*' as i32 {
                    re_append(p, 3 as libc::c_int, 0 as libc::c_int);
                    (*p).sIn.i += 1;
                    (*p).sIn.i;
                } else {
                    re_append(p, 2 as libc::c_int, 0 as libc::c_int);
                }
            }
            42 => {
                if iPrev < 0 as libc::c_int {
                    return b"'*' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_insert(
                    p,
                    iPrev,
                    5 as libc::c_int,
                    ((*p).nState)
                        .wrapping_sub(iPrev as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
                re_append(
                    p,
                    4 as libc::c_int,
                    (iPrev as libc::c_uint)
                        .wrapping_sub((*p).nState)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
            }
            43 => {
                if iPrev < 0 as libc::c_int {
                    return b"'+' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_append(
                    p,
                    4 as libc::c_int,
                    (iPrev as libc::c_uint).wrapping_sub((*p).nState) as libc::c_int,
                );
            }
            63 => {
                if iPrev < 0 as libc::c_int {
                    return b"'?' without operand\0" as *const u8 as *const libc::c_char;
                }
                re_insert(
                    p,
                    iPrev,
                    4 as libc::c_int,
                    ((*p).nState)
                        .wrapping_sub(iPrev as libc::c_uint)
                        .wrapping_add(1 as libc::c_int as libc::c_uint) as libc::c_int,
                );
            }
            36 => {
                re_append(p, 1 as libc::c_int, 0 as libc::c_int);
            }
            94 => {
                re_append(p, 18 as libc::c_int, 0 as libc::c_int);
            }
            123 => {
                let mut m: libc::c_int = 0 as libc::c_int;
                let mut n: libc::c_int = 0 as libc::c_int;
                let mut sz: libc::c_int = 0;
                let mut j: libc::c_int = 0;
                if iPrev < 0 as libc::c_int {
                    return b"'{m,n}' without operand\0" as *const u8
                        as *const libc::c_char;
                }
                loop {
                    c = rePeek(p) as libc::c_uint;
                    if !(c >= '0' as i32 as libc::c_uint
                        && c <= '9' as i32 as libc::c_uint)
                    {
                        break;
                    }
                    m = ((m * 10 as libc::c_int) as libc::c_uint)
                        .wrapping_add(c)
                        .wrapping_sub('0' as i32 as libc::c_uint) as libc::c_int;
                    (*p).sIn.i += 1;
                    (*p).sIn.i;
                }
                n = m;
                if c == ',' as i32 as libc::c_uint {
                    (*p).sIn.i += 1;
                    (*p).sIn.i;
                    n = 0 as libc::c_int;
                    loop {
                        c = rePeek(p) as libc::c_uint;
                        if !(c >= '0' as i32 as libc::c_uint
                            && c <= '9' as i32 as libc::c_uint)
                        {
                            break;
                        }
                        n = ((n * 10 as libc::c_int) as libc::c_uint)
                            .wrapping_add(c)
                            .wrapping_sub('0' as i32 as libc::c_uint) as libc::c_int;
                        (*p).sIn.i += 1;
                        (*p).sIn.i;
                    }
                }
                if c != '}' as i32 as libc::c_uint {
                    return b"unmatched '{'\0" as *const u8 as *const libc::c_char;
                }
                if n > 0 as libc::c_int && n < m {
                    return b"n less than m in '{m,n}'\0" as *const u8
                        as *const libc::c_char;
                }
                (*p).sIn.i += 1;
                (*p).sIn.i;
                sz = ((*p).nState).wrapping_sub(iPrev as libc::c_uint) as libc::c_int;
                if m == 0 as libc::c_int {
                    if n == 0 as libc::c_int {
                        return b"both m and n are zero in '{m,n}'\0" as *const u8
                            as *const libc::c_char;
                    }
                    re_insert(p, iPrev, 4 as libc::c_int, sz + 1 as libc::c_int);
                    iPrev += 1;
                    iPrev;
                    n -= 1;
                    n;
                } else {
                    j = 1 as libc::c_int;
                    while j < m {
                        re_copy(p, iPrev, sz);
                        j += 1;
                        j;
                    }
                }
                j = m;
                while j < n {
                    re_append(p, 4 as libc::c_int, sz + 1 as libc::c_int);
                    re_copy(p, iPrev, sz);
                    j += 1;
                    j;
                }
                if n == 0 as libc::c_int && m > 0 as libc::c_int {
                    re_append(p, 4 as libc::c_int, -sz);
                }
            }
            91 => {
                let iFirst: libc::c_uint = (*p).nState;
                if rePeek(p) as libc::c_int == '^' as i32 {
                    re_append(p, 8 as libc::c_int, 0 as libc::c_int);
                    (*p).sIn.i += 1;
                    (*p).sIn.i;
                } else {
                    re_append(p, 7 as libc::c_int, 0 as libc::c_int);
                }
                loop {
                    c = ((*p).xNextChar)
                        .expect("non-null function pointer")(&mut (*p).sIn);
                    if !(c != 0 as libc::c_int as libc::c_uint) {
                        break;
                    }
                    if c == '[' as i32 as libc::c_uint
                        && rePeek(p) as libc::c_int == ':' as i32
                    {
                        return b"POSIX character classes not supported\0" as *const u8
                            as *const libc::c_char;
                    }
                    if c == '\\' as i32 as libc::c_uint {
                        c = re_esc_char(p);
                    }
                    if rePeek(p) as libc::c_int == '-' as i32 {
                        re_append(p, 10 as libc::c_int, c as libc::c_int);
                        (*p).sIn.i += 1;
                        (*p).sIn.i;
                        c = ((*p).xNextChar)
                            .expect("non-null function pointer")(&mut (*p).sIn);
                        if c == '\\' as i32 as libc::c_uint {
                            c = re_esc_char(p);
                        }
                        re_append(p, 10 as libc::c_int, c as libc::c_int);
                    } else {
                        re_append(p, 9 as libc::c_int, c as libc::c_int);
                    }
                    if !(rePeek(p) as libc::c_int == ']' as i32) {
                        continue;
                    }
                    (*p).sIn.i += 1;
                    (*p).sIn.i;
                    break;
                }
                if c == 0 as libc::c_int as libc::c_uint {
                    return b"unclosed '['\0" as *const u8 as *const libc::c_char;
                }
                if (*p).nState > iFirst {
                    *((*p).aArg)
                        .offset(
                            iFirst as isize,
                        ) = ((*p).nState).wrapping_sub(iFirst) as libc::c_int;
                }
            }
            92 => {
                let mut specialOp: libc::c_int = 0 as libc::c_int;
                match rePeek(p) as libc::c_int {
                    98 => {
                        specialOp = 17 as libc::c_int;
                    }
                    100 => {
                        specialOp = 13 as libc::c_int;
                    }
                    68 => {
                        specialOp = 14 as libc::c_int;
                    }
                    115 => {
                        specialOp = 15 as libc::c_int;
                    }
                    83 => {
                        specialOp = 16 as libc::c_int;
                    }
                    119 => {
                        specialOp = 11 as libc::c_int;
                    }
                    87 => {
                        specialOp = 12 as libc::c_int;
                    }
                    _ => {}
                }
                if specialOp != 0 {
                    (*p).sIn.i += 1;
                    (*p).sIn.i;
                    re_append(p, specialOp, 0 as libc::c_int);
                } else {
                    c = re_esc_char(p);
                    re_append(p, 1 as libc::c_int, c as libc::c_int);
                }
            }
            _ => {
                re_append(p, 1 as libc::c_int, c as libc::c_int);
            }
        }
        iPrev = iStart;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn sqlite3re_free(pRe: *mut ReCompiled) {
    if !pRe.is_null() {
        sqlite3_free((*pRe).aOp as *mut libc::c_void);
        sqlite3_free((*pRe).aArg as *mut libc::c_void);
        sqlite3_free(pRe as *mut libc::c_void);
    }
}
unsafe extern "C" fn sqlite3re_compile(
    ppRe: *mut *mut ReCompiled,
    mut zIn: *const libc::c_char,
    noCase: libc::c_int,
) -> *const libc::c_char {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    *ppRe = 0 as *mut ReCompiled;
    pRe = sqlite3_malloc(
        ::core::mem::size_of::<ReCompiled>() as libc::c_ulong as libc::c_int,
    ) as *mut ReCompiled;
    if pRe.is_null() {
        return b"out of memory\0" as *const u8 as *const libc::c_char;
    }
    memset(
        pRe as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ReCompiled>() as libc::c_ulong,
    );
    (*pRe)
        .xNextChar = if noCase != 0 {
        Some(re_next_char_nocase as unsafe extern "C" fn(*mut ReInput) -> libc::c_uint)
    } else {
        Some(re_next_char as unsafe extern "C" fn(*mut ReInput) -> libc::c_uint)
    };
    if re_resize(pRe, 30 as libc::c_int) != 0 {
        sqlite3re_free(pRe);
        return b"out of memory\0" as *const u8 as *const libc::c_char;
    }
    if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '^' as i32 {
        zIn = zIn.offset(1);
        zIn;
    } else {
        re_append(pRe, 3 as libc::c_int, 0 as libc::c_int);
    }
    (*pRe).sIn.z = zIn as *mut libc::c_uchar;
    (*pRe).sIn.i = 0 as libc::c_int;
    (*pRe).sIn.mx = strlen(zIn) as libc::c_int;
    zErr = re_subcompile_re(pRe);
    if !zErr.is_null() {
        sqlite3re_free(pRe);
        return zErr;
    }
    if (*pRe).sIn.i >= (*pRe).sIn.mx {
        re_append(pRe, 6 as libc::c_int, 0 as libc::c_int);
        *ppRe = pRe;
    } else {
        sqlite3re_free(pRe);
        return b"unrecognized character\0" as *const u8 as *const libc::c_char;
    }
    if *((*pRe).aOp).offset(0 as libc::c_int as isize) as libc::c_int == 3 as libc::c_int
        && noCase == 0
    {
        j = 0 as libc::c_int;
        i = 1 as libc::c_int;
        while j
            < ::core::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong
                as libc::c_int - 2 as libc::c_int
            && *((*pRe).aOp).offset(i as isize) as libc::c_int == 1 as libc::c_int
        {
            let x: libc::c_uint = *((*pRe).aArg).offset(i as isize) as libc::c_uint;
            if x <= 0x7f as libc::c_int as libc::c_uint {
                let fresh35 = j;
                j = j + 1;
                (*pRe).zInit[fresh35 as usize] = x as libc::c_uchar;
            } else if x <= 0x7ff as libc::c_int as libc::c_uint {
                let fresh36 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh36
                    as usize] = (0xc0 as libc::c_int as libc::c_uint
                    | x >> 6 as libc::c_int) as libc::c_uchar;
                let fresh37 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh37
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x & 0x3f as libc::c_int as libc::c_uint) as libc::c_uchar;
            } else {
                if !(x <= 0xffff as libc::c_int as libc::c_uint) {
                    break;
                }
                let fresh38 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh38
                    as usize] = (0xe0 as libc::c_int as libc::c_uint
                    | x >> 12 as libc::c_int) as libc::c_uchar;
                let fresh39 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh39
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                    as libc::c_uchar;
                let fresh40 = j;
                j = j + 1;
                (*pRe)
                    .zInit[fresh40
                    as usize] = (0x80 as libc::c_int as libc::c_uint
                    | x & 0x3f as libc::c_int as libc::c_uint) as libc::c_uchar;
            }
            i += 1;
            i;
        }
        if j > 0 as libc::c_int
            && (*pRe).zInit[(j - 1 as libc::c_int) as usize] as libc::c_int
                == 0 as libc::c_int
        {
            j -= 1;
            j;
        }
        (*pRe).nInit = j;
    }
    return (*pRe).zErr;
}
unsafe extern "C" fn re_sql_func(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zPattern: *const libc::c_char = 0 as *const libc::c_char;
    let mut zStr: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut setAux: libc::c_int = 0 as libc::c_int;
    pRe = sqlite3_get_auxdata(context, 0 as libc::c_int) as *mut ReCompiled;
    if pRe.is_null() {
        zPattern = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
            as *const libc::c_char;
        if zPattern.is_null() {
            return;
        }
        zErr = sqlite3re_compile(
            &mut pRe,
            zPattern,
            (sqlite3_user_data(context) != 0 as *mut libc::c_void) as libc::c_int,
        );
        if !zErr.is_null() {
            sqlite3re_free(pRe);
            sqlite3_result_error(context, zErr, -(1 as libc::c_int));
            return;
        }
        if pRe.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        }
        setAux = 1 as libc::c_int;
    }
    zStr = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize));
    if !zStr.is_null() {
        sqlite3_result_int(context, sqlite3re_match(pRe, zStr, -(1 as libc::c_int)));
    }
    if setAux != 0 {
        sqlite3_set_auxdata(
            context,
            0 as libc::c_int,
            pRe as *mut libc::c_void,
            ::core::mem::transmute::<
                Option::<unsafe extern "C" fn(*mut ReCompiled) -> ()>,
                Option::<unsafe extern "C" fn(*mut libc::c_void) -> ()>,
            >(Some(sqlite3re_free as unsafe extern "C" fn(*mut ReCompiled) -> ())),
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_regexp_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"regexp\0" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            re_sql_func
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"regexpi\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            db as *mut libc::c_void,
            Some(
                re_sql_func
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn readFileContents(
    ctx: *mut sqlite3_context,
    zName: *const libc::c_char,
) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut nIn: sqlite3_int64 = 0;
    let mut pBuf: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut mxBlob: libc::c_int = 0;
    in_0 = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        return;
    }
    fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
    nIn = ftell(in_0) as sqlite3_int64;
    rewind(in_0);
    db = sqlite3_context_db_handle(ctx);
    mxBlob = sqlite3_limit(db, 0 as libc::c_int, -(1 as libc::c_int));
    if nIn > mxBlob as libc::c_longlong {
        sqlite3_result_error_code(ctx, 18 as libc::c_int);
        fclose(in_0);
        return;
    }
    pBuf = sqlite3_malloc64(
        (if nIn != 0 { nIn } else { 1 as libc::c_int as libc::c_longlong })
            as sqlite3_uint64,
    );
    if pBuf.is_null() {
        sqlite3_result_error_nomem(ctx);
        fclose(in_0);
        return;
    }
    if nIn
        == fread(pBuf, 1 as libc::c_int as libc::c_ulong, nIn as size_t, in_0)
            as sqlite3_int64
    {
        sqlite3_result_blob64(
            ctx,
            pBuf,
            nIn as sqlite3_uint64,
            Some(sqlite3_free as unsafe extern "C" fn(*mut libc::c_void) -> ()),
        );
    } else {
        sqlite3_result_error_code(ctx, 10 as libc::c_int);
        sqlite3_free(pBuf);
    }
    fclose(in_0);
}
unsafe extern "C" fn readfileFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    zName = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zName.is_null() {
        return;
    }
    readFileContents(context, zName);
}
unsafe extern "C" fn ctxErrorMsg(
    ctx: *mut sqlite3_context,
    zFmt: *const libc::c_char,
    args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
unsafe extern "C" fn fileStat(
    zPath: *const libc::c_char,
    pStatBuf: *mut stat,
) -> libc::c_int {
    return stat(zPath, pStatBuf);
}
unsafe extern "C" fn fileLinkStat(
    zPath: *const libc::c_char,
    pStatBuf: *mut stat,
) -> libc::c_int {
    return lstat(zPath, pStatBuf);
}
unsafe extern "C" fn makeDirectory(zFile: *const libc::c_char) -> libc::c_int {
    let zCopy: *mut libc::c_char = sqlite3_mprintf(
        b"%s\0" as *const u8 as *const libc::c_char,
        zFile,
    );
    let mut rc: libc::c_int = 0 as libc::c_int;
    if zCopy.is_null() {
        rc = 7 as libc::c_int;
    } else {
        let nCopy: libc::c_int = strlen(zCopy) as libc::c_int;
        let mut i: libc::c_int = 1 as libc::c_int;
        while rc == 0 as libc::c_int {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
                __glibc_reserved: [0; 3],
            };
            let mut rc2: libc::c_int = 0;
            while *zCopy.offset(i as isize) as libc::c_int != '/' as i32 && i < nCopy {
                i += 1;
                i;
            }
            if i == nCopy {
                break;
            }
            *zCopy.offset(i as isize) = '\0' as i32 as libc::c_char;
            rc2 = fileStat(zCopy, &mut sStat);
            if rc2 != 0 as libc::c_int {
                if mkdir(zCopy, 0o777 as libc::c_int as __mode_t) != 0 {
                    rc = 1 as libc::c_int;
                }
            } else if !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint)
            {
                rc = 1 as libc::c_int;
            }
            *zCopy.offset(i as isize) = '/' as i32 as libc::c_char;
            i += 1;
            i;
        }
        sqlite3_free(zCopy as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn writeFile(
    pCtx: *mut sqlite3_context,
    zFile: *const libc::c_char,
    pData: *mut sqlite3_value,
    mode: mode_t,
    mtime: sqlite3_int64,
) -> libc::c_int {
    if zFile.is_null() {
        return 1 as libc::c_int;
    }
    if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o120000 as libc::c_int as libc::c_uint
    {
        let zTo: *const libc::c_char = sqlite3_value_text(pData)
            as *const libc::c_char;
        if zTo.is_null() || symlink(zTo, zFile) < 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    } else if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        if mkdir(zFile, mode) != 0 {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_mtim: timespec { tv_sec: 0, tv_nsec: 0 },
                st_ctim: timespec { tv_sec: 0, tv_nsec: 0 },
                __glibc_reserved: [0; 3],
            };
            if *__errno_location() != 17 as libc::c_int
                || 0 as libc::c_int != fileStat(zFile, &mut sStat)
                || !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint)
                || sStat.st_mode & 0o777 as libc::c_int as libc::c_uint
                    != mode & 0o777 as libc::c_int as libc::c_uint
                    && 0 as libc::c_int
                        != chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint)
            {
                return 1 as libc::c_int;
            }
        }
    } else {
        let mut nWrite: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut z: *const libc::c_char = 0 as *const libc::c_char;
        let mut rc: libc::c_int = 0 as libc::c_int;
        let out: *mut FILE = fopen(
            zFile,
            b"wb\0" as *const u8 as *const libc::c_char,
        );
        if out.is_null() {
            return 1 as libc::c_int;
        }
        z = sqlite3_value_blob(pData) as *const libc::c_char;
        if !z.is_null() {
            let n: sqlite3_int64 = fwrite(
                z as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                sqlite3_value_bytes(pData) as libc::c_ulong,
                out,
            ) as sqlite3_int64;
            nWrite = sqlite3_value_bytes(pData) as sqlite3_int64;
            if nWrite != n {
                rc = 1 as libc::c_int;
            }
        }
        fclose(out);
        if rc == 0 as libc::c_int && mode != 0
            && chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint) != 0
        {
            rc = 1 as libc::c_int;
        }
        if rc != 0 {
            return 2 as libc::c_int;
        }
        sqlite3_result_int64(pCtx, nWrite);
    }
    if mtime >= 0 as libc::c_int as libc::c_longlong {
        let mut times: [timeval; 2] = [timeval { tv_sec: 0, tv_usec: 0 }; 2];
        times[1 as libc::c_int as usize].tv_usec = 0 as libc::c_int as __suseconds_t;
        times[0 as libc::c_int as usize]
            .tv_usec = times[1 as libc::c_int as usize].tv_usec;
        times[0 as libc::c_int as usize].tv_sec = time(0 as *mut time_t);
        times[1 as libc::c_int as usize].tv_sec = mtime as __time_t;
        if utimes(zFile, times.as_mut_ptr() as *const timeval) != 0 {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn writefileFunc(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut mode: mode_t = 0 as libc::c_int as mode_t;
    let mut res: libc::c_int = 0;
    let mut mtime: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    if argc < 2 as libc::c_int || argc > 4 as libc::c_int {
        sqlite3_result_error(
            context,
            b"wrong number of arguments to function writefile()\0" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zFile.is_null() {
        return;
    }
    if argc >= 3 as libc::c_int {
        mode = sqlite3_value_int(*argv.offset(2 as libc::c_int as isize)) as mode_t;
    }
    if argc == 4 as libc::c_int {
        mtime = sqlite3_value_int64(*argv.offset(3 as libc::c_int as isize));
    }
    res = writeFile(
        context,
        zFile,
        *argv.offset(1 as libc::c_int as isize),
        mode,
        mtime,
    );
    if res == 1 as libc::c_int && *__errno_location() == 2 as libc::c_int {
        if makeDirectory(zFile) == 0 as libc::c_int {
            res = writeFile(
                context,
                zFile,
                *argv.offset(1 as libc::c_int as isize),
                mode,
                mtime,
            );
        }
    }
    if argc > 2 as libc::c_int && res != 0 as libc::c_int {
        if mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o120000 as libc::c_int as libc::c_uint
        {
            ctxErrorMsg(
                context,
                b"failed to create symlink: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        } else if mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o40000 as libc::c_int as libc::c_uint
        {
            ctxErrorMsg(
                context,
                b"failed to create directory: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        } else {
            ctxErrorMsg(
                context,
                b"failed to write file: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
}
unsafe extern "C" fn lsModeFunc(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut i: libc::c_int = 0;
    let iMode: libc::c_int = sqlite3_value_int(
        *argv.offset(0 as libc::c_int as isize),
    );
    let mut z: [libc::c_char; 16] = [0; 16];
    if iMode & 0o170000 as libc::c_int == 0o120000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'l' as i32 as libc::c_char;
    } else if iMode & 0o170000 as libc::c_int == 0o100000 as libc::c_int {
        z[0 as libc::c_int as usize] = '-' as i32 as libc::c_char;
    } else if iMode & 0o170000 as libc::c_int == 0o40000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'd' as i32 as libc::c_char;
    } else {
        z[0 as libc::c_int as usize] = '?' as i32 as libc::c_char;
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        let m: libc::c_int = iMode >> (2 as libc::c_int - i) * 3 as libc::c_int;
        let a: *mut libc::c_char = &mut *z
            .as_mut_ptr()
            .offset((1 as libc::c_int + i * 3 as libc::c_int) as isize)
            as *mut libc::c_char;
        *a
            .offset(
                0 as libc::c_int as isize,
            ) = (if m & 0x4 as libc::c_int != 0 { 'r' as i32 } else { '-' as i32 })
            as libc::c_char;
        *a
            .offset(
                1 as libc::c_int as isize,
            ) = (if m & 0x2 as libc::c_int != 0 { 'w' as i32 } else { '-' as i32 })
            as libc::c_char;
        *a
            .offset(
                2 as libc::c_int as isize,
            ) = (if m & 0x1 as libc::c_int != 0 { 'x' as i32 } else { '-' as i32 })
            as libc::c_char;
        i += 1;
        i;
    }
    z[10 as libc::c_int as usize] = '\0' as i32 as libc::c_char;
    sqlite3_result_text(
        context,
        z.as_mut_ptr(),
        -(1 as libc::c_int),
        ::core::mem::transmute::<
            libc::intptr_t,
            sqlite3_destructor_type,
        >(-(1 as libc::c_int) as libc::intptr_t),
    );
}
unsafe extern "C" fn fsdirConnect(
    db: *mut sqlite3,
    _pAux: *mut libc::c_void,
    _argc: libc::c_int,
    _argv: *const *const libc::c_char,
    ppVtab: *mut *mut sqlite3_vtab,
    _pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut fsdir_tab = 0 as *mut fsdir_tab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\0" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::core::mem::size_of::<fsdir_tab>() as libc::c_ulong as libc::c_int,
        ) as *mut fsdir_tab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<fsdir_tab>() as libc::c_ulong,
        );
        sqlite3_vtab_config(db, 3 as libc::c_int);
    }
    *ppVtab = pNew as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn fsdirDisconnect(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirOpen(
    _p: *mut sqlite3_vtab,
    ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = 0 as *mut fsdir_cursor;
    pCur = sqlite3_malloc(
        ::core::mem::size_of::<fsdir_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut fsdir_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<fsdir_cursor>() as libc::c_ulong,
    );
    (*pCur).iLvl = -(1 as libc::c_int);
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirResetCursor(pCur: *mut fsdir_cursor) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i <= (*pCur).iLvl {
        let pLvl: *mut FsdirLevel = &mut *((*pCur).aLvl).offset(i as isize)
            as *mut FsdirLevel;
        if !((*pLvl).pDir).is_null() {
            closedir((*pLvl).pDir);
        }
        sqlite3_free((*pLvl).zDir as *mut libc::c_void);
        i += 1;
        i;
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    sqlite3_free((*pCur).aLvl as *mut libc::c_void);
    (*pCur).aLvl = 0 as *mut FsdirLevel;
    (*pCur).zPath = 0 as *mut libc::c_char;
    (*pCur).zBase = 0 as *const libc::c_char;
    (*pCur).nBase = 0 as libc::c_int;
    (*pCur).nLvl = 0 as libc::c_int;
    (*pCur).iLvl = -(1 as libc::c_int);
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
}
unsafe extern "C" fn fsdirClose(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    sqlite3_free(pCur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirSetErrmsg(
    pCur: *mut fsdir_cursor,
    zFmt: *const libc::c_char,
    args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    (*(*pCur).base.pVtab).zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn fsdirNext(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    let m: mode_t = (*pCur).sStat.st_mode;
    (*pCur).iRowid += 1;
    (*pCur).iRowid;
    if m & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        let iNew: libc::c_int = (*pCur).iLvl + 1 as libc::c_int;
        let mut pLvl: *mut FsdirLevel = 0 as *mut FsdirLevel;
        if iNew >= (*pCur).nLvl {
            let nNew: libc::c_int = iNew + 1 as libc::c_int;
            let nByte: sqlite3_int64 = (nNew as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                as sqlite3_int64;
            let aNew: *mut FsdirLevel = sqlite3_realloc64(
                (*pCur).aLvl as *mut libc::c_void,
                nByte as sqlite3_uint64,
            ) as *mut FsdirLevel;
            if aNew.is_null() {
                return 7 as libc::c_int;
            }
            memset(
                &mut *aNew.offset((*pCur).nLvl as isize) as *mut FsdirLevel
                    as *mut libc::c_void,
                0 as libc::c_int,
                (::core::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                    .wrapping_mul((nNew - (*pCur).nLvl) as libc::c_ulong),
            );
            (*pCur).aLvl = aNew;
            (*pCur).nLvl = nNew;
        }
        (*pCur).iLvl = iNew;
        pLvl = &mut *((*pCur).aLvl).offset(iNew as isize) as *mut FsdirLevel;
        (*pLvl).zDir = (*pCur).zPath;
        (*pCur).zPath = 0 as *mut libc::c_char;
        (*pLvl).pDir = opendir((*pLvl).zDir);
        if ((*pLvl).pDir).is_null() {
            fsdirSetErrmsg(
                pCur,
                b"cannot read directory: %s\0" as *const u8 as *const libc::c_char,
                (*pCur).zPath,
            );
            return 1 as libc::c_int;
        }
    }
    while (*pCur).iLvl >= 0 as libc::c_int {
        let pLvl_0: *mut FsdirLevel = &mut *((*pCur).aLvl)
            .offset((*pCur).iLvl as isize) as *mut FsdirLevel;
        let pEntry: *mut dirent = readdir((*pLvl_0).pDir);
        if !pEntry.is_null() {
            if (*pEntry).d_name[0 as libc::c_int as usize] as libc::c_int == '.' as i32 {
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int
                    == '.' as i32
                    && (*pEntry).d_name[2 as libc::c_int as usize] as libc::c_int
                        == '\0' as i32
                {
                    continue;
                }
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int
                    == '\0' as i32
                {
                    continue;
                }
            }
            sqlite3_free((*pCur).zPath as *mut libc::c_void);
            (*pCur)
                .zPath = sqlite3_mprintf(
                b"%s/%s\0" as *const u8 as *const libc::c_char,
                (*pLvl_0).zDir,
                ((*pEntry).d_name).as_mut_ptr(),
            );
            if ((*pCur).zPath).is_null() {
                return 7 as libc::c_int;
            }
            if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
                fsdirSetErrmsg(
                    pCur,
                    b"cannot stat file: %s\0" as *const u8 as *const libc::c_char,
                    (*pCur).zPath,
                );
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        } else {
            closedir((*pLvl_0).pDir);
            sqlite3_free((*pLvl_0).zDir as *mut libc::c_void);
            (*pLvl_0).pDir = 0 as *mut DIR;
            (*pLvl_0).zDir = 0 as *mut libc::c_char;
            (*pCur).iLvl -= 1;
            (*pCur).iLvl;
        }
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    (*pCur).zPath = 0 as *mut libc::c_char;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirColumn(
    cur: *mut sqlite3_vtab_cursor,
    ctx: *mut sqlite3_context,
    i: libc::c_int,
) -> libc::c_int {
    let pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                &mut *((*pCur).zPath).offset((*pCur).nBase as isize),
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        1 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mode as sqlite3_int64);
        }
        2 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mtim.tv_sec as sqlite3_int64);
        }
        3 => {
            let m: mode_t = (*pCur).sStat.st_mode;
            if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint
            {
                sqlite3_result_null(ctx);
            } else if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o120000 as libc::c_int as libc::c_uint
            {
                let mut aStatic: [libc::c_char; 64] = [0; 64];
                let mut aBuf: *mut libc::c_char = aStatic.as_mut_ptr();
                let mut nBuf: sqlite3_int64 = 64 as libc::c_int as sqlite3_int64;
                let mut n: libc::c_int = 0;
                loop {
                    n = readlink((*pCur).zPath, aBuf, nBuf as size_t) as libc::c_int;
                    if (n as libc::c_longlong) < nBuf {
                        break;
                    }
                    if aBuf != aStatic.as_mut_ptr() {
                        sqlite3_free(aBuf as *mut libc::c_void);
                    }
                    nBuf = nBuf * 2 as libc::c_int as libc::c_longlong;
                    aBuf = sqlite3_malloc64(nBuf as sqlite3_uint64) as *mut libc::c_char;
                    if aBuf.is_null() {
                        sqlite3_result_error_nomem(ctx);
                        return 7 as libc::c_int;
                    }
                }
                sqlite3_result_text(
                    ctx,
                    aBuf,
                    n,
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
                if aBuf != aStatic.as_mut_ptr() {
                    sqlite3_free(aBuf as *mut libc::c_void);
                }
            } else {
                readFileContents(ctx, (*pCur).zPath);
            }
        }
        4 | _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirRowid(
    cur: *mut sqlite3_vtab_cursor,
    pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirEof(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    return ((*pCur).zPath == 0 as *mut libc::c_char) as libc::c_int;
}
unsafe extern "C" fn fsdirFilter(
    cur: *mut sqlite3_vtab_cursor,
    idxNum: libc::c_int,
    _idxStr: *const libc::c_char,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut zDir: *const libc::c_char = 0 as *const libc::c_char;
    let pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    if idxNum == 0 as libc::c_int {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires an argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc == idxNum && (argc == 1 as libc::c_int || argc == 2 as libc::c_int) {} else {
        __assert_fail(
            b"argc==idxNum && (argc==1 || argc==2)\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            7140 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 81],
                &[libc::c_char; 81],
            >(
                b"int fsdirFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
            ))
                .as_ptr(),
        );
    }
    'c_37985: {
        if argc == idxNum && (argc == 1 as libc::c_int || argc == 2 as libc::c_int)
        {} else {
            __assert_fail(
                b"argc==idxNum && (argc==1 || argc==2)\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                7140 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 81],
                    &[libc::c_char; 81],
                >(
                    b"int fsdirFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    zDir = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    if zDir.is_null() {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires a non-NULL argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc == 2 as libc::c_int {
        (*pCur)
            .zBase = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
            as *const libc::c_char;
    }
    if !((*pCur).zBase).is_null() {
        (*pCur).nBase = strlen((*pCur).zBase) as libc::c_int + 1 as libc::c_int;
        (*pCur)
            .zPath = sqlite3_mprintf(
            b"%s/%s\0" as *const u8 as *const libc::c_char,
            (*pCur).zBase,
            zDir,
        );
    } else {
        (*pCur)
            .zPath = sqlite3_mprintf(b"%s\0" as *const u8 as *const libc::c_char, zDir);
    }
    if ((*pCur).zPath).is_null() {
        return 7 as libc::c_int;
    }
    if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
        fsdirSetErrmsg(
            pCur,
            b"cannot stat file: %s\0" as *const u8 as *const libc::c_char,
            (*pCur).zPath,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirBestIndex(
    _tab: *mut sqlite3_vtab,
    pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idxPath: libc::c_int = -(1 as libc::c_int);
    let mut idxDir: libc::c_int = -(1 as libc::c_int);
    let mut seenPath: libc::c_int = 0 as libc::c_int;
    let mut seenDir: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
            match (*pConstraint).iColumn {
                4 => {
                    if (*pConstraint).usable != 0 {
                        idxPath = i;
                        seenPath = 0 as libc::c_int;
                    } else if idxPath < 0 as libc::c_int {
                        seenPath = 1 as libc::c_int;
                    }
                }
                5 => {
                    if (*pConstraint).usable != 0 {
                        idxDir = i;
                        seenDir = 0 as libc::c_int;
                    } else if idxDir < 0 as libc::c_int {
                        seenDir = 1 as libc::c_int;
                    }
                }
                _ => {}
            }
        }
        i += 1;
        i;
        pConstraint = pConstraint.offset(1);
        pConstraint;
    }
    if seenPath != 0 || seenDir != 0 {
        return 19 as libc::c_int;
    }
    if idxPath < 0 as libc::c_int {
        (*pIdxInfo).idxNum = 0 as libc::c_int;
        (*pIdxInfo).estimatedRows = 0x7fffffff as libc::c_int as sqlite3_int64;
    } else {
        (*((*pIdxInfo).aConstraintUsage).offset(idxPath as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*((*pIdxInfo).aConstraintUsage).offset(idxPath as isize))
            .argvIndex = 1 as libc::c_int;
        if idxDir >= 0 as libc::c_int {
            (*((*pIdxInfo).aConstraintUsage).offset(idxDir as isize))
                .omit = 1 as libc::c_int as libc::c_uchar;
            (*((*pIdxInfo).aConstraintUsage).offset(idxDir as isize))
                .argvIndex = 2 as libc::c_int;
            (*pIdxInfo).idxNum = 2 as libc::c_int;
            (*pIdxInfo).estimatedCost = 10.0f64;
        } else {
            (*pIdxInfo).idxNum = 1 as libc::c_int;
            (*pIdxInfo).estimatedCost = 100.0f64;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn fsdirRegister(db: *mut sqlite3) -> libc::c_int {
    static mut fsdirModule: sqlite3_module = unsafe {
        {
            let init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    fsdirConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    fsdirBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    fsdirDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    fsdirOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    fsdirClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    fsdirFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    fsdirNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    fsdirEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    fsdirColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    fsdirRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let rc: libc::c_int = sqlite3_create_module(
        db,
        b"fsdir\0" as *const u8 as *const libc::c_char,
        &mut fsdirModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_fileio_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"readfile\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x80000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            readfileFunc
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"writefile\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                writefileFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"lsmode\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                lsModeFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = fsdirRegister(db);
    }
    return rc;
}
unsafe extern "C" fn completionConnect(
    db: *mut sqlite3,
    _pAux: *mut libc::c_void,
    _argc: libc::c_int,
    _argv: *const *const libc::c_char,
    ppVtab: *mut *mut sqlite3_vtab,
    _pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut completion_vtab = 0 as *mut completion_vtab;
    let mut rc: libc::c_int = 0;
    sqlite3_vtab_config(db, 2 as libc::c_int);
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(  candidate TEXT,  prefix TEXT HIDDEN,  wholeline TEXT HIDDEN,  phase INT HIDDEN)\0"
            as *const u8 as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::core::mem::size_of::<completion_vtab>() as libc::c_ulong as libc::c_int,
        ) as *mut completion_vtab;
        *ppVtab = pNew as *mut sqlite3_vtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<completion_vtab>() as libc::c_ulong,
        );
        (*pNew).db = db;
    }
    return rc;
}
unsafe extern "C" fn completionDisconnect(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionOpen(
    p: *mut sqlite3_vtab,
    ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = 0 as *mut completion_cursor;
    pCur = sqlite3_malloc(
        ::core::mem::size_of::<completion_cursor>() as libc::c_ulong as libc::c_int,
    ) as *mut completion_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCur as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<completion_cursor>() as libc::c_ulong,
    );
    (*pCur).db = (*(p as *mut completion_vtab)).db;
    *ppCursor = &mut (*pCur).base;
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionCursorReset(pCur: *mut completion_cursor) {
    sqlite3_free((*pCur).zPrefix as *mut libc::c_void);
    (*pCur).zPrefix = 0 as *mut libc::c_char;
    (*pCur).nPrefix = 0 as libc::c_int;
    sqlite3_free((*pCur).zLine as *mut libc::c_void);
    (*pCur).zLine = 0 as *mut libc::c_char;
    (*pCur).nLine = 0 as libc::c_int;
    sqlite3_finalize((*pCur).pStmt);
    (*pCur).pStmt = 0 as *mut sqlite3_stmt;
    (*pCur).j = 0 as libc::c_int;
}
unsafe extern "C" fn completionClose(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    completionCursorReset(cur as *mut completion_cursor);
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionNext(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut completion_cursor = cur as *mut completion_cursor;
    let mut eNextPhase: libc::c_int = 0 as libc::c_int;
    let mut iCol: libc::c_int = -(1 as libc::c_int);
    (*pCur).iRowid += 1;
    (*pCur).iRowid;
    while (*pCur).ePhase != 11 as libc::c_int {
        match (*pCur).ePhase {
            1 => {
                if (*pCur).j >= sqlite3_keyword_count() {
                    (*pCur).zCurrentRow = 0 as *const libc::c_char;
                    (*pCur).ePhase = 7 as libc::c_int;
                } else {
                    let fresh41 = (*pCur).j;
                    (*pCur).j = (*pCur).j + 1;
                    sqlite3_keyword_name(
                        fresh41,
                        &mut (*pCur).zCurrentRow,
                        &mut (*pCur).szRow,
                    );
                }
                iCol = -(1 as libc::c_int);
            }
            7 => {
                if ((*pCur).pStmt).is_null() {
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                }
                iCol = 1 as libc::c_int;
                eNextPhase = 8 as libc::c_int;
            }
            8 => {
                if ((*pCur).pStmt).is_null() {
                    let mut pS2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep: *const libc::c_char = b"\0" as *const u8
                        as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2) == 100 as libc::c_int {
                        let zDb: *const libc::c_char = sqlite3_column_text(
                            pS2,
                            1 as libc::c_int,
                        ) as *const libc::c_char;
                        zSql = sqlite3_mprintf(
                            b"%z%sSELECT name FROM \"%w\".sqlite_schema\0" as *const u8
                                as *const libc::c_char,
                            zSql,
                            zSep,
                            zDb,
                        );
                        if zSql.is_null() {
                            return 7 as libc::c_int;
                        }
                        zSep = b" UNION \0" as *const u8 as *const libc::c_char;
                    }
                    sqlite3_finalize(pS2);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 9 as libc::c_int;
            }
            9 => {
                if ((*pCur).pStmt).is_null() {
                    let mut pS2_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep_0: *const libc::c_char = b"\0" as *const u8
                        as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2_0,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2_0) == 100 as libc::c_int {
                        let zDb_0: *const libc::c_char = sqlite3_column_text(
                            pS2_0,
                            1 as libc::c_int,
                        ) as *const libc::c_char;
                        zSql_0 = sqlite3_mprintf(
                            b"%z%sSELECT pti.name FROM \"%w\".sqlite_schema AS sm JOIN pragma_table_info(sm.name,%Q) AS pti WHERE sm.type='table'\0"
                                as *const u8 as *const libc::c_char,
                            zSql_0,
                            zSep_0,
                            zDb_0,
                            zDb_0,
                        );
                        if zSql_0.is_null() {
                            return 7 as libc::c_int;
                        }
                        zSep_0 = b" UNION \0" as *const u8 as *const libc::c_char;
                    }
                    sqlite3_finalize(pS2_0);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql_0,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_0 as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 11 as libc::c_int;
            }
            _ => {}
        }
        if iCol < 0 as libc::c_int {
            if ((*pCur).zCurrentRow).is_null() {
                continue;
            }
        } else if sqlite3_step((*pCur).pStmt) == 100 as libc::c_int {
            (*pCur)
                .zCurrentRow = sqlite3_column_text((*pCur).pStmt, iCol)
                as *const libc::c_char;
            (*pCur).szRow = sqlite3_column_bytes((*pCur).pStmt, iCol);
        } else {
            sqlite3_finalize((*pCur).pStmt);
            (*pCur).pStmt = 0 as *mut sqlite3_stmt;
            (*pCur).ePhase = eNextPhase;
            continue;
        }
        if (*pCur).nPrefix == 0 as libc::c_int {
            break;
        }
        if (*pCur).nPrefix <= (*pCur).szRow
            && sqlite3_strnicmp((*pCur).zPrefix, (*pCur).zCurrentRow, (*pCur).nPrefix)
                == 0 as libc::c_int
        {
            break;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionColumn(
    cur: *mut sqlite3_vtab_cursor,
    ctx: *mut sqlite3_context,
    i: libc::c_int,
) -> libc::c_int {
    let pCur: *mut completion_cursor = cur as *mut completion_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zCurrentRow,
                (*pCur).szRow,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        1 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zPrefix,
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        2 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zLine,
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        3 => {
            sqlite3_result_int(ctx, (*pCur).ePhase);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionRowid(
    cur: *mut sqlite3_vtab_cursor,
    pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let pCur: *mut completion_cursor = cur as *mut completion_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn completionEof(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCur: *mut completion_cursor = cur as *mut completion_cursor;
    return ((*pCur).ePhase >= 11 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn completionFilter(
    pVtabCursor: *mut sqlite3_vtab_cursor,
    idxNum: libc::c_int,
    _idxStr: *const libc::c_char,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let pCur: *mut completion_cursor = pVtabCursor as *mut completion_cursor;
    let mut iArg: libc::c_int = 0 as libc::c_int;
    completionCursorReset(pCur);
    if idxNum & 1 as libc::c_int != 0 {
        (*pCur).nPrefix = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nPrefix > 0 as libc::c_int {
            (*pCur)
                .zPrefix = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if ((*pCur).zPrefix).is_null() {
                return 7 as libc::c_int;
            }
        }
        iArg = 1 as libc::c_int;
    }
    if idxNum & 2 as libc::c_int != 0 {
        (*pCur).nLine = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nLine > 0 as libc::c_int {
            (*pCur)
                .zLine = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if ((*pCur).zLine).is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    if !((*pCur).zLine).is_null() && ((*pCur).zPrefix).is_null() {
        let mut i: libc::c_int = (*pCur).nLine;
        while i > 0 as libc::c_int
            && (*(*__ctype_b_loc())
                .offset(
                    *((*pCur).zLine).offset((i - 1 as libc::c_int) as isize)
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int != 0
                || *((*pCur).zLine).offset((i - 1 as libc::c_int) as isize)
                    as libc::c_int == '_' as i32)
        {
            i -= 1;
            i;
        }
        (*pCur).nPrefix = (*pCur).nLine - i;
        if (*pCur).nPrefix > 0 as libc::c_int {
            (*pCur)
                .zPrefix = sqlite3_mprintf(
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (*pCur).nPrefix,
                ((*pCur).zLine).offset(i as isize),
            );
            if ((*pCur).zPrefix).is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    (*pCur).iRowid = 0 as libc::c_int as sqlite3_int64;
    (*pCur).ePhase = 1 as libc::c_int;
    return completionNext(pVtabCursor);
}
unsafe extern "C" fn completionBestIndex(
    _tab: *mut sqlite3_vtab,
    pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idxNum: libc::c_int = 0 as libc::c_int;
    let mut prefixIdx: libc::c_int = -(1 as libc::c_int);
    let mut wholelineIdx: libc::c_int = -(1 as libc::c_int);
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0
        as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).usable as libc::c_int == 0 as libc::c_int) {
            if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
                match (*pConstraint).iColumn {
                    1 => {
                        prefixIdx = i;
                        idxNum |= 1 as libc::c_int;
                    }
                    2 => {
                        wholelineIdx = i;
                        idxNum |= 2 as libc::c_int;
                    }
                    _ => {}
                }
            }
        }
        i += 1;
        i;
        pConstraint = pConstraint.offset(1);
        pConstraint;
    }
    if prefixIdx >= 0 as libc::c_int {
        nArg += 1;
        (*((*pIdxInfo).aConstraintUsage).offset(prefixIdx as isize)).argvIndex = nArg;
        (*((*pIdxInfo).aConstraintUsage).offset(prefixIdx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    if wholelineIdx >= 0 as libc::c_int {
        nArg += 1;
        (*((*pIdxInfo).aConstraintUsage).offset(wholelineIdx as isize)).argvIndex = nArg;
        (*((*pIdxInfo).aConstraintUsage).offset(wholelineIdx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    (*pIdxInfo).idxNum = idxNum;
    (*pIdxInfo)
        .estimatedCost = 5000 as libc::c_int as libc::c_double
        - (1000 as libc::c_int * nArg) as libc::c_double;
    (*pIdxInfo)
        .estimatedRows = (500 as libc::c_int - 100 as libc::c_int * nArg)
        as sqlite3_int64;
    return 0 as libc::c_int;
}
static mut completionModule: sqlite3_module = unsafe {
    {
        let init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                completionConnect
                    as unsafe extern "C" fn(
                        *mut sqlite3,
                        *mut libc::c_void,
                        libc::c_int,
                        *const *const libc::c_char,
                        *mut *mut sqlite3_vtab,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                completionBestIndex
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                completionDisconnect
                    as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                completionOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab,
                        *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                completionClose
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                completionFilter
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        libc::c_int,
                        *const libc::c_char,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                completionNext
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                completionEof
                    as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                completionColumn
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite3_context,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                completionRowid
                    as unsafe extern "C" fn(
                        *mut sqlite3_vtab_cursor,
                        *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
#[no_mangle]
pub unsafe extern "C" fn sqlite3CompletionVtabInit(db: *mut sqlite3) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_module(
        db,
        b"completion\0" as *const u8 as *const libc::c_char,
        &mut completionModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_completion_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3CompletionVtabInit(db);
    return rc;
}
static mut apnd_vfs: sqlite3_vfs = unsafe {
    {
        let init = sqlite3_vfs {
            iVersion: 3 as libc::c_int,
            szOsFile: 0 as libc::c_int,
            mxPathname: 1024 as libc::c_int,
            pNext: 0 as *const sqlite3_vfs as *mut sqlite3_vfs,
            zName: b"apndvfs\0" as *const u8 as *const libc::c_char,
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
            xOpen: Some(
                apndOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xDelete: Some(
                apndDelete
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xAccess: Some(
                apndAccess
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFullPathname: Some(
                apndFullPathname
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xDlOpen: Some(
                apndDlOpen
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> *mut libc::c_void,
            ),
            xDlError: Some(
                apndDlError
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> (),
            ),
            xDlSym: Some(
                apndDlSym
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut libc::c_void,
                        *const libc::c_char,
                    ) -> Option::<unsafe extern "C" fn() -> ()>,
            ),
            xDlClose: Some(
                apndDlClose
                    as unsafe extern "C" fn(*mut sqlite3_vfs, *mut libc::c_void) -> (),
            ),
            xRandomness: Some(
                apndRandomness
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xSleep: Some(
                apndSleep
                    as unsafe extern "C" fn(*mut sqlite3_vfs, libc::c_int) -> libc::c_int,
            ),
            xCurrentTime: Some(
                apndCurrentTime
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut libc::c_double,
                    ) -> libc::c_int,
            ),
            xGetLastError: Some(
                apndGetLastError
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        libc::c_int,
                        *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xCurrentTimeInt64: Some(
                apndCurrentTimeInt64
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSetSystemCall: Some(
                apndSetSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                        sqlite3_syscall_ptr,
                    ) -> libc::c_int,
            ),
            xGetSystemCall: Some(
                apndGetSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> sqlite3_syscall_ptr,
            ),
            xNextSystemCall: Some(
                apndNextSystemCall
                    as unsafe extern "C" fn(
                        *mut sqlite3_vfs,
                        *const libc::c_char,
                    ) -> *const libc::c_char,
            ),
        };
        init
    }
};
static mut apnd_io_methods: sqlite3_io_methods = unsafe {
    {
        let init = sqlite3_io_methods {
            iVersion: 3 as libc::c_int,
            xClose: Some(
                apndClose as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xRead: Some(
                apndRead
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xWrite: Some(
                apndWrite
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *const libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xTruncate: Some(
                apndTruncate
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSync: Some(
                apndSync
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileSize: Some(
                apndFileSize
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xLock: Some(
                apndLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xUnlock: Some(
                apndUnlock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xCheckReservedLock: Some(
                apndCheckReservedLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileControl: Some(
                apndFileControl
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xSectorSize: Some(
                apndSectorSize as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xDeviceCharacteristics: Some(
                apndDeviceCharacteristics
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xShmMap: Some(
                apndShmMap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xShmLock: Some(
                apndShmLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xShmBarrier: Some(
                apndShmBarrier as unsafe extern "C" fn(*mut sqlite3_file) -> (),
            ),
            xShmUnmap: Some(
                apndShmUnmap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFetch: Some(
                apndFetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xUnfetch: Some(
                apndUnfetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
unsafe extern "C" fn apndClose(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xClose).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndRead(
    mut pFile: *mut sqlite3_file,
    zBuf: *mut libc::c_void,
    iAmt: libc::c_int,
    iOfst: sqlite_int64,
) -> libc::c_int {
    let paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xRead)
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
unsafe extern "C" fn apndWriteMark(
    paf: *mut ApndFile,
    pFile: *mut sqlite3_file,
    mut iWriteEnd: sqlite_int64,
) -> libc::c_int {
    let mut iPgOne: sqlite_int64 = (*paf).iPgOne;
    let mut a: [libc::c_uchar; 25] = [0; 25];
    let mut i: libc::c_int = 8 as libc::c_int;
    let mut rc: libc::c_int = 0;
    if pFile == paf.offset(1 as libc::c_int as isize) as *mut sqlite3_file {} else {
        __assert_fail(
            b"pFile == ORIGFILE(paf)\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            8084 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 60],
                &[libc::c_char; 60],
            >(b"int apndWriteMark(ApndFile *, sqlite3_file *, sqlite_int64)\0"))
                .as_ptr(),
        );
    }
    'c_40278: {
        if pFile == paf.offset(1 as libc::c_int as isize) as *mut sqlite3_file {} else {
            __assert_fail(
                b"pFile == ORIGFILE(paf)\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                8084 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 60],
                    &[libc::c_char; 60],
                >(b"int apndWriteMark(ApndFile *, sqlite3_file *, sqlite_int64)\0"))
                    .as_ptr(),
            );
        }
    };
    memcpy(
        a.as_mut_ptr() as *mut libc::c_void,
        b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
            as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    );
    loop {
        i -= 1;
        if !(i >= 0 as libc::c_int) {
            break;
        }
        a[(17 as libc::c_int + i)
            as usize] = (iPgOne & 0xff as libc::c_int as libc::c_longlong)
            as libc::c_uchar;
        iPgOne >>= 8 as libc::c_int;
    }
    iWriteEnd += (*paf).iPgOne;
    rc = ((*(*pFile).pMethods).xWrite)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        a.as_mut_ptr() as *const libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        iWriteEnd,
    );
    if 0 as libc::c_int == rc {
        (*paf).iMark = iWriteEnd;
    }
    return rc;
}
unsafe extern "C" fn apndWrite(
    mut pFile: *mut sqlite3_file,
    zBuf: *const libc::c_void,
    iAmt: libc::c_int,
    iOfst: sqlite_int64,
) -> libc::c_int {
    let paf: *mut ApndFile = pFile as *mut ApndFile;
    let iWriteEnd: sqlite_int64 = iOfst + iAmt as libc::c_longlong;
    if iWriteEnd >= 0x40000000 as libc::c_int as libc::c_longlong {
        return 13 as libc::c_int;
    }
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if (*paf).iMark < 0 as libc::c_int as libc::c_longlong
        || (*paf).iPgOne + iWriteEnd > (*paf).iMark
    {
        let rc: libc::c_int = apndWriteMark(paf, pFile, iWriteEnd);
        if 0 as libc::c_int != rc {
            return rc;
        }
    }
    return ((*(*pFile).pMethods).xWrite)
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
unsafe extern "C" fn apndTruncate(
    mut pFile: *mut sqlite3_file,
    size: sqlite_int64,
) -> libc::c_int {
    let paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if 0 as libc::c_int != apndWriteMark(paf, pFile, size) {
        return 10 as libc::c_int;
    }
    return ((*(*pFile).pMethods).xTruncate)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        (*paf).iMark + (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
    );
}
unsafe extern "C" fn apndSync(
    mut pFile: *mut sqlite3_file,
    flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xSync)
        .expect("non-null function pointer")(pFile, flags);
}
unsafe extern "C" fn apndFileSize(
    pFile: *mut sqlite3_file,
    pSize: *mut sqlite_int64,
) -> libc::c_int {
    let paf: *mut ApndFile = pFile as *mut ApndFile;
    *pSize = if (*paf).iMark >= 0 as libc::c_int as libc::c_longlong {
        (*paf).iMark - (*paf).iPgOne
    } else {
        0 as libc::c_int as libc::c_longlong
    };
    return 0 as libc::c_int;
}
unsafe extern "C" fn apndLock(
    mut pFile: *mut sqlite3_file,
    eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xLock)
        .expect("non-null function pointer")(pFile, eLock);
}
unsafe extern "C" fn apndUnlock(
    mut pFile: *mut sqlite3_file,
    eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xUnlock)
        .expect("non-null function pointer")(pFile, eLock);
}
unsafe extern "C" fn apndCheckReservedLock(
    mut pFile: *mut sqlite3_file,
    pResOut: *mut libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xCheckReservedLock)
        .expect("non-null function pointer")(pFile, pResOut);
}
unsafe extern "C" fn apndFileControl(
    mut pFile: *mut sqlite3_file,
    op: libc::c_int,
    pArg: *mut libc::c_void,
) -> libc::c_int {
    let paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut rc: libc::c_int = 0;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    if op == 5 as libc::c_int {
        let ref mut fresh42 = *(pArg as *mut sqlite3_int64);
        *fresh42 += (*paf).iPgOne;
    }
    rc = ((*(*pFile).pMethods).xFileControl)
        .expect("non-null function pointer")(pFile, op, pArg);
    if rc == 0 as libc::c_int && op == 12 as libc::c_int {
        let ref mut fresh43 = *(pArg as *mut *mut libc::c_char);
        *fresh43 = sqlite3_mprintf(
            b"apnd(%lld)/%z\0" as *const u8 as *const libc::c_char,
            (*paf).iPgOne,
            *(pArg as *mut *mut libc::c_char),
        );
    }
    return rc;
}
unsafe extern "C" fn apndSectorSize(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xSectorSize).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndDeviceCharacteristics(
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xDeviceCharacteristics)
        .expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndShmMap(
    mut pFile: *mut sqlite3_file,
    iPg: libc::c_int,
    pgsz: libc::c_int,
    bExtend: libc::c_int,
    pp: *mut *mut libc::c_void,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmMap)
        .expect("non-null function pointer")(pFile, iPg, pgsz, bExtend, pp);
}
unsafe extern "C" fn apndShmLock(
    mut pFile: *mut sqlite3_file,
    offset: libc::c_int,
    n: libc::c_int,
    flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmLock)
        .expect("non-null function pointer")(pFile, offset, n, flags);
}
unsafe extern "C" fn apndShmBarrier(mut pFile: *mut sqlite3_file) {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    ((*(*pFile).pMethods).xShmBarrier).expect("non-null function pointer")(pFile);
}
unsafe extern "C" fn apndShmUnmap(
    mut pFile: *mut sqlite3_file,
    deleteFlag: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xShmUnmap)
        .expect("non-null function pointer")(pFile, deleteFlag);
}
unsafe extern "C" fn apndFetch(
    mut pFile: *mut sqlite3_file,
    iOfst: sqlite3_int64,
    iAmt: libc::c_int,
    pp: *mut *mut libc::c_void,
) -> libc::c_int {
    let p: *mut ApndFile = pFile as *mut ApndFile;
    if (*p).iMark < 0 as libc::c_int as libc::c_longlong
        || iOfst + iAmt as libc::c_longlong > (*p).iMark
    {
        return 10 as libc::c_int;
    }
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xFetch)
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, iAmt, pp);
}
unsafe extern "C" fn apndUnfetch(
    mut pFile: *mut sqlite3_file,
    iOfst: sqlite3_int64,
    pPage: *mut libc::c_void,
) -> libc::c_int {
    let p: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize)
        as *mut sqlite3_file;
    return ((*(*pFile).pMethods).xUnfetch)
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, pPage);
}
unsafe extern "C" fn apndReadMark(
    sz: sqlite3_int64,
    pFile: *mut sqlite3_file,
) -> sqlite3_int64 {
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iMark: sqlite3_int64 = 0;
    let mut msbs: libc::c_int = 8 as libc::c_int * (8 as libc::c_int - 1 as libc::c_int);
    let mut a: [libc::c_uchar; 25] = [0; 25];
    if (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
        != sz & 0x1ff as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    rc = ((*(*pFile).pMethods).xRead)
        .expect(
            "non-null function pointer",
        )(
        pFile,
        a.as_mut_ptr() as *mut libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
    );
    if rc != 0 {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    if memcmp(
        a.as_mut_ptr() as *const libc::c_void,
        b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
            as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    iMark = ((a[17 as libc::c_int as usize] as libc::c_int & 0x7f as libc::c_int)
        as sqlite3_int64) << msbs;
    i = 1 as libc::c_int;
    while i < 8 as libc::c_int {
        msbs -= 8 as libc::c_int;
        iMark |= (a[(17 as libc::c_int + i) as usize] as sqlite3_int64) << msbs;
        i += 1;
        i;
    }
    if iMark
        > sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            - 512 as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    if iMark & 0x1ff as libc::c_int as libc::c_longlong != 0 {
        return -(1 as libc::c_int) as sqlite3_int64;
    }
    return iMark;
}
static mut apvfsSqliteHdr: [libc::c_char; 16] = unsafe {
    *::core::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SQLite format 3\0")
};
unsafe extern "C" fn apndIsAppendvfsDatabase(
    sz: sqlite3_int64,
    pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    let iMark: sqlite3_int64 = apndReadMark(sz, pFile);
    if iMark >= 0 as libc::c_int as libc::c_longlong {
        rc = ((*(*pFile).pMethods).xRead)
            .expect(
                "non-null function pointer",
            )(
            pFile,
            zHdr.as_mut_ptr() as *mut libc::c_void,
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as libc::c_int,
            iMark,
        );
        if 0 as libc::c_int == rc
            && memcmp(
                zHdr.as_mut_ptr() as *const libc::c_void,
                apvfsSqliteHdr.as_ptr() as *const libc::c_void,
                ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            && sz & 0x1ff as libc::c_int as libc::c_longlong
                == (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            && sz
                >= (512 as libc::c_int + (17 as libc::c_int + 8 as libc::c_int))
                    as libc::c_longlong
        {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn apndIsOrdinaryDatabaseFile(
    sz: sqlite3_int64,
    pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    if apndIsAppendvfsDatabase(sz, pFile) != 0
        || sz & 0x1ff as libc::c_int as libc::c_longlong
            != 0 as libc::c_int as libc::c_longlong
        || 0 as libc::c_int
            != ((*(*pFile).pMethods).xRead)
                .expect(
                    "non-null function pointer",
                )(
                pFile,
                zHdr.as_mut_ptr() as *mut libc::c_void,
                ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong
                    as libc::c_int,
                0 as libc::c_int as sqlite3_int64,
            )
        || memcmp(
            zHdr.as_mut_ptr() as *const libc::c_void,
            apvfsSqliteHdr.as_ptr() as *const libc::c_void,
            ::core::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        ) != 0 as libc::c_int
    {
        return 0 as libc::c_int
    } else {
        return 1 as libc::c_int
    };
}
unsafe extern "C" fn apndOpen(
    pApndVfs: *mut sqlite3_vfs,
    zName: *const libc::c_char,
    pFile: *mut sqlite3_file,
    flags: libc::c_int,
    pOutFlags: *mut libc::c_int,
) -> libc::c_int {
    let pApndFile: *mut ApndFile = pFile as *mut ApndFile;
    let pBaseFile: *mut sqlite3_file = (pFile as *mut ApndFile)
        .offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    let pBaseVfs: *mut sqlite3_vfs = (*pApndVfs).pAppData as *mut sqlite3_vfs;
    let mut rc: libc::c_int = 0;
    let mut sz: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    if flags & 0x100 as libc::c_int == 0 as libc::c_int {
        return ((*pBaseVfs).xOpen)
            .expect(
                "non-null function pointer",
            )(pBaseVfs, zName, pFile, flags, pOutFlags);
    }
    memset(
        pApndFile as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ApndFile>() as libc::c_ulong,
    );
    (*pFile).pMethods = &apnd_io_methods;
    (*pApndFile).iMark = -(1 as libc::c_int) as sqlite3_int64;
    rc = ((*pBaseVfs).xOpen)
        .expect(
            "non-null function pointer",
        )(pBaseVfs, zName, pBaseFile, flags, pOutFlags);
    if rc == 0 as libc::c_int {
        rc = ((*(*pBaseFile).pMethods).xFileSize)
            .expect("non-null function pointer")(pBaseFile, &mut sz);
        if rc != 0 {
            ((*(*pBaseFile).pMethods).xClose)
                .expect("non-null function pointer")(pBaseFile);
        }
    }
    if rc != 0 {
        (*pFile).pMethods = 0 as *const sqlite3_io_methods;
        return rc;
    }
    if apndIsOrdinaryDatabaseFile(sz, pBaseFile) != 0 {
        memmove(
            pApndFile as *mut libc::c_void,
            pBaseFile as *const libc::c_void,
            (*pBaseVfs).szOsFile as libc::c_ulong,
        );
        return 0 as libc::c_int;
    }
    (*pApndFile).iPgOne = apndReadMark(sz, pFile);
    if (*pApndFile).iPgOne >= 0 as libc::c_int as libc::c_longlong {
        (*pApndFile)
            .iMark = sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong;
        return 0 as libc::c_int;
    }
    if flags & 0x4 as libc::c_int == 0 as libc::c_int {
        ((*(*pBaseFile).pMethods).xClose).expect("non-null function pointer")(pBaseFile);
        rc = 14 as libc::c_int;
        (*pFile).pMethods = 0 as *const sqlite3_io_methods;
    } else {
        (*pApndFile)
            .iPgOne = sz + (4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64
            & !((4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64);
    }
    return rc;
}
unsafe extern "C" fn apndDelete(
    pVfs: *mut sqlite3_vfs,
    zPath: *const libc::c_char,
    dirSync: libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDelete)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, dirSync);
}
unsafe extern "C" fn apndAccess(
    pVfs: *mut sqlite3_vfs,
    zPath: *const libc::c_char,
    flags: libc::c_int,
    pResOut: *mut libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xAccess)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, flags, pResOut);
}
unsafe extern "C" fn apndFullPathname(
    pVfs: *mut sqlite3_vfs,
    zPath: *const libc::c_char,
    nOut: libc::c_int,
    zOut: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xFullPathname)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath, nOut, zOut);
}
unsafe extern "C" fn apndDlOpen(
    pVfs: *mut sqlite3_vfs,
    zPath: *const libc::c_char,
) -> *mut libc::c_void {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlOpen)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zPath);
}
unsafe extern "C" fn apndDlError(
    pVfs: *mut sqlite3_vfs,
    nByte: libc::c_int,
    zErrMsg: *mut libc::c_char,
) {
    ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlError)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nByte, zErrMsg);
}
unsafe extern "C" fn apndDlSym(
    pVfs: *mut sqlite3_vfs,
    p: *mut libc::c_void,
    zSym: *const libc::c_char,
) -> Option::<unsafe extern "C" fn() -> ()> {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlSym)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, p, zSym);
}
unsafe extern "C" fn apndDlClose(
    pVfs: *mut sqlite3_vfs,
    pHandle: *mut libc::c_void,
) {
    ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xDlClose)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, pHandle);
}
unsafe extern "C" fn apndRandomness(
    pVfs: *mut sqlite3_vfs,
    nByte: libc::c_int,
    zBufOut: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xRandomness)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nByte, zBufOut);
}
unsafe extern "C" fn apndSleep(
    pVfs: *mut sqlite3_vfs,
    nMicro: libc::c_int,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xSleep)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, nMicro);
}
unsafe extern "C" fn apndCurrentTime(
    pVfs: *mut sqlite3_vfs,
    pTimeOut: *mut libc::c_double,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xCurrentTime)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, pTimeOut);
}
unsafe extern "C" fn apndGetLastError(
    pVfs: *mut sqlite3_vfs,
    a: libc::c_int,
    b: *mut libc::c_char,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xGetLastError)
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, a, b);
}
unsafe extern "C" fn apndCurrentTimeInt64(
    pVfs: *mut sqlite3_vfs,
    p: *mut sqlite3_int64,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xCurrentTimeInt64)
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, p);
}
unsafe extern "C" fn apndSetSystemCall(
    pVfs: *mut sqlite3_vfs,
    zName: *const libc::c_char,
    pCall: sqlite3_syscall_ptr,
) -> libc::c_int {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xSetSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName, pCall);
}
unsafe extern "C" fn apndGetSystemCall(
    pVfs: *mut sqlite3_vfs,
    zName: *const libc::c_char,
) -> sqlite3_syscall_ptr {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xGetSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName);
}
unsafe extern "C" fn apndNextSystemCall(
    pVfs: *mut sqlite3_vfs,
    zName: *const libc::c_char,
) -> *const libc::c_char {
    return ((*((*pVfs).pAppData as *mut sqlite3_vfs)).xNextSystemCall)
        .expect(
            "non-null function pointer",
        )((*pVfs).pAppData as *mut sqlite3_vfs, zName);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_appendvfs_init(
    _db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pOrig: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
    pOrig = sqlite3_vfs_find(0 as *const libc::c_char);
    if pOrig.is_null() {
        return 1 as libc::c_int;
    }
    apnd_vfs.iVersion = (*pOrig).iVersion;
    apnd_vfs.pAppData = pOrig as *mut libc::c_void;
    apnd_vfs
        .szOsFile = ((*pOrig).szOsFile as libc::c_ulong)
        .wrapping_add(::core::mem::size_of::<ApndFile>() as libc::c_ulong)
        as libc::c_int;
    rc = sqlite3_vfs_register(&mut apnd_vfs, 0 as libc::c_int);
    if rc == 0 as libc::c_int {
        rc = 0 as libc::c_int | (1 as libc::c_int) << 8 as libc::c_int;
    }
    return rc;
}
static mut ZIPFILE_SCHEMA: [libc::c_char; 91] = unsafe {
    *::core::mem::transmute::<
        &[u8; 91],
        &[libc::c_char; 91],
    >(
        b"CREATE TABLE y(name PRIMARY KEY,mode,mtime,sz,rawdata,data,method,z HIDDEN) WITHOUT ROWID;\0",
    )
};
unsafe extern "C" fn zipfileCtxErrorMsg(
    ctx: *mut sqlite3_context,
    zFmt: *const libc::c_char,
    args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
unsafe extern "C" fn zipfileDequote(zIn: *mut libc::c_char) {
    let mut q: libc::c_char = *zIn.offset(0 as libc::c_int as isize);
    if q as libc::c_int == '"' as i32 || q as libc::c_int == '\'' as i32
        || q as libc::c_int == '`' as i32 || q as libc::c_int == '[' as i32
    {
        let mut iIn: libc::c_int = 1 as libc::c_int;
        let mut iOut: libc::c_int = 0 as libc::c_int;
        if q as libc::c_int == '[' as i32 {
            q = ']' as i32 as libc::c_char;
        }
        while if *zIn.offset(iIn as isize) as libc::c_int != 0 {
            1 as libc::c_int
        } else {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                8827 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 28],
                    &[libc::c_char; 28],
                >(b"void zipfileDequote(char *)\0"))
                    .as_ptr(),
            );
            'c_42899: {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    8827 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 28],
                        &[libc::c_char; 28],
                    >(b"void zipfileDequote(char *)\0"))
                        .as_ptr(),
                );
            };
            0 as libc::c_int
        } != 0
        {
            let fresh44 = iIn;
            iIn = iIn + 1;
            let c: libc::c_char = *zIn.offset(fresh44 as isize);
            if c as libc::c_int == q as libc::c_int
                && {
                    let fresh45 = iIn;
                    iIn = iIn + 1;
                    *zIn.offset(fresh45 as isize) as libc::c_int != q as libc::c_int
                }
            {
                break;
            }
            let fresh46 = iOut;
            iOut = iOut + 1;
            *zIn.offset(fresh46 as isize) = c;
        }
        *zIn.offset(iOut as isize) = '\0' as i32 as libc::c_char;
    }
}
unsafe extern "C" fn zipfileConnect(
    db: *mut sqlite3,
    _pAux: *mut libc::c_void,
    argc: libc::c_int,
    argv: *const *const libc::c_char,
    ppVtab: *mut *mut sqlite3_vtab,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let nByte: libc::c_int = (::core::mem::size_of::<ZipfileTab>() as libc::c_ulong)
        .wrapping_add((64 as libc::c_int * 1024 as libc::c_int) as libc::c_ulong)
        as libc::c_int;
    let mut nFile: libc::c_int = 0 as libc::c_int;
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut pNew: *mut ZipfileTab = 0 as *mut ZipfileTab;
    let mut rc: libc::c_int = 0;
    if 0 as libc::c_int
        == sqlite3_stricmp(
            *argv.offset(0 as libc::c_int as isize),
            b"zipfile\0" as *const u8 as *const libc::c_char,
        )
    {} else {
        __assert_fail(
            b"0==sqlite3_stricmp(argv[0], \"zipfile\")\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            8867 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 90],
                &[libc::c_char; 90],
            >(
                b"int zipfileConnect(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)\0",
            ))
                .as_ptr(),
        );
    }
    'c_43200: {
        if 0 as libc::c_int
            == sqlite3_stricmp(
                *argv.offset(0 as libc::c_int as isize),
                b"zipfile\0" as *const u8 as *const libc::c_char,
            )
        {} else {
            __assert_fail(
                b"0==sqlite3_stricmp(argv[0], \"zipfile\")\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                8867 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 90],
                    &[libc::c_char; 90],
                >(
                    b"int zipfileConnect(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if 0 as libc::c_int
        != sqlite3_stricmp(
            *argv.offset(2 as libc::c_int as isize),
            b"zipfile\0" as *const u8 as *const libc::c_char,
        ) && argc < 4 as libc::c_int || argc > 4 as libc::c_int
    {
        *pzErr = sqlite3_mprintf(
            b"zipfile constructor requires one argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    if argc > 3 as libc::c_int {
        zFile = *argv.offset(3 as libc::c_int as isize);
        nFile = strlen(zFile) as libc::c_int + 1 as libc::c_int;
    }
    rc = sqlite3_declare_vtab(db, ZIPFILE_SCHEMA.as_ptr());
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc64(
            (nByte as sqlite3_int64 + nFile as libc::c_longlong) as sqlite3_uint64,
        ) as *mut ZipfileTab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        }
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            (nByte + nFile) as libc::c_ulong,
        );
        (*pNew).db = db;
        (*pNew)
            .aBuffer = &mut *pNew.offset(1 as libc::c_int as isize) as *mut ZipfileTab
            as *mut u8_0;
        if !zFile.is_null() {
            (*pNew)
                .zFile = &mut *((*pNew).aBuffer)
                .offset((64 as libc::c_int * 1024 as libc::c_int) as isize) as *mut u8_0
                as *mut libc::c_char;
            memcpy(
                (*pNew).zFile as *mut libc::c_void,
                zFile as *const libc::c_void,
                nFile as libc::c_ulong,
            );
            zipfileDequote((*pNew).zFile);
        }
    }
    sqlite3_vtab_config(db, 3 as libc::c_int);
    *ppVtab = pNew as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn zipfileEntryFree(p: *mut ZipfileEntry) {
    if !p.is_null() {
        sqlite3_free((*p).cds.zFile as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn zipfileCleanupTransaction(pTab: *mut ZipfileTab) {
    let mut pEntry: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pNext: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    if !((*pTab).pWriteFd).is_null() {
        fclose((*pTab).pWriteFd);
        (*pTab).pWriteFd = 0 as *mut FILE;
    }
    pEntry = (*pTab).pFirstEntry;
    while !pEntry.is_null() {
        pNext = (*pEntry).pNext;
        zipfileEntryFree(pEntry);
        pEntry = pNext;
    }
    (*pTab).pFirstEntry = 0 as *mut ZipfileEntry;
    (*pTab).pLastEntry = 0 as *mut ZipfileEntry;
    (*pTab).szCurrent = 0 as libc::c_int as i64_0;
    (*pTab).szOrig = 0 as libc::c_int as i64_0;
}
unsafe extern "C" fn zipfileDisconnect(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    zipfileCleanupTransaction(pVtab as *mut ZipfileTab);
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileOpen(
    p: *mut sqlite3_vtab,
    ppCsr: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let pTab: *mut ZipfileTab = p as *mut ZipfileTab;
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    pCsr = sqlite3_malloc(
        ::core::mem::size_of::<ZipfileCsr>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCsr;
    *ppCsr = pCsr as *mut sqlite3_vtab_cursor;
    if pCsr.is_null() {
        return 7 as libc::c_int;
    }
    memset(
        pCsr as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ZipfileCsr>() as libc::c_ulong,
    );
    (*pTab).iNextCsrid += 1;
    (*pCsr).iId = (*pTab).iNextCsrid;
    (*pCsr).pCsrNext = (*pTab).pCsrList;
    (*pTab).pCsrList = pCsr;
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileResetCursor(pCsr: *mut ZipfileCsr) {
    let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pNext: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    (*pCsr).bEof = 0 as libc::c_int as u8_0;
    if !((*pCsr).pFile).is_null() {
        fclose((*pCsr).pFile);
        (*pCsr).pFile = 0 as *mut FILE;
        zipfileEntryFree((*pCsr).pCurrent);
        (*pCsr).pCurrent = 0 as *mut ZipfileEntry;
    }
    p = (*pCsr).pFreeEntry;
    while !p.is_null() {
        pNext = (*p).pNext;
        zipfileEntryFree(p);
        p = pNext;
    }
}
unsafe extern "C" fn zipfileClose(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let pTab: *mut ZipfileTab = (*pCsr).base.pVtab as *mut ZipfileTab;
    let mut pp: *mut *mut ZipfileCsr = 0 as *mut *mut ZipfileCsr;
    zipfileResetCursor(pCsr);
    pp = &mut (*pTab).pCsrList;
    while *pp != pCsr {
        pp = &mut (**pp).pCsrNext;
    }
    *pp = (*pCsr).pCsrNext;
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileTableErr(
    pTab: *mut ZipfileTab,
    zFmt: *const libc::c_char,
    args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    sqlite3_free((*pTab).base.zErrMsg as *mut libc::c_void);
    (*pTab).base.zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn zipfileCursorErr(
    pCsr: *mut ZipfileCsr,
    zFmt: *const libc::c_char,
    args: ...
) {
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    sqlite3_free((*(*pCsr).base.pVtab).zErrMsg as *mut libc::c_void);
    (*(*pCsr).base.pVtab).zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn zipfileReadData(
    pFile: *mut FILE,
    aRead: *mut u8_0,
    nRead: libc::c_int,
    iOff: i64_0,
    pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut n: size_t = 0;
    fseek(pFile, iOff as libc::c_long, 0 as libc::c_int);
    n = fread(
        aRead as *mut libc::c_void,
        1 as libc::c_int as libc::c_ulong,
        nRead as libc::c_ulong,
        pFile,
    );
    if n as libc::c_int != nRead {
        *pzErrmsg = sqlite3_mprintf(
            b"error in fread()\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileAppendData(
    pTab: *mut ZipfileTab,
    aWrite: *const u8_0,
    nWrite: libc::c_int,
) -> libc::c_int {
    if nWrite > 0 as libc::c_int {
        let mut n: size_t = nWrite as size_t;
        fseek((*pTab).pWriteFd, (*pTab).szCurrent as libc::c_long, 0 as libc::c_int);
        n = fwrite(
            aWrite as *const libc::c_void,
            1 as libc::c_int as libc::c_ulong,
            nWrite as libc::c_ulong,
            (*pTab).pWriteFd,
        );
        if n as libc::c_int != nWrite {
            (*pTab)
                .base
                .zErrMsg = sqlite3_mprintf(
                b"error in fwrite()\0" as *const u8 as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        (*pTab).szCurrent += nWrite as libc::c_longlong;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileGetU16(aBuf: *const u8_0) -> u16_0 {
    return (((*aBuf.offset(1 as libc::c_int as isize) as libc::c_int)
        << 8 as libc::c_int) + *aBuf.offset(0 as libc::c_int as isize) as libc::c_int)
        as u16_0;
}
unsafe extern "C" fn zipfileGetU32(aBuf: *const u8_0) -> u32_0 {
    if aBuf.is_null() {
        return 0 as libc::c_int as u32_0;
    }
    return ((*aBuf.offset(3 as libc::c_int as isize) as u32_0) << 24 as libc::c_int)
        .wrapping_add(
            (*aBuf.offset(2 as libc::c_int as isize) as u32_0) << 16 as libc::c_int,
        )
        .wrapping_add(
            (*aBuf.offset(1 as libc::c_int as isize) as u32_0) << 8 as libc::c_int,
        )
        .wrapping_add(
            (*aBuf.offset(0 as libc::c_int as isize) as u32_0) << 0 as libc::c_int,
        );
}
unsafe extern "C" fn zipfilePutU16(aBuf: *mut u8_0, val: u16_0) {
    *aBuf
        .offset(
            0 as libc::c_int as isize,
        ) = (val as libc::c_int & 0xff as libc::c_int) as u8_0;
    *aBuf
        .offset(
            1 as libc::c_int as isize,
        ) = (val as libc::c_int >> 8 as libc::c_int & 0xff as libc::c_int) as u8_0;
}
unsafe extern "C" fn zipfilePutU32(aBuf: *mut u8_0, val: u32_0) {
    *aBuf
        .offset(
            0 as libc::c_int as isize,
        ) = (val & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf
        .offset(
            1 as libc::c_int as isize,
        ) = (val >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf
        .offset(
            2 as libc::c_int as isize,
        ) = (val >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf
        .offset(
            3 as libc::c_int as isize,
        ) = (val >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
unsafe extern "C" fn zipfileReadCDS(
    aBuf: *mut u8_0,
    pCDS: *mut ZipfileCDS,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = aBuf;
    aRead = aRead.offset(4 as libc::c_int as isize);
    let sig: u32_0 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sig != 0x2014b50 as libc::c_int as libc::c_uint {
        rc = 1 as libc::c_int;
    } else {
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS)
            .iVersionMadeBy = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS)
            .iVersionExtract = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).flags = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iCompression = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).mTime = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).mDate = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).crc32 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).szCompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS)
            .szUncompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        if aRead == &mut *aBuf.offset(28 as libc::c_int as isize) as *mut u8_0 {} else {
            __assert_fail(
                b"aRead==&aBuf[ZIPFILE_CDS_NFILE_OFF]\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9126 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 39],
                    &[libc::c_char; 39],
                >(b"int zipfileReadCDS(u8 *, ZipfileCDS *)\0"))
                    .as_ptr(),
            );
        }
        'c_44227: {
            if aRead == &mut *aBuf.offset(28 as libc::c_int as isize) as *mut u8_0
            {} else {
                __assert_fail(
                    b"aRead==&aBuf[ZIPFILE_CDS_NFILE_OFF]\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    9126 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 39],
                        &[libc::c_char; 39],
                    >(b"int zipfileReadCDS(u8 *, ZipfileCDS *)\0"))
                        .as_ptr(),
                );
            }
        };
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nFile = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nExtra = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nComment = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iDiskStart = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS)
            .iInternalAttr = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS)
            .iExternalAttr = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).iOffset = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        if aRead == &mut *aBuf.offset(46 as libc::c_int as isize) as *mut u8_0 {} else {
            __assert_fail(
                b"aRead==&aBuf[ZIPFILE_CDS_FIXED_SZ]\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9134 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 39],
                    &[libc::c_char; 39],
                >(b"int zipfileReadCDS(u8 *, ZipfileCDS *)\0"))
                    .as_ptr(),
            );
        }
        'c_44057: {
            if aRead == &mut *aBuf.offset(46 as libc::c_int as isize) as *mut u8_0
            {} else {
                __assert_fail(
                    b"aRead==&aBuf[ZIPFILE_CDS_FIXED_SZ]\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    9134 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 39],
                        &[libc::c_char; 39],
                    >(b"int zipfileReadCDS(u8 *, ZipfileCDS *)\0"))
                        .as_ptr(),
                );
            }
        };
    }
    return rc;
}
unsafe extern "C" fn zipfileReadLFH(
    aBuffer: *mut u8_0,
    pLFH: *mut ZipfileLFH,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = aBuffer;
    let mut rc: libc::c_int = 0 as libc::c_int;
    aRead = aRead.offset(4 as libc::c_int as isize);
    let sig: u32_0 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    if sig != 0x4034b50 as libc::c_int as libc::c_uint {
        rc = 1 as libc::c_int;
    } else {
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH)
            .iVersionExtract = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).flags = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).iCompression = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).mTime = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).mDate = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).crc32 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).szCompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH)
            .szUncompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).nFile = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).nExtra = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
    }
    return rc;
}
unsafe extern "C" fn zipfileScanExtra(
    aExtra: *mut u8_0,
    nExtra: libc::c_int,
    pmTime: *mut u32_0,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut p: *mut u8_0 = aExtra;
    let pEnd: *mut u8_0 = &mut *aExtra.offset(nExtra as isize) as *mut u8_0;
    while p < pEnd {
        p = p.offset(2 as libc::c_int as isize);
        let id: u16_0 = zipfileGetU16(p.offset(-(2 as libc::c_int as isize)));
        p = p.offset(2 as libc::c_int as isize);
        let nByte: u16_0 = zipfileGetU16(p.offset(-(2 as libc::c_int as isize)));
        match id as libc::c_int {
            21589 => {
                let b: u8_0 = *p.offset(0 as libc::c_int as isize);
                if b as libc::c_int & 0x1 as libc::c_int != 0 {
                    *pmTime = zipfileGetU32(&mut *p.offset(1 as libc::c_int as isize));
                    ret = 1 as libc::c_int;
                }
            }
            _ => {}
        }
        p = p.offset(nByte as libc::c_int as isize);
    }
    return ret;
}
unsafe extern "C" fn zipfileMtime(pCDS: *mut ZipfileCDS) -> u32_0 {
    let mut Y: libc::c_int = 0;
    let mut M: libc::c_int = 0;
    let mut D: libc::c_int = 0;
    let mut X1: libc::c_int = 0;
    let mut X2: libc::c_int = 0;
    let mut A: libc::c_int = 0;
    let mut B: libc::c_int = 0;
    let mut sec: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut hr: libc::c_int = 0;
    let mut JDsec: i64_0 = 0;
    Y = 1980 as libc::c_int
        + ((*pCDS).mDate as libc::c_int >> 9 as libc::c_int & 0x7f as libc::c_int);
    M = (*pCDS).mDate as libc::c_int >> 5 as libc::c_int & 0xf as libc::c_int;
    D = (*pCDS).mDate as libc::c_int & 0x1f as libc::c_int;
    sec = ((*pCDS).mTime as libc::c_int & 0x1f as libc::c_int) * 2 as libc::c_int;
    min = (*pCDS).mTime as libc::c_int >> 5 as libc::c_int & 0x3f as libc::c_int;
    hr = (*pCDS).mTime as libc::c_int >> 11 as libc::c_int & 0x1f as libc::c_int;
    if M <= 2 as libc::c_int {
        Y -= 1;
        Y;
        M += 12 as libc::c_int;
    }
    X1 = 36525 as libc::c_int * (Y + 4716 as libc::c_int) / 100 as libc::c_int;
    X2 = 306001 as libc::c_int * (M + 1 as libc::c_int) / 10000 as libc::c_int;
    A = Y / 100 as libc::c_int;
    B = 2 as libc::c_int - A + A / 4 as libc::c_int;
    JDsec = (((X1 + X2 + D + B) as libc::c_double - 1524.5f64)
        * 86400 as libc::c_int as libc::c_double) as i64_0
        + (hr * 3600 as libc::c_int) as libc::c_longlong
        + (min * 60 as libc::c_int) as libc::c_longlong + sec as libc::c_longlong;
    return (JDsec - 24405875 as libc::c_int as i64_0 * 8640 as libc::c_int as i64_0)
        as u32_0;
}
unsafe extern "C" fn zipfileMtimeToDos(pCds: *mut ZipfileCDS, mUnixTime: u32_0) {
    let JD: i64_0 = 2440588 as libc::c_int as i64_0
        + mUnixTime
            .wrapping_div(
                (24 as libc::c_int * 60 as libc::c_int * 60 as libc::c_int)
                    as libc::c_uint,
            ) as libc::c_longlong;
    let mut A: libc::c_int = 0;
    let mut B: libc::c_int = 0;
    let mut C: libc::c_int = 0;
    let mut D: libc::c_int = 0;
    let mut E: libc::c_int = 0;
    let mut yr: libc::c_int = 0;
    let mut mon: libc::c_int = 0;
    let mut day: libc::c_int = 0;
    let mut hr: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut sec: libc::c_int = 0;
    A = ((JD as libc::c_double - 1867216.25f64) / 36524.25f64) as libc::c_int;
    A = (JD + 1 as libc::c_int as libc::c_longlong + A as libc::c_longlong
        - (A / 4 as libc::c_int) as libc::c_longlong) as libc::c_int;
    B = A + 1524 as libc::c_int;
    C = ((B as libc::c_double - 122.1f64) / 365.25f64) as libc::c_int;
    D = 36525 as libc::c_int * (C & 32767 as libc::c_int) / 100 as libc::c_int;
    E = ((B - D) as libc::c_double / 30.6001f64) as libc::c_int;
    day = B - D - (30.6001f64 * E as libc::c_double) as libc::c_int;
    mon = if E < 14 as libc::c_int {
        E - 1 as libc::c_int
    } else {
        E - 13 as libc::c_int
    };
    yr = if mon > 2 as libc::c_int {
        C - 4716 as libc::c_int
    } else {
        C - 4715 as libc::c_int
    };
    hr = mUnixTime
        .wrapping_rem(
            (24 as libc::c_int * 60 as libc::c_int * 60 as libc::c_int) as libc::c_uint,
        )
        .wrapping_div((60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        as libc::c_int;
    min = mUnixTime
        .wrapping_rem((60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        .wrapping_div(60 as libc::c_int as libc::c_uint) as libc::c_int;
    sec = mUnixTime.wrapping_rem(60 as libc::c_int as libc::c_uint) as libc::c_int;
    if yr >= 1980 as libc::c_int {
        (*pCds)
            .mDate = (day + (mon << 5 as libc::c_int)
            + ((yr - 1980 as libc::c_int) << 9 as libc::c_int)) as u16_0;
        (*pCds)
            .mTime = (sec / 2 as libc::c_int + (min << 5 as libc::c_int)
            + (hr << 11 as libc::c_int)) as u16_0;
    } else {
        (*pCds).mTime = 0 as libc::c_int as u16_0;
        (*pCds).mDate = (*pCds).mTime;
    }
    if mUnixTime < 315507600 as libc::c_int as libc::c_uint
        || mUnixTime == zipfileMtime(pCds)
        || mUnixTime.wrapping_rem(2 as libc::c_int as libc::c_uint) != 0
            && mUnixTime.wrapping_sub(1 as libc::c_int as libc::c_uint)
                == zipfileMtime(pCds)
    {} else {
        __assert_fail(
            b"mUnixTime<315507600 || mUnixTime==zipfileMtime(pCds) || ((mUnixTime % 2) && mUnixTime-1==zipfileMtime(pCds))\0"
                as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9288 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 42],
                &[libc::c_char; 42],
            >(b"void zipfileMtimeToDos(ZipfileCDS *, u32)\0"))
                .as_ptr(),
        );
    }
    'c_45011: {
        if mUnixTime < 315507600 as libc::c_int as libc::c_uint
            || mUnixTime == zipfileMtime(pCds)
            || mUnixTime.wrapping_rem(2 as libc::c_int as libc::c_uint) != 0
                && mUnixTime.wrapping_sub(1 as libc::c_int as libc::c_uint)
                    == zipfileMtime(pCds)
        {} else {
            __assert_fail(
                b"mUnixTime<315507600 || mUnixTime==zipfileMtime(pCds) || ((mUnixTime % 2) && mUnixTime-1==zipfileMtime(pCds))\0"
                    as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9288 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 42],
                    &[libc::c_char; 42],
                >(b"void zipfileMtimeToDos(ZipfileCDS *, u32)\0"))
                    .as_ptr(),
            );
        }
    };
}
unsafe extern "C" fn zipfileGetEntry(
    pTab: *mut ZipfileTab,
    aBlob: *const u8_0,
    _nBlob: libc::c_int,
    pFile: *mut FILE,
    iOff: i64_0,
    ppEntry: *mut *mut ZipfileEntry,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = 0 as *mut u8_0;
    let pzErr: *mut *mut libc::c_char = &mut (*pTab).base.zErrMsg;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if aBlob.is_null() {
        aRead = (*pTab).aBuffer;
        rc = zipfileReadData(pFile, aRead, 46 as libc::c_int, iOff, pzErr);
    } else {
        aRead = &*aBlob.offset(iOff as isize) as *const u8_0 as *mut u8_0;
    }
    if rc == 0 as libc::c_int {
        let mut nAlloc: sqlite3_int64 = 0;
        let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        let nFile: libc::c_int = zipfileGetU16(
            &mut *aRead.offset(28 as libc::c_int as isize),
        ) as libc::c_int;
        let mut nExtra: libc::c_int = zipfileGetU16(
            &mut *aRead.offset((28 as libc::c_int + 2 as libc::c_int) as isize),
        ) as libc::c_int;
        nExtra
            += zipfileGetU16(
                &mut *aRead.offset((28 as libc::c_int + 4 as libc::c_int) as isize),
            ) as libc::c_int;
        nAlloc = (::core::mem::size_of::<ZipfileEntry>() as libc::c_ulong)
            .wrapping_add(nExtra as libc::c_ulong) as sqlite3_int64;
        if !aBlob.is_null() {
            nAlloc
                += zipfileGetU32(&mut *aRead.offset(20 as libc::c_int as isize))
                    as libc::c_longlong;
        }
        pNew = sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut ZipfileEntry;
        if pNew.is_null() {
            rc = 7 as libc::c_int;
        } else {
            memset(
                pNew as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
            );
            rc = zipfileReadCDS(aRead, &mut (*pNew).cds);
            if rc != 0 as libc::c_int {
                *pzErr = sqlite3_mprintf(
                    b"failed to read CDS at offset %lld\0" as *const u8
                        as *const libc::c_char,
                    iOff,
                );
            } else if aBlob.is_null() {
                rc = zipfileReadData(
                    pFile,
                    aRead,
                    nExtra + nFile,
                    iOff + 46 as libc::c_int as libc::c_longlong,
                    pzErr,
                );
            } else {
                aRead = &*aBlob
                    .offset((iOff + 46 as libc::c_int as libc::c_longlong) as isize)
                    as *const u8_0 as *mut u8_0;
            }
        }
        if rc == 0 as libc::c_int {
            let pt: *mut u32_0 = &mut (*pNew).mUnixTime;
            (*pNew)
                .cds
                .zFile = sqlite3_mprintf(
                b"%.*s\0" as *const u8 as *const libc::c_char,
                nFile,
                aRead,
            );
            (*pNew)
                .aExtra = &mut *pNew.offset(1 as libc::c_int as isize)
                as *mut ZipfileEntry as *mut u8_0;
            memcpy(
                (*pNew).aExtra as *mut libc::c_void,
                &mut *aRead.offset(nFile as isize) as *mut u8_0 as *const libc::c_void,
                nExtra as libc::c_ulong,
            );
            if ((*pNew).cds.zFile).is_null() {
                rc = 7 as libc::c_int;
            } else if 0 as libc::c_int
                == zipfileScanExtra(
                    &mut *aRead.offset(nFile as isize),
                    (*pNew).cds.nExtra as libc::c_int,
                    pt,
                )
            {
                (*pNew).mUnixTime = zipfileMtime(&mut (*pNew).cds);
            }
        }
        if rc == 0 as libc::c_int {
            static mut szFix: libc::c_int = 30 as libc::c_int;
            let mut lfh: ZipfileLFH = ZipfileLFH {
                iVersionExtract: 0,
                flags: 0,
                iCompression: 0,
                mTime: 0,
                mDate: 0,
                crc32: 0,
                szCompressed: 0,
                szUncompressed: 0,
                nFile: 0,
                nExtra: 0,
            };
            if !pFile.is_null() {
                rc = zipfileReadData(
                    pFile,
                    aRead,
                    szFix,
                    (*pNew).cds.iOffset as i64_0,
                    pzErr,
                );
            } else {
                aRead = &*aBlob.offset((*pNew).cds.iOffset as isize) as *const u8_0
                    as *mut u8_0;
            }
            if rc == 0 as libc::c_int {
                rc = zipfileReadLFH(aRead, &mut lfh);
            }
            if rc == 0 as libc::c_int {
                (*pNew)
                    .iDataOff = ((*pNew).cds.iOffset)
                    .wrapping_add(30 as libc::c_int as libc::c_uint) as i64_0;
                (*pNew).iDataOff
                    += (lfh.nFile as libc::c_int + lfh.nExtra as libc::c_int)
                        as libc::c_longlong;
                if !aBlob.is_null() && (*pNew).cds.szCompressed != 0 {
                    (*pNew)
                        .aData = &mut *((*pNew).aExtra).offset(nExtra as isize)
                        as *mut u8_0;
                    memcpy(
                        (*pNew).aData as *mut libc::c_void,
                        &*aBlob.offset((*pNew).iDataOff as isize) as *const u8_0
                            as *const libc::c_void,
                        (*pNew).cds.szCompressed as libc::c_ulong,
                    );
                }
            } else {
                *pzErr = sqlite3_mprintf(
                    b"failed to read LFH at offset %d\0" as *const u8
                        as *const libc::c_char,
                    (*pNew).cds.iOffset as libc::c_int,
                );
            }
        }
        if rc != 0 as libc::c_int {
            zipfileEntryFree(pNew);
        } else {
            *ppEntry = pNew;
        }
    }
    return rc;
}
unsafe extern "C" fn zipfileNext(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !((*pCsr).pFile).is_null() {
        let iEof: i64_0 = ((*pCsr).eocd.iOffset).wrapping_add((*pCsr).eocd.nSize)
            as i64_0;
        zipfileEntryFree((*pCsr).pCurrent);
        (*pCsr).pCurrent = 0 as *mut ZipfileEntry;
        if (*pCsr).iNextOff >= iEof {
            (*pCsr).bEof = 1 as libc::c_int as u8_0;
        } else {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            let pTab: *mut ZipfileTab = (*cur).pVtab as *mut ZipfileTab;
            rc = zipfileGetEntry(
                pTab,
                0 as *const u8_0,
                0 as libc::c_int,
                (*pCsr).pFile,
                (*pCsr).iNextOff,
                &mut p,
            );
            if rc == 0 as libc::c_int {
                (*pCsr).iNextOff += 46 as libc::c_int as libc::c_longlong;
                (*pCsr).iNextOff
                    += ((*p).cds.nExtra as libc::c_int + (*p).cds.nFile as libc::c_int
                        + (*p).cds.nComment as libc::c_int) as libc::c_longlong;
            }
            (*pCsr).pCurrent = p;
        }
    } else {
        if (*pCsr).bNoop == 0 {
            (*pCsr).pCurrent = (*(*pCsr).pCurrent).pNext;
        }
        if ((*pCsr).pCurrent).is_null() {
            (*pCsr).bEof = 1 as libc::c_int as u8_0;
        }
    }
    (*pCsr).bNoop = 0 as libc::c_int as u8_0;
    return rc;
}
unsafe extern "C" fn zipfileFree(p: *mut libc::c_void) {
    sqlite3_free(p);
}
unsafe extern "C" fn zipfileInflate(
    pCtx: *mut sqlite3_context,
    aIn: *const u8_0,
    nIn: libc::c_int,
    nOut: libc::c_int,
) {
    let mut aRes: *mut u8_0 = sqlite3_malloc(nOut) as *mut u8_0;
    if aRes.is_null() {
        sqlite3_result_error_nomem(pCtx);
    } else {
        let mut err: libc::c_int = 0;
        let mut str: z_stream = z_stream {
            next_in: 0 as *mut Bytef,
            avail_in: 0,
            total_in: 0,
            next_out: 0 as *mut Bytef,
            avail_out: 0,
            total_out: 0,
            msg: 0 as *mut libc::c_char,
            state: 0 as *mut internal_state,
            zalloc: None,
            zfree: None,
            opaque: 0 as *mut libc::c_void,
            data_type: 0,
            adler: 0,
            reserved: 0,
        };
        memset(
            &mut str as *mut z_stream as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<z_stream>() as libc::c_ulong,
        );
        str.next_in = aIn as *mut Byte;
        str.avail_in = nIn as uInt;
        str.next_out = aRes as *mut Byte;
        str.avail_out = nOut as uInt;
        err = inflateInit2_(
            &mut str,
            -(15 as libc::c_int),
            b"1.2.11\0" as *const u8 as *const libc::c_char,
            ::core::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
        );
        if err != 0 as libc::c_int {
            zipfileCtxErrorMsg(
                pCtx,
                b"inflateInit2() failed (%d)\0" as *const u8 as *const libc::c_char,
                err,
            );
        } else {
            err = inflate(&mut str, 0 as libc::c_int);
            if err != 1 as libc::c_int {
                zipfileCtxErrorMsg(
                    pCtx,
                    b"inflate() failed (%d)\0" as *const u8 as *const libc::c_char,
                    err,
                );
            } else {
                sqlite3_result_blob(
                    pCtx,
                    aRes as *const libc::c_void,
                    nOut,
                    Some(zipfileFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
                );
                aRes = 0 as *mut u8_0;
            }
        }
        sqlite3_free(aRes as *mut libc::c_void);
        inflateEnd(&mut str);
    };
}
unsafe extern "C" fn zipfileDeflate(
    aIn: *const u8_0,
    nIn: libc::c_int,
    ppOut: *mut *mut u8_0,
    pnOut: *mut libc::c_int,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: sqlite3_int64 = 0;
    let mut str: z_stream = z_stream {
        next_in: 0 as *mut Bytef,
        avail_in: 0,
        total_in: 0,
        next_out: 0 as *mut Bytef,
        avail_out: 0,
        total_out: 0,
        msg: 0 as *mut libc::c_char,
        state: 0 as *mut internal_state,
        zalloc: None,
        zfree: None,
        opaque: 0 as *mut libc::c_void,
        data_type: 0,
        adler: 0,
        reserved: 0,
    };
    let mut aOut: *mut u8_0 = 0 as *mut u8_0;
    memset(
        &mut str as *mut z_stream as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<z_stream>() as libc::c_ulong,
    );
    str.next_in = aIn as *mut Bytef;
    str.avail_in = nIn as uInt;
    deflateInit2_(
        &mut str,
        9 as libc::c_int,
        8 as libc::c_int,
        -(15 as libc::c_int),
        8 as libc::c_int,
        0 as libc::c_int,
        b"1.2.11\0" as *const u8 as *const libc::c_char,
        ::core::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
    );
    nAlloc = deflateBound(&mut str, nIn as uLong) as sqlite3_int64;
    aOut = sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut u8_0;
    if aOut.is_null() {
        rc = 7 as libc::c_int;
    } else {
        let mut res: libc::c_int = 0;
        str.next_out = aOut;
        str.avail_out = nAlloc as uInt;
        res = deflate(&mut str, 4 as libc::c_int);
        if res == 1 as libc::c_int {
            *ppOut = aOut;
            *pnOut = str.total_out as libc::c_int;
        } else {
            sqlite3_free(aOut as *mut libc::c_void);
            *pzErr = sqlite3_mprintf(
                b"zipfile: deflate() error\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
        deflateEnd(&mut str);
    }
    return rc;
}
unsafe extern "C" fn zipfileColumn(
    cur: *mut sqlite3_vtab_cursor,
    ctx: *mut sqlite3_context,
    i: libc::c_int,
) -> libc::c_int {
    let pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let pCDS: *mut ZipfileCDS = &mut (*(*pCsr).pCurrent).cds;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let current_block_37: u64;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                (*pCDS).zFile,
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            current_block_37 = 18435049525520518667;
        }
        1 => {
            sqlite3_result_int(
                ctx,
                ((*pCDS).iExternalAttr >> 16 as libc::c_int) as libc::c_int,
            );
            current_block_37 = 18435049525520518667;
        }
        2 => {
            sqlite3_result_int64(ctx, (*(*pCsr).pCurrent).mUnixTime as sqlite3_int64);
            current_block_37 = 18435049525520518667;
        }
        3 => {
            if sqlite3_vtab_nochange(ctx) == 0 as libc::c_int {
                sqlite3_result_int64(ctx, (*pCDS).szUncompressed as sqlite3_int64);
            }
            current_block_37 = 18435049525520518667;
        }
        4 => {
            if sqlite3_vtab_nochange(ctx) != 0 {
                current_block_37 = 18435049525520518667;
            } else {
                current_block_37 = 13536709405535804910;
            }
        }
        5 => {
            current_block_37 = 13536709405535804910;
        }
        6 => {
            sqlite3_result_int(ctx, (*pCDS).iCompression as libc::c_int);
            current_block_37 = 18435049525520518667;
        }
        _ => {
            if i == 7 as libc::c_int {} else {
                __assert_fail(
                    b"i==7\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    9615 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 65],
                        &[libc::c_char; 65],
                    >(
                        b"int zipfileColumn(sqlite3_vtab_cursor *, sqlite3_context *, int)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_46499: {
                if i == 7 as libc::c_int {} else {
                    __assert_fail(
                        b"i==7\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        9615 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 65],
                            &[libc::c_char; 65],
                        >(
                            b"int zipfileColumn(sqlite3_vtab_cursor *, sqlite3_context *, int)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            sqlite3_result_int64(ctx, (*pCsr).iId);
            current_block_37 = 18435049525520518667;
        }
    }
    match current_block_37 {
        13536709405535804910 => {
            if i == 4 as libc::c_int
                || (*pCDS).iCompression as libc::c_int == 0 as libc::c_int
                || (*pCDS).iCompression as libc::c_int == 8 as libc::c_int
            {
                let sz: libc::c_int = (*pCDS).szCompressed as libc::c_int;
                let szFinal: libc::c_int = (*pCDS).szUncompressed as libc::c_int;
                if szFinal > 0 as libc::c_int {
                    let mut aBuf: *mut u8_0 = 0 as *mut u8_0;
                    let mut aFree: *mut u8_0 = 0 as *mut u8_0;
                    if !((*(*pCsr).pCurrent).aData).is_null() {
                        aBuf = (*(*pCsr).pCurrent).aData;
                    } else {
                        aFree = sqlite3_malloc64(sz as sqlite3_uint64) as *mut u8_0;
                        aBuf = aFree;
                        if aBuf.is_null() {
                            rc = 7 as libc::c_int;
                        } else {
                            let mut pFile: *mut FILE = (*pCsr).pFile;
                            if pFile.is_null() {
                                pFile = (*((*pCsr).base.pVtab as *mut ZipfileTab)).pWriteFd;
                            }
                            rc = zipfileReadData(
                                pFile,
                                aBuf,
                                sz,
                                (*(*pCsr).pCurrent).iDataOff,
                                &mut (*(*pCsr).base.pVtab).zErrMsg,
                            );
                        }
                    }
                    if rc == 0 as libc::c_int {
                        if i == 5 as libc::c_int
                            && (*pCDS).iCompression as libc::c_int != 0
                        {
                            zipfileInflate(ctx, aBuf, sz, szFinal);
                        } else {
                            sqlite3_result_blob(
                                ctx,
                                aBuf as *const libc::c_void,
                                sz,
                                ::core::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                    }
                    sqlite3_free(aFree as *mut libc::c_void);
                } else {
                    let mode: u32_0 = (*pCDS).iExternalAttr >> 16 as libc::c_int;
                    if mode & 0o40000 as libc::c_int as libc::c_uint == 0
                        && (*pCDS).nFile as libc::c_int >= 1 as libc::c_int
                        && *((*pCDS).zFile)
                            .offset(
                                ((*pCDS).nFile as libc::c_int - 1 as libc::c_int) as isize,
                            ) as libc::c_int != '/' as i32
                    {
                        sqlite3_result_blob(
                            ctx,
                            b"\0" as *const u8 as *const libc::c_char
                                as *const libc::c_void,
                            0 as libc::c_int,
                            None,
                        );
                    }
                }
            }
        }
        _ => {}
    }
    return rc;
}
unsafe extern "C" fn zipfileEof(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    return (*pCsr).bEof as libc::c_int;
}
unsafe extern "C" fn zipfileReadEOCD(
    pTab: *mut ZipfileTab,
    aBlob: *const u8_0,
    nBlob: libc::c_int,
    pFile: *mut FILE,
    pEOCD: *mut ZipfileEOCD,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = (*pTab).aBuffer;
    let mut nRead: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    memset(
        pEOCD as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ZipfileEOCD>() as libc::c_ulong,
    );
    if aBlob.is_null() {
        let mut iOff: i64_0 = 0;
        let mut szFile: i64_0 = 0;
        fseek(pFile, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        szFile = ftell(pFile) as i64_0;
        if szFile == 0 as libc::c_int as libc::c_longlong {
            return 0 as libc::c_int;
        }
        nRead = (if szFile
            < (64 as libc::c_int * 1024 as libc::c_int) as libc::c_longlong
        {
            szFile
        } else {
            (64 as libc::c_int * 1024 as libc::c_int) as libc::c_longlong
        }) as libc::c_int;
        iOff = szFile - nRead as libc::c_longlong;
        rc = zipfileReadData(pFile, aRead, nRead, iOff, &mut (*pTab).base.zErrMsg);
    } else {
        nRead = if nBlob < 64 as libc::c_int * 1024 as libc::c_int {
            nBlob
        } else {
            64 as libc::c_int * 1024 as libc::c_int
        };
        aRead = &*aBlob.offset((nBlob - nRead) as isize) as *const u8_0 as *mut u8_0;
    }
    if rc == 0 as libc::c_int {
        let mut i: libc::c_int = 0;
        i = nRead - 20 as libc::c_int;
        while i >= 0 as libc::c_int {
            if *aRead.offset(i as isize) as libc::c_int == 0x50 as libc::c_int
                && *aRead.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    == 0x4b as libc::c_int
                && *aRead.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                    == 0x5 as libc::c_int
                && *aRead.offset((i + 3 as libc::c_int) as isize) as libc::c_int
                    == 0x6 as libc::c_int
            {
                break;
            }
            i -= 1;
            i;
        }
        if i < 0 as libc::c_int {
            (*pTab)
                .base
                .zErrMsg = sqlite3_mprintf(
                b"cannot find end of central directory record\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        aRead = aRead.offset((i + 4 as libc::c_int) as isize);
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).iDisk = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).iFirstDisk = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).nEntry = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pEOCD).nEntryTotal = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pEOCD).nSize = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pEOCD).iOffset = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    }
    return rc;
}
unsafe extern "C" fn zipfileAddEntry(
    pTab: *mut ZipfileTab,
    pBefore: *mut ZipfileEntry,
    pNew: *mut ZipfileEntry,
) {
    if ((*pTab).pFirstEntry == 0 as *mut ZipfileEntry) as libc::c_int
        == ((*pTab).pLastEntry == 0 as *mut ZipfileEntry) as libc::c_int
    {} else {
        __assert_fail(
            b"(pTab->pFirstEntry==0)==(pTab->pLastEntry==0)\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9710 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 67],
                &[libc::c_char; 67],
            >(b"void zipfileAddEntry(ZipfileTab *, ZipfileEntry *, ZipfileEntry *)\0"))
                .as_ptr(),
        );
    }
    'c_47467: {
        if ((*pTab).pFirstEntry == 0 as *mut ZipfileEntry) as libc::c_int
            == ((*pTab).pLastEntry == 0 as *mut ZipfileEntry) as libc::c_int
        {} else {
            __assert_fail(
                b"(pTab->pFirstEntry==0)==(pTab->pLastEntry==0)\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9710 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 67],
                    &[libc::c_char; 67],
                >(
                    b"void zipfileAddEntry(ZipfileTab *, ZipfileEntry *, ZipfileEntry *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if ((*pNew).pNext).is_null() {} else {
        __assert_fail(
            b"pNew->pNext==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9711 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 67],
                &[libc::c_char; 67],
            >(b"void zipfileAddEntry(ZipfileTab *, ZipfileEntry *, ZipfileEntry *)\0"))
                .as_ptr(),
        );
    }
    'c_47424: {
        if ((*pNew).pNext).is_null() {} else {
            __assert_fail(
                b"pNew->pNext==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9711 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 67],
                    &[libc::c_char; 67],
                >(
                    b"void zipfileAddEntry(ZipfileTab *, ZipfileEntry *, ZipfileEntry *)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if pBefore.is_null() {
        if ((*pTab).pFirstEntry).is_null() {
            (*pTab).pLastEntry = pNew;
            (*pTab).pFirstEntry = (*pTab).pLastEntry;
        } else {
            if ((*(*pTab).pLastEntry).pNext).is_null() {} else {
                __assert_fail(
                    b"pTab->pLastEntry->pNext==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    9716 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 67],
                        &[libc::c_char; 67],
                    >(
                        b"void zipfileAddEntry(ZipfileTab *, ZipfileEntry *, ZipfileEntry *)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_47356: {
                if ((*(*pTab).pLastEntry).pNext).is_null() {} else {
                    __assert_fail(
                        b"pTab->pLastEntry->pNext==0\0" as *const u8
                            as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        9716 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 67],
                            &[libc::c_char; 67],
                        >(
                            b"void zipfileAddEntry(ZipfileTab *, ZipfileEntry *, ZipfileEntry *)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            (*(*pTab).pLastEntry).pNext = pNew;
            (*pTab).pLastEntry = pNew;
        }
    } else {
        let mut pp: *mut *mut ZipfileEntry = 0 as *mut *mut ZipfileEntry;
        pp = &mut (*pTab).pFirstEntry;
        while *pp != pBefore {
            pp = &mut (**pp).pNext;
        }
        (*pNew).pNext = pBefore;
        *pp = pNew;
    };
}
unsafe extern "C" fn zipfileLoadDirectory(
    pTab: *mut ZipfileTab,
    aBlob: *const u8_0,
    nBlob: libc::c_int,
) -> libc::c_int {
    let mut eocd: ZipfileEOCD = ZipfileEOCD {
        iDisk: 0,
        iFirstDisk: 0,
        nEntry: 0,
        nEntryTotal: 0,
        nSize: 0,
        iOffset: 0,
    };
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iOff: i64_0 = 0;
    rc = zipfileReadEOCD(pTab, aBlob, nBlob, (*pTab).pWriteFd, &mut eocd);
    iOff = eocd.iOffset as i64_0;
    i = 0 as libc::c_int;
    while rc == 0 as libc::c_int && i < eocd.nEntry as libc::c_int {
        let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        rc = zipfileGetEntry(pTab, aBlob, nBlob, (*pTab).pWriteFd, iOff, &mut pNew);
        if rc == 0 as libc::c_int {
            zipfileAddEntry(pTab, 0 as *mut ZipfileEntry, pNew);
            iOff += 46 as libc::c_int as libc::c_longlong;
            iOff
                += ((*pNew).cds.nExtra as libc::c_int + (*pNew).cds.nFile as libc::c_int
                    + (*pNew).cds.nComment as libc::c_int) as libc::c_longlong;
        }
        i += 1;
        i;
    }
    return rc;
}
unsafe extern "C" fn zipfileFilter(
    cur: *mut sqlite3_vtab_cursor,
    idxNum: libc::c_int,
    _idxStr: *const libc::c_char,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let pTab: *mut ZipfileTab = (*cur).pVtab as *mut ZipfileTab;
    let pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut bInMemory: libc::c_int = 0 as libc::c_int;
    zipfileResetCursor(pCsr);
    if !((*pTab).zFile).is_null() {
        zFile = (*pTab).zFile;
    } else if idxNum == 0 as libc::c_int {
        zipfileCursorErr(
            pCsr,
            b"zipfile() function requires an argument\0" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
        == 4 as libc::c_int
    {
        static mut aEmptyBlob: u8_0 = 0 as libc::c_int as u8_0;
        let mut aBlob: *const u8_0 = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const u8_0;
        let mut nBlob: libc::c_int = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        );
        if ((*pTab).pFirstEntry).is_null() {} else {
            __assert_fail(
                b"pTab->pFirstEntry==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9777 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 83],
                    &[libc::c_char; 83],
                >(
                    b"int zipfileFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
                ))
                    .as_ptr(),
            );
        }
        'c_47958: {
            if ((*pTab).pFirstEntry).is_null() {} else {
                __assert_fail(
                    b"pTab->pFirstEntry==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    9777 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 83],
                        &[libc::c_char; 83],
                    >(
                        b"int zipfileFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
                    ))
                        .as_ptr(),
                );
            }
        };
        if aBlob.is_null() {
            aBlob = &aEmptyBlob;
            nBlob = 0 as libc::c_int;
        }
        rc = zipfileLoadDirectory(pTab, aBlob, nBlob);
        (*pCsr).pFreeEntry = (*pTab).pFirstEntry;
        (*pTab).pLastEntry = 0 as *mut ZipfileEntry;
        (*pTab).pFirstEntry = (*pTab).pLastEntry;
        if rc != 0 as libc::c_int {
            return rc;
        }
        bInMemory = 1 as libc::c_int;
    } else {
        zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
            as *const libc::c_char;
    }
    if ((*pTab).pWriteFd).is_null() && 0 as libc::c_int == bInMemory {
        (*pCsr)
            .pFile = if !zFile.is_null() {
            fopen(zFile, b"rb\0" as *const u8 as *const libc::c_char)
        } else {
            0 as *mut FILE
        };
        if ((*pCsr).pFile).is_null() {
            zipfileCursorErr(
                pCsr,
                b"cannot open file: %s\0" as *const u8 as *const libc::c_char,
                zFile,
            );
            rc = 1 as libc::c_int;
        } else {
            rc = zipfileReadEOCD(
                pTab,
                0 as *const u8_0,
                0 as libc::c_int,
                (*pCsr).pFile,
                &mut (*pCsr).eocd,
            );
            if rc == 0 as libc::c_int {
                if (*pCsr).eocd.nEntry as libc::c_int == 0 as libc::c_int {
                    (*pCsr).bEof = 1 as libc::c_int as u8_0;
                } else {
                    (*pCsr).iNextOff = (*pCsr).eocd.iOffset as i64_0;
                    rc = zipfileNext(cur);
                }
            }
        }
    } else {
        (*pCsr).bNoop = 1 as libc::c_int as u8_0;
        (*pCsr)
            .pCurrent = if !((*pCsr).pFreeEntry).is_null() {
            (*pCsr).pFreeEntry
        } else {
            (*pTab).pFirstEntry
        };
        rc = zipfileNext(cur);
    }
    return rc;
}
unsafe extern "C" fn zipfileBestIndex(
    _tab: *mut sqlite3_vtab,
    pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = -(1 as libc::c_int);
    let mut unusable: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let pCons: *const sqlite3_index_constraint = &mut *((*pIdxInfo).aConstraint)
            .offset(i as isize) as *mut sqlite3_index_constraint;
        if !((*pCons).iColumn != 7 as libc::c_int) {
            if (*pCons).usable as libc::c_int == 0 as libc::c_int {
                unusable = 1 as libc::c_int;
            } else if (*pCons).op as libc::c_int == 2 as libc::c_int {
                idx = i;
            }
        }
        i += 1;
        i;
    }
    (*pIdxInfo).estimatedCost = 1000.0f64;
    if idx >= 0 as libc::c_int {
        (*((*pIdxInfo).aConstraintUsage).offset(idx as isize))
            .argvIndex = 1 as libc::c_int;
        (*((*pIdxInfo).aConstraintUsage).offset(idx as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*pIdxInfo).idxNum = 1 as libc::c_int;
    } else if unusable != 0 {
        return 19 as libc::c_int
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileNewEntry(
    zPath: *const libc::c_char,
) -> *mut ZipfileEntry {
    let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    pNew = sqlite3_malloc(
        ::core::mem::size_of::<ZipfileEntry>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileEntry;
    if !pNew.is_null() {
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
        );
        (*pNew)
            .cds
            .zFile = sqlite3_mprintf(b"%s\0" as *const u8 as *const libc::c_char, zPath);
        if ((*pNew).cds.zFile).is_null() {
            sqlite3_free(pNew as *mut libc::c_void);
            pNew = 0 as *mut ZipfileEntry;
        }
    }
    return pNew;
}
unsafe extern "C" fn zipfileSerializeLFH(
    pEntry: *mut ZipfileEntry,
    aBuf: *mut u8_0,
) -> libc::c_int {
    let pCds: *mut ZipfileCDS = &mut (*pEntry).cds;
    let mut a: *mut u8_0 = aBuf;
    (*pCds).nExtra = 9 as libc::c_int as u16_0;
    zipfilePutU32(a, 0x4034b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).iVersionExtract);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).flags);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).iCompression);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).mTime);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).mDate);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).crc32);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).szCompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).szUncompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).nFile);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).nExtra);
    a = a.offset(2 as libc::c_int as isize);
    if a == &mut *aBuf.offset(30 as libc::c_int as isize) as *mut u8_0 {} else {
        __assert_fail(
            b"a==&aBuf[ZIPFILE_LFH_FIXED_SZ]\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9880 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 46],
                &[libc::c_char; 46],
            >(b"int zipfileSerializeLFH(ZipfileEntry *, u8 *)\0"))
                .as_ptr(),
        );
    }
    'c_48364: {
        if a == &mut *aBuf.offset(30 as libc::c_int as isize) as *mut u8_0 {} else {
            __assert_fail(
                b"a==&aBuf[ZIPFILE_LFH_FIXED_SZ]\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9880 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 46],
                    &[libc::c_char; 46],
                >(b"int zipfileSerializeLFH(ZipfileEntry *, u8 *)\0"))
                    .as_ptr(),
            );
        }
    };
    memcpy(
        a as *mut libc::c_void,
        (*pCds).zFile as *const libc::c_void,
        (*pCds).nFile as libc::c_int as libc::c_ulong,
    );
    a = a.offset((*pCds).nFile as libc::c_int as isize);
    zipfilePutU16(a, 0x5455 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, 5 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    let fresh47 = a;
    a = a.offset(1);
    *fresh47 = 0x1 as libc::c_int as u8_0;
    zipfilePutU32(a, (*pEntry).mUnixTime);
    a = a.offset(4 as libc::c_int as isize);
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileAppendEntry(
    pTab: *mut ZipfileTab,
    pEntry: *mut ZipfileEntry,
    pData: *const u8_0,
    nData: libc::c_int,
) -> libc::c_int {
    let aBuf: *mut u8_0 = (*pTab).aBuffer;
    let mut nBuf: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    nBuf = zipfileSerializeLFH(pEntry, aBuf);
    rc = zipfileAppendData(pTab, aBuf, nBuf);
    if rc == 0 as libc::c_int {
        (*pEntry).iDataOff = (*pTab).szCurrent;
        rc = zipfileAppendData(pTab, pData, nData);
    }
    return rc;
}
unsafe extern "C" fn zipfileGetMode(
    pVal: *mut sqlite3_value,
    bIsDir: libc::c_int,
    pMode: *mut u32_0,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    let z: *const libc::c_char = sqlite3_value_text(pVal) as *const libc::c_char;
    let mut mode: u32_0 = 0 as libc::c_int as u32_0;
    if z.is_null() {
        mode = (if bIsDir != 0 {
            0o40000 as libc::c_int + 0o755 as libc::c_int
        } else {
            0o100000 as libc::c_int + 0o644 as libc::c_int
        }) as u32_0;
    } else if *z.offset(0 as libc::c_int as isize) as libc::c_int >= '0' as i32
        && *z.offset(0 as libc::c_int as isize) as libc::c_int <= '9' as i32
    {
        mode = sqlite3_value_int(pVal) as libc::c_uint;
    } else {
        let zTemplate: [libc::c_char; 11] = *::core::mem::transmute::<
            &[u8; 11],
            &[libc::c_char; 11],
        >(b"-rwxrwxrwx\0");
        let mut i: libc::c_int = 0;
        if strlen(z) != 10 as libc::c_int as libc::c_ulong {
            current_block = 11013874754328381039;
        } else {
            match *z.offset(0 as libc::c_int as isize) as libc::c_int {
                45 => {
                    current_block = 12607594691601134922;
                    match current_block {
                        15197600785943144413 => {
                            mode |= 0o120000 as libc::c_int as libc::c_uint;
                        }
                        11538569013431031416 => {
                            mode |= 0o40000 as libc::c_int as libc::c_uint;
                        }
                        _ => {
                            mode |= 0o100000 as libc::c_int as libc::c_uint;
                        }
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 6057473163062296781;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode
                                |= ((1 as libc::c_int) << 9 as libc::c_int - i)
                                    as libc::c_uint;
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 11013874754328381039;
                            break;
                        }
                        i += 1;
                        i;
                    }
                }
                100 => {
                    current_block = 11538569013431031416;
                    match current_block {
                        15197600785943144413 => {
                            mode |= 0o120000 as libc::c_int as libc::c_uint;
                        }
                        11538569013431031416 => {
                            mode |= 0o40000 as libc::c_int as libc::c_uint;
                        }
                        _ => {
                            mode |= 0o100000 as libc::c_int as libc::c_uint;
                        }
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 6057473163062296781;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode
                                |= ((1 as libc::c_int) << 9 as libc::c_int - i)
                                    as libc::c_uint;
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 11013874754328381039;
                            break;
                        }
                        i += 1;
                        i;
                    }
                }
                108 => {
                    current_block = 15197600785943144413;
                    match current_block {
                        15197600785943144413 => {
                            mode |= 0o120000 as libc::c_int as libc::c_uint;
                        }
                        11538569013431031416 => {
                            mode |= 0o40000 as libc::c_int as libc::c_uint;
                        }
                        _ => {
                            mode |= 0o100000 as libc::c_int as libc::c_uint;
                        }
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 6057473163062296781;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode
                                |= ((1 as libc::c_int) << 9 as libc::c_int - i)
                                    as libc::c_uint;
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 11013874754328381039;
                            break;
                        }
                        i += 1;
                        i;
                    }
                }
                _ => {
                    current_block = 11013874754328381039;
                }
            }
        }
        match current_block {
            6057473163062296781 => {}
            _ => {
                *pzErr = sqlite3_mprintf(
                    b"zipfile: parse error in mode: %s\0" as *const u8
                        as *const libc::c_char,
                    z,
                );
                return 1 as libc::c_int;
            }
        }
    }
    if (mode & 0o40000 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint) as libc::c_int == bIsDir
    {
        *pzErr = sqlite3_mprintf(
            b"zipfile: mode does not match data\0" as *const u8 as *const libc::c_char,
        );
        return 19 as libc::c_int;
    }
    *pMode = mode;
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileComparePath(
    zA: *const libc::c_char,
    zB: *const libc::c_char,
    mut nB: libc::c_int,
) -> libc::c_int {
    let mut nA: libc::c_int = strlen(zA) as libc::c_int;
    if nA > 0 as libc::c_int
        && *zA.offset((nA - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        nA -= 1;
        nA;
    }
    if nB > 0 as libc::c_int
        && *zB.offset((nB - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        nB -= 1;
        nB;
    }
    if nA == nB
        && memcmp(
            zA as *const libc::c_void,
            zB as *const libc::c_void,
            nA as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn zipfileBegin(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if ((*pTab).pWriteFd).is_null() {} else {
        __assert_fail(
            b"pTab->pWriteFd==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            9972 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 33],
                &[libc::c_char; 33],
            >(b"int zipfileBegin(sqlite3_vtab *)\0"))
                .as_ptr(),
        );
    }
    'c_49087: {
        if ((*pTab).pWriteFd).is_null() {} else {
            __assert_fail(
                b"pTab->pWriteFd==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                9972 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 33],
                    &[libc::c_char; 33],
                >(b"int zipfileBegin(sqlite3_vtab *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ((*pTab).zFile).is_null()
        || *((*pTab).zFile).offset(0 as libc::c_int as isize) as libc::c_int
            == 0 as libc::c_int
    {
        (*pTab)
            .base
            .zErrMsg = sqlite3_mprintf(
            b"zipfile: missing filename\0" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    }
    (*pTab)
        .pWriteFd = fopen((*pTab).zFile, b"ab+\0" as *const u8 as *const libc::c_char);
    if ((*pTab).pWriteFd).is_null() {
        (*pTab)
            .base
            .zErrMsg = sqlite3_mprintf(
            b"zipfile: failed to open file %s for writing\0" as *const u8
                as *const libc::c_char,
            (*pTab).zFile,
        );
        rc = 1 as libc::c_int;
    } else {
        fseek((*pTab).pWriteFd, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        (*pTab).szOrig = ftell((*pTab).pWriteFd) as i64_0;
        (*pTab).szCurrent = (*pTab).szOrig;
        rc = zipfileLoadDirectory(pTab, 0 as *const u8_0, 0 as libc::c_int);
    }
    if rc != 0 as libc::c_int {
        zipfileCleanupTransaction(pTab);
    }
    return rc;
}
unsafe extern "C" fn zipfileTime() -> u32_0 {
    let pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(0 as *const libc::c_char);
    let mut ret: u32_0 = 0;
    if pVfs.is_null() {
        return 0 as libc::c_int as u32_0;
    }
    if (*pVfs).iVersion >= 2 as libc::c_int && ((*pVfs).xCurrentTimeInt64).is_some() {
        let mut ms: i64_0 = 0;
        ((*pVfs).xCurrentTimeInt64).expect("non-null function pointer")(pVfs, &mut ms);
        ret = (ms / 1000 as libc::c_int as libc::c_longlong
            - 24405875 as libc::c_int as i64_0 * 8640 as libc::c_int as libc::c_longlong)
            as u32_0;
    } else {
        let mut day: libc::c_double = 0.;
        ((*pVfs).xCurrentTime).expect("non-null function pointer")(pVfs, &mut day);
        ret = ((day - 2440587.5f64) * 86400 as libc::c_int as libc::c_double) as u32_0;
    }
    return ret;
}
unsafe extern "C" fn zipfileGetTime(pVal: *mut sqlite3_value) -> u32_0 {
    if pVal.is_null() || sqlite3_value_type(pVal) == 5 as libc::c_int {
        return zipfileTime();
    }
    return sqlite3_value_int64(pVal) as u32_0;
}
unsafe extern "C" fn zipfileRemoveEntryFromList(
    pTab: *mut ZipfileTab,
    pOld: *mut ZipfileEntry,
) {
    if !pOld.is_null() {
        if (*pTab).pFirstEntry == pOld {
            (*pTab).pFirstEntry = (*pOld).pNext;
            if (*pTab).pLastEntry == pOld {
                (*pTab).pLastEntry = 0 as *mut ZipfileEntry;
            }
        } else {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            p = (*pTab).pFirstEntry;
            while !p.is_null() {
                if (*p).pNext == pOld {
                    (*p).pNext = (*pOld).pNext;
                    if (*pTab).pLastEntry == pOld {
                        (*pTab).pLastEntry = p;
                    }
                    break;
                } else {
                    p = (*p).pNext;
                }
            }
        }
        zipfileEntryFree(pOld);
    }
}
unsafe extern "C" fn zipfileUpdate(
    pVtab: *mut sqlite3_vtab,
    nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
    _pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut current_block: u64;
    let pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut mode: u32_0 = 0 as libc::c_int as u32_0;
    let mut mTime: u32_0 = 0 as libc::c_int as u32_0;
    let mut sz: i64_0 = 0 as libc::c_int as i64_0;
    let mut zPath: *const libc::c_char = 0 as *const libc::c_char;
    let mut nPath: libc::c_int = 0 as libc::c_int;
    let mut pData: *const u8_0 = 0 as *const u8_0;
    let mut nData: libc::c_int = 0 as libc::c_int;
    let mut iMethod: libc::c_int = 0 as libc::c_int;
    let mut pFree: *mut u8_0 = 0 as *mut u8_0;
    let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pOld: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pOld2: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut bUpdate: libc::c_int = 0 as libc::c_int;
    let mut bIsDir: libc::c_int = 0 as libc::c_int;
    let mut iCrc32: u32_0 = 0 as libc::c_int as u32_0;
    if ((*pTab).pWriteFd).is_null() {
        rc = zipfileBegin(pVtab);
        if rc != 0 as libc::c_int {
            return rc;
        }
    }
    if sqlite3_value_type(*apVal.offset(0 as libc::c_int as isize)) != 5 as libc::c_int {
        let zDelete: *const libc::c_char = sqlite3_value_text(
            *apVal.offset(0 as libc::c_int as isize),
        ) as *const libc::c_char;
        let nDelete: libc::c_int = strlen(zDelete) as libc::c_int;
        if nVal > 1 as libc::c_int {
            let zUpdate: *const libc::c_char = sqlite3_value_text(
                *apVal.offset(1 as libc::c_int as isize),
            ) as *const libc::c_char;
            if !zUpdate.is_null()
                && zipfileComparePath(zUpdate, zDelete, nDelete) != 0 as libc::c_int
            {
                bUpdate = 1 as libc::c_int;
            }
        }
        pOld = (*pTab).pFirstEntry;
        while !(zipfileComparePath((*pOld).cds.zFile, zDelete, nDelete)
            == 0 as libc::c_int)
        {
            if !((*pOld).pNext).is_null() {} else {
                __assert_fail(
                    b"pOld->pNext\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    10108 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 73],
                        &[libc::c_char; 73],
                    >(
                        b"int zipfileUpdate(sqlite3_vtab *, int, sqlite3_value **, sqlite_int64 *)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_50203: {
                if !((*pOld).pNext).is_null() {} else {
                    __assert_fail(
                        b"pOld->pNext\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        10108 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 73],
                            &[libc::c_char; 73],
                        >(
                            b"int zipfileUpdate(sqlite3_vtab *, int, sqlite3_value **, sqlite_int64 *)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            pOld = (*pOld).pNext;
        }
    }
    if nVal > 1 as libc::c_int {
        if sqlite3_value_type(*apVal.offset(5 as libc::c_int as isize))
            != 5 as libc::c_int
        {
            zipfileTableErr(
                pTab,
                b"sz must be NULL\0" as *const u8 as *const libc::c_char,
            );
            rc = 19 as libc::c_int;
        }
        if sqlite3_value_type(*apVal.offset(6 as libc::c_int as isize))
            != 5 as libc::c_int
        {
            zipfileTableErr(
                pTab,
                b"rawdata must be NULL\0" as *const u8 as *const libc::c_char,
            );
            rc = 19 as libc::c_int;
        }
        if rc == 0 as libc::c_int {
            if sqlite3_value_type(*apVal.offset(7 as libc::c_int as isize))
                == 5 as libc::c_int
            {
                bIsDir = 1 as libc::c_int;
            } else {
                let aIn: *const u8_0 = sqlite3_value_blob(
                    *apVal.offset(7 as libc::c_int as isize),
                ) as *const u8_0;
                let nIn: libc::c_int = sqlite3_value_bytes(
                    *apVal.offset(7 as libc::c_int as isize),
                );
                let bAuto: libc::c_int = (sqlite3_value_type(
                    *apVal.offset(8 as libc::c_int as isize),
                ) == 5 as libc::c_int) as libc::c_int;
                iMethod = sqlite3_value_int(*apVal.offset(8 as libc::c_int as isize));
                sz = nIn as i64_0;
                pData = aIn;
                nData = nIn;
                if iMethod != 0 as libc::c_int && iMethod != 8 as libc::c_int {
                    zipfileTableErr(
                        pTab,
                        b"unknown compression method: %d\0" as *const u8
                            as *const libc::c_char,
                        iMethod,
                    );
                    rc = 19 as libc::c_int;
                } else {
                    if bAuto != 0 || iMethod != 0 {
                        let mut nCmp: libc::c_int = 0;
                        rc = zipfileDeflate(
                            aIn,
                            nIn,
                            &mut pFree,
                            &mut nCmp,
                            &mut (*pTab).base.zErrMsg,
                        );
                        if rc == 0 as libc::c_int {
                            if iMethod != 0 || nCmp < nIn {
                                iMethod = 8 as libc::c_int;
                                pData = pFree;
                                nData = nCmp;
                            }
                        }
                    }
                    iCrc32 = crc32(0 as libc::c_int as uLong, aIn, nIn as uInt) as u32_0;
                }
            }
        }
        if rc == 0 as libc::c_int {
            rc = zipfileGetMode(
                *apVal.offset(3 as libc::c_int as isize),
                bIsDir,
                &mut mode,
                &mut (*pTab).base.zErrMsg,
            );
        }
        if rc == 0 as libc::c_int {
            zPath = sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize))
                as *const libc::c_char;
            if zPath.is_null() {
                zPath = b"\0" as *const u8 as *const libc::c_char;
            }
            nPath = strlen(zPath) as libc::c_int;
            mTime = zipfileGetTime(*apVal.offset(4 as libc::c_int as isize));
        }
        if rc == 0 as libc::c_int && bIsDir != 0 {
            if nPath <= 0 as libc::c_int
                || *zPath.offset((nPath - 1 as libc::c_int) as isize) as libc::c_int
                    != '/' as i32
            {
                zFree = sqlite3_mprintf(
                    b"%s/\0" as *const u8 as *const libc::c_char,
                    zPath,
                );
                zPath = zFree as *const libc::c_char;
                if zFree.is_null() {
                    rc = 7 as libc::c_int;
                    nPath = 0 as libc::c_int;
                } else {
                    nPath = strlen(zPath) as libc::c_int;
                }
            }
        }
        if (pOld.is_null() || bUpdate != 0) && rc == 0 as libc::c_int {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            p = (*pTab).pFirstEntry;
            loop {
                if p.is_null() {
                    current_block = 17485376261910781866;
                    break;
                }
                if zipfileComparePath((*p).cds.zFile, zPath, nPath) == 0 as libc::c_int {
                    match sqlite3_vtab_on_conflict((*pTab).db) {
                        2 => {
                            current_block = 10436599309501436525;
                            break;
                        }
                        5 => {
                            pOld2 = p;
                            current_block = 17485376261910781866;
                            break;
                        }
                        _ => {
                            zipfileTableErr(
                                pTab,
                                b"duplicate name: \"%s\"\0" as *const u8
                                    as *const libc::c_char,
                                zPath,
                            );
                            rc = 19 as libc::c_int;
                            current_block = 17485376261910781866;
                            break;
                        }
                    }
                } else {
                    p = (*p).pNext;
                }
            }
        } else {
            current_block = 17485376261910781866;
        }
        match current_block {
            10436599309501436525 => {}
            _ => {
                if rc == 0 as libc::c_int {
                    pNew = zipfileNewEntry(zPath);
                    if pNew.is_null() {
                        rc = 7 as libc::c_int;
                    } else {
                        (*pNew)
                            .cds
                            .iVersionMadeBy = (((3 as libc::c_int) << 8 as libc::c_int)
                            + 30 as libc::c_int) as u16_0;
                        (*pNew).cds.iVersionExtract = 20 as libc::c_int as u16_0;
                        (*pNew).cds.flags = 0x800 as libc::c_int as u16_0;
                        (*pNew).cds.iCompression = iMethod as u16_0;
                        zipfileMtimeToDos(&mut (*pNew).cds, mTime);
                        (*pNew).cds.crc32 = iCrc32;
                        (*pNew).cds.szCompressed = nData as u32_0;
                        (*pNew).cds.szUncompressed = sz as u32_0;
                        (*pNew).cds.iExternalAttr = mode << 16 as libc::c_int;
                        (*pNew).cds.iOffset = (*pTab).szCurrent as u32_0;
                        (*pNew).cds.nFile = nPath as u16_0;
                        (*pNew).mUnixTime = mTime;
                        rc = zipfileAppendEntry(pTab, pNew, pData, nData);
                        zipfileAddEntry(pTab, pOld, pNew);
                    }
                }
                current_block = 17395932908762866334;
            }
        }
    } else {
        current_block = 17395932908762866334;
    }
    match current_block {
        17395932908762866334 => {
            if rc == 0 as libc::c_int && (!pOld.is_null() || !pOld2.is_null()) {
                let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
                pCsr = (*pTab).pCsrList;
                while !pCsr.is_null() {
                    if !((*pCsr).pCurrent).is_null()
                        && ((*pCsr).pCurrent == pOld || (*pCsr).pCurrent == pOld2)
                    {
                        (*pCsr).pCurrent = (*(*pCsr).pCurrent).pNext;
                        (*pCsr).bNoop = 1 as libc::c_int as u8_0;
                    }
                    pCsr = (*pCsr).pCsrNext;
                }
                zipfileRemoveEntryFromList(pTab, pOld);
                zipfileRemoveEntryFromList(pTab, pOld2);
            }
        }
        _ => {}
    }
    sqlite3_free(pFree as *mut libc::c_void);
    sqlite3_free(zFree as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn zipfileSerializeEOCD(
    p: *mut ZipfileEOCD,
    aBuf: *mut u8_0,
) -> libc::c_int {
    let mut a: *mut u8_0 = aBuf;
    zipfilePutU32(a, 0x6054b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*p).iDisk);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).iFirstDisk);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).nEntry);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).nEntryTotal);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*p).nSize);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*p).iOffset);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, 0 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileAppendEOCD(
    pTab: *mut ZipfileTab,
    p: *mut ZipfileEOCD,
) -> libc::c_int {
    let nBuf: libc::c_int = zipfileSerializeEOCD(p, (*pTab).aBuffer);
    if nBuf == 22 as libc::c_int {} else {
        __assert_fail(
            b"nBuf==ZIPFILE_EOCD_FIXED_SZ\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10270 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 51],
                &[libc::c_char; 51],
            >(b"int zipfileAppendEOCD(ZipfileTab *, ZipfileEOCD *)\0"))
                .as_ptr(),
        );
    }
    'c_50528: {
        if nBuf == 22 as libc::c_int {} else {
            __assert_fail(
                b"nBuf==ZIPFILE_EOCD_FIXED_SZ\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10270 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 51],
                    &[libc::c_char; 51],
                >(b"int zipfileAppendEOCD(ZipfileTab *, ZipfileEOCD *)\0"))
                    .as_ptr(),
            );
        }
    };
    return zipfileAppendData(pTab, (*pTab).aBuffer, nBuf);
}
unsafe extern "C" fn zipfileSerializeCDS(
    pEntry: *mut ZipfileEntry,
    aBuf: *mut u8_0,
) -> libc::c_int {
    let mut a: *mut u8_0 = aBuf;
    let pCDS: *mut ZipfileCDS = &mut (*pEntry).cds;
    if ((*pEntry).aExtra).is_null() {
        (*pCDS).nExtra = 9 as libc::c_int as u16_0;
    }
    zipfilePutU32(a, 0x2014b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iVersionMadeBy);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iVersionExtract);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).flags);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iCompression);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).mTime);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).mDate);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).crc32);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).szCompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).szUncompressed);
    a = a.offset(4 as libc::c_int as isize);
    if a == &mut *aBuf.offset(28 as libc::c_int as isize) as *mut u8_0 {} else {
        __assert_fail(
            b"a==&aBuf[ZIPFILE_CDS_NFILE_OFF]\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10296 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 46],
                &[libc::c_char; 46],
            >(b"int zipfileSerializeCDS(ZipfileEntry *, u8 *)\0"))
                .as_ptr(),
        );
    }
    'c_50879: {
        if a == &mut *aBuf.offset(28 as libc::c_int as isize) as *mut u8_0 {} else {
            __assert_fail(
                b"a==&aBuf[ZIPFILE_CDS_NFILE_OFF]\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10296 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 46],
                    &[libc::c_char; 46],
                >(b"int zipfileSerializeCDS(ZipfileEntry *, u8 *)\0"))
                    .as_ptr(),
            );
        }
    };
    zipfilePutU16(a, (*pCDS).nFile);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nExtra);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nComment);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iDiskStart);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iInternalAttr);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).iExternalAttr);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).iOffset);
    a = a.offset(4 as libc::c_int as isize);
    memcpy(
        a as *mut libc::c_void,
        (*pCDS).zFile as *const libc::c_void,
        (*pCDS).nFile as libc::c_ulong,
    );
    a = a.offset((*pCDS).nFile as libc::c_int as isize);
    if !((*pEntry).aExtra).is_null() {
        let n: libc::c_int = (*pCDS).nExtra as libc::c_int
            + (*pCDS).nComment as libc::c_int;
        memcpy(
            a as *mut libc::c_void,
            (*pEntry).aExtra as *const libc::c_void,
            n as libc::c_ulong,
        );
        a = a.offset(n as isize);
    } else {
        if (*pCDS).nExtra as libc::c_int == 9 as libc::c_int {} else {
            __assert_fail(
                b"pCDS->nExtra==9\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10313 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 46],
                    &[libc::c_char; 46],
                >(b"int zipfileSerializeCDS(ZipfileEntry *, u8 *)\0"))
                    .as_ptr(),
            );
        }
        'c_50675: {
            if (*pCDS).nExtra as libc::c_int == 9 as libc::c_int {} else {
                __assert_fail(
                    b"pCDS->nExtra==9\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    10313 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 46],
                        &[libc::c_char; 46],
                    >(b"int zipfileSerializeCDS(ZipfileEntry *, u8 *)\0"))
                        .as_ptr(),
                );
            }
        };
        zipfilePutU16(a, 0x5455 as libc::c_int as u16_0);
        a = a.offset(2 as libc::c_int as isize);
        zipfilePutU16(a, 5 as libc::c_int as u16_0);
        a = a.offset(2 as libc::c_int as isize);
        let fresh48 = a;
        a = a.offset(1);
        *fresh48 = 0x1 as libc::c_int as u8_0;
        zipfilePutU32(a, (*pEntry).mUnixTime);
        a = a.offset(4 as libc::c_int as isize);
    }
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileCommit(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !((*pTab).pWriteFd).is_null() {
        let iOffset: i64_0 = (*pTab).szCurrent;
        let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        let mut eocd: ZipfileEOCD = ZipfileEOCD {
            iDisk: 0,
            iFirstDisk: 0,
            nEntry: 0,
            nEntryTotal: 0,
            nSize: 0,
            iOffset: 0,
        };
        let mut nEntry: libc::c_int = 0 as libc::c_int;
        p = (*pTab).pFirstEntry;
        while rc == 0 as libc::c_int && !p.is_null() {
            let n: libc::c_int = zipfileSerializeCDS(p, (*pTab).aBuffer);
            rc = zipfileAppendData(pTab, (*pTab).aBuffer, n);
            nEntry += 1;
            nEntry;
            p = (*p).pNext;
        }
        eocd.iDisk = 0 as libc::c_int as u16_0;
        eocd.iFirstDisk = 0 as libc::c_int as u16_0;
        eocd.nEntry = nEntry as u16_0;
        eocd.nEntryTotal = nEntry as u16_0;
        eocd.nSize = ((*pTab).szCurrent - iOffset) as u32_0;
        eocd.iOffset = iOffset as u32_0;
        rc = zipfileAppendEOCD(pTab, &mut eocd);
        zipfileCleanupTransaction(pTab);
    }
    return rc;
}
unsafe extern "C" fn zipfileRollback(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    return zipfileCommit(pVtab);
}
unsafe extern "C" fn zipfileFindCursor(
    pTab: *mut ZipfileTab,
    iId: i64_0,
) -> *mut ZipfileCsr {
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    pCsr = (*pTab).pCsrList;
    while !pCsr.is_null() {
        if iId == (*pCsr).iId {
            break;
        }
        pCsr = (*pCsr).pCsrNext;
    }
    return pCsr;
}
unsafe extern "C" fn zipfileFunctionCds(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    let pTab: *mut ZipfileTab = sqlite3_user_data(context) as *mut ZipfileTab;
    if argc > 0 as libc::c_int {} else {
        __assert_fail(
            b"argc>0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10372 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 66],
                &[libc::c_char; 66],
            >(b"void zipfileFunctionCds(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_51437: {
        if argc > 0 as libc::c_int {} else {
            __assert_fail(
                b"argc>0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10372 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 66],
                    &[libc::c_char; 66],
                >(
                    b"void zipfileFunctionCds(sqlite3_context *, int, sqlite3_value **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    pCsr = zipfileFindCursor(
        pTab,
        sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize)),
    );
    if !pCsr.is_null() {
        let p: *mut ZipfileCDS = &mut (*(*pCsr).pCurrent).cds;
        let zRes: *mut libc::c_char = sqlite3_mprintf(
            b"{\"version-made-by\" : %u, \"version-to-extract\" : %u, \"flags\" : %u, \"compression\" : %u, \"time\" : %u, \"date\" : %u, \"crc32\" : %u, \"compressed-size\" : %u, \"uncompressed-size\" : %u, \"file-name-length\" : %u, \"extra-field-length\" : %u, \"file-comment-length\" : %u, \"disk-number-start\" : %u, \"internal-attr\" : %u, \"external-attr\" : %u, \"offset\" : %u }\0"
                as *const u8 as *const libc::c_char,
            (*p).iVersionMadeBy as u32_0,
            (*p).iVersionExtract as u32_0,
            (*p).flags as u32_0,
            (*p).iCompression as u32_0,
            (*p).mTime as u32_0,
            (*p).mDate as u32_0,
            (*p).crc32,
            (*p).szCompressed,
            (*p).szUncompressed,
            (*p).nFile as u32_0,
            (*p).nExtra as u32_0,
            (*p).nComment as u32_0,
            (*p).iDiskStart as u32_0,
            (*p).iInternalAttr as u32_0,
            (*p).iExternalAttr,
            (*p).iOffset,
        );
        if zRes.is_null() {
            sqlite3_result_error_nomem(context);
        } else {
            sqlite3_result_text(
                context,
                zRes,
                -(1 as libc::c_int),
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            sqlite3_free(zRes as *mut libc::c_void);
        }
    }
}
unsafe extern "C" fn zipfileFindFunction(
    pVtab: *mut sqlite3_vtab,
    _nArg: libc::c_int,
    zName: *const libc::c_char,
    pxFunc: *mut Option::<
        unsafe extern "C" fn(
            *mut sqlite3_context,
            libc::c_int,
            *mut *mut sqlite3_value,
        ) -> (),
    >,
    ppArg: *mut *mut libc::c_void,
) -> libc::c_int {
    if sqlite3_stricmp(b"zipfile_cds\0" as *const u8 as *const libc::c_char, zName)
        == 0 as libc::c_int
    {
        *pxFunc = Some(
            zipfileFunctionCds
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        );
        *ppArg = pVtab as *mut libc::c_void;
        return 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileBufferGrow(
    pBuf: *mut ZipfileBuffer,
    nByte: libc::c_int,
) -> libc::c_int {
    if (*pBuf).n + nByte > (*pBuf).nAlloc {
        let mut aNew: *mut u8_0 = 0 as *mut u8_0;
        let mut nNew: sqlite3_int64 = (if (*pBuf).n != 0 {
            (*pBuf).n * 2 as libc::c_int
        } else {
            512 as libc::c_int
        }) as sqlite3_int64;
        let nReq: libc::c_int = (*pBuf).n + nByte;
        while nNew < nReq as libc::c_longlong {
            nNew = nNew * 2 as libc::c_int as libc::c_longlong;
        }
        aNew = sqlite3_realloc64((*pBuf).a as *mut libc::c_void, nNew as sqlite3_uint64)
            as *mut u8_0;
        if aNew.is_null() {
            return 7 as libc::c_int;
        }
        (*pBuf).a = aNew;
        (*pBuf).nAlloc = nNew as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileStep(
    pCtx: *mut sqlite3_context,
    nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    let mut current_block: u64;
    let mut p: *mut ZipfileCtx = 0 as *mut ZipfileCtx;
    let mut e: ZipfileEntry = ZipfileEntry {
        cds: ZipfileCDS {
            iVersionMadeBy: 0,
            iVersionExtract: 0,
            flags: 0,
            iCompression: 0,
            mTime: 0,
            mDate: 0,
            crc32: 0,
            szCompressed: 0,
            szUncompressed: 0,
            nFile: 0,
            nExtra: 0,
            nComment: 0,
            iDiskStart: 0,
            iInternalAttr: 0,
            iExternalAttr: 0,
            iOffset: 0,
            zFile: 0 as *mut libc::c_char,
        },
        mUnixTime: 0,
        aExtra: 0 as *mut u8_0,
        iDataOff: 0,
        aData: 0 as *mut u8_0,
        pNext: 0 as *mut ZipfileEntry,
    };
    let mut pName: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pMode: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pMtime: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pData: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut pMethod: *mut sqlite3_value = 0 as *mut sqlite3_value;
    let mut bIsDir: libc::c_int = 0 as libc::c_int;
    let mut mode: u32_0 = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut iMethod: libc::c_int = -(1 as libc::c_int);
    let mut aData: *const u8_0 = 0 as *const u8_0;
    let mut nData: libc::c_int = 0 as libc::c_int;
    let mut szUncompressed: libc::c_int = 0 as libc::c_int;
    let mut aFree: *mut u8_0 = 0 as *mut u8_0;
    let mut iCrc32: u32_0 = 0 as libc::c_int as u32_0;
    let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nName: libc::c_int = 0 as libc::c_int;
    let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nByte: libc::c_int = 0;
    memset(
        &mut e as *mut ZipfileEntry as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
    );
    p = sqlite3_aggregate_context(
        pCtx,
        ::core::mem::size_of::<ZipfileCtx>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCtx;
    if p.is_null() {
        return;
    }
    if nVal != 2 as libc::c_int && nVal != 4 as libc::c_int && nVal != 5 as libc::c_int {
        zErr = sqlite3_mprintf(
            b"wrong number of arguments to function zipfile()\0" as *const u8
                as *const libc::c_char,
        );
        rc = 1 as libc::c_int;
    } else {
        pName = *apVal.offset(0 as libc::c_int as isize);
        if nVal == 2 as libc::c_int {
            pData = *apVal.offset(1 as libc::c_int as isize);
        } else {
            pMode = *apVal.offset(1 as libc::c_int as isize);
            pMtime = *apVal.offset(2 as libc::c_int as isize);
            pData = *apVal.offset(3 as libc::c_int as isize);
            if nVal == 5 as libc::c_int {
                pMethod = *apVal.offset(4 as libc::c_int as isize);
            }
        }
        zName = sqlite3_value_text(pName) as *mut libc::c_char;
        nName = sqlite3_value_bytes(pName);
        if zName.is_null() {
            zErr = sqlite3_mprintf(
                b"first argument to zipfile() must be non-NULL\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            if !pMethod.is_null() && 5 as libc::c_int != sqlite3_value_type(pMethod) {
                iMethod = sqlite3_value_int64(pMethod) as libc::c_int;
                if iMethod != 0 as libc::c_int && iMethod != 8 as libc::c_int {
                    zErr = sqlite3_mprintf(
                        b"illegal method value: %d\0" as *const u8
                            as *const libc::c_char,
                        iMethod,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 1890501112830710335;
                } else {
                    current_block = 7205609094909031804;
                }
            } else {
                current_block = 7205609094909031804;
            }
            match current_block {
                1890501112830710335 => {}
                _ => {
                    if sqlite3_value_type(pData) == 5 as libc::c_int {
                        bIsDir = 1 as libc::c_int;
                        iMethod = 0 as libc::c_int;
                        current_block = 1356832168064818221;
                    } else {
                        aData = sqlite3_value_blob(pData) as *const u8_0;
                        nData = sqlite3_value_bytes(pData);
                        szUncompressed = nData;
                        iCrc32 = crc32(0 as libc::c_int as uLong, aData, nData as uInt)
                            as u32_0;
                        if iMethod < 0 as libc::c_int || iMethod == 8 as libc::c_int {
                            let mut nOut: libc::c_int = 0 as libc::c_int;
                            rc = zipfileDeflate(
                                aData,
                                nData,
                                &mut aFree,
                                &mut nOut,
                                &mut zErr,
                            );
                            if rc != 0 as libc::c_int {
                                current_block = 1890501112830710335;
                            } else {
                                if iMethod == 8 as libc::c_int || nOut < nData {
                                    aData = aFree;
                                    nData = nOut;
                                    iMethod = 8 as libc::c_int;
                                } else {
                                    iMethod = 0 as libc::c_int;
                                }
                                current_block = 1356832168064818221;
                            }
                        } else {
                            current_block = 1356832168064818221;
                        }
                    }
                    match current_block {
                        1890501112830710335 => {}
                        _ => {
                            rc = zipfileGetMode(pMode, bIsDir, &mut mode, &mut zErr);
                            if !(rc != 0) {
                                e.mUnixTime = zipfileGetTime(pMtime);
                                if bIsDir == 0 as libc::c_int {
                                    if nName > 0 as libc::c_int
                                        && *zName.offset((nName - 1 as libc::c_int) as isize)
                                            as libc::c_int == '/' as i32
                                    {
                                        zErr = sqlite3_mprintf(
                                            b"non-directory name must not end with /\0" as *const u8
                                                as *const libc::c_char,
                                        );
                                        rc = 1 as libc::c_int;
                                        current_block = 1890501112830710335;
                                    } else {
                                        current_block = 6721012065216013753;
                                    }
                                } else if nName == 0 as libc::c_int
                                    || *zName.offset((nName - 1 as libc::c_int) as isize)
                                        as libc::c_int != '/' as i32
                                {
                                    zFree = sqlite3_mprintf(
                                        b"%s/\0" as *const u8 as *const libc::c_char,
                                        zName,
                                    );
                                    zName = zFree;
                                    if zName.is_null() {
                                        rc = 7 as libc::c_int;
                                        current_block = 1890501112830710335;
                                    } else {
                                        nName = strlen(zName) as libc::c_int;
                                        current_block = 6721012065216013753;
                                    }
                                } else {
                                    while nName > 1 as libc::c_int
                                        && *zName.offset((nName - 2 as libc::c_int) as isize)
                                            as libc::c_int == '/' as i32
                                    {
                                        nName -= 1;
                                        nName;
                                    }
                                    current_block = 6721012065216013753;
                                }
                                match current_block {
                                    1890501112830710335 => {}
                                    _ => {
                                        e
                                            .cds
                                            .iVersionMadeBy = (((3 as libc::c_int) << 8 as libc::c_int)
                                            + 30 as libc::c_int) as u16_0;
                                        e.cds.iVersionExtract = 20 as libc::c_int as u16_0;
                                        e.cds.flags = 0x800 as libc::c_int as u16_0;
                                        e.cds.iCompression = iMethod as u16_0;
                                        zipfileMtimeToDos(&mut e.cds, e.mUnixTime);
                                        e.cds.crc32 = iCrc32;
                                        e.cds.szCompressed = nData as u32_0;
                                        e.cds.szUncompressed = szUncompressed as u32_0;
                                        e.cds.iExternalAttr = mode << 16 as libc::c_int;
                                        e.cds.iOffset = (*p).body.n as u32_0;
                                        e.cds.nFile = nName as u16_0;
                                        e.cds.zFile = zName;
                                        nByte = 30 as libc::c_int + e.cds.nFile as libc::c_int
                                            + 9 as libc::c_int;
                                        rc = zipfileBufferGrow(&mut (*p).body, nByte);
                                        if !(rc != 0) {
                                            (*p).body.n
                                                += zipfileSerializeLFH(
                                                    &mut e,
                                                    &mut *((*p).body.a).offset((*p).body.n as isize),
                                                );
                                            if nData > 0 as libc::c_int {
                                                rc = zipfileBufferGrow(&mut (*p).body, nData);
                                                if rc != 0 {
                                                    current_block = 1890501112830710335;
                                                } else {
                                                    memcpy(
                                                        &mut *((*p).body.a).offset((*p).body.n as isize)
                                                            as *mut u8_0 as *mut libc::c_void,
                                                        aData as *const libc::c_void,
                                                        nData as libc::c_ulong,
                                                    );
                                                    (*p).body.n += nData;
                                                    current_block = 7419121793134201633;
                                                }
                                            } else {
                                                current_block = 7419121793134201633;
                                            }
                                            match current_block {
                                                1890501112830710335 => {}
                                                _ => {
                                                    nByte = 46 as libc::c_int + e.cds.nFile as libc::c_int
                                                        + 9 as libc::c_int;
                                                    rc = zipfileBufferGrow(&mut (*p).cds, nByte);
                                                    if !(rc != 0) {
                                                        (*p).cds.n
                                                            += zipfileSerializeCDS(
                                                                &mut e,
                                                                &mut *((*p).cds.a).offset((*p).cds.n as isize),
                                                            );
                                                        (*p).nEntry += 1;
                                                        (*p).nEntry;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    sqlite3_free(aFree as *mut libc::c_void);
    sqlite3_free(zFree as *mut libc::c_void);
    if rc != 0 {
        if !zErr.is_null() {
            sqlite3_result_error(pCtx, zErr, -(1 as libc::c_int));
        } else {
            sqlite3_result_error_code(pCtx, rc);
        }
    }
    sqlite3_free(zErr as *mut libc::c_void);
}
unsafe extern "C" fn zipfileFinal(pCtx: *mut sqlite3_context) {
    let mut p: *mut ZipfileCtx = 0 as *mut ZipfileCtx;
    let mut eocd: ZipfileEOCD = ZipfileEOCD {
        iDisk: 0,
        iFirstDisk: 0,
        nEntry: 0,
        nEntryTotal: 0,
        nSize: 0,
        iOffset: 0,
    };
    let mut nZip: sqlite3_int64 = 0;
    let mut aZip: *mut u8_0 = 0 as *mut u8_0;
    p = sqlite3_aggregate_context(
        pCtx,
        ::core::mem::size_of::<ZipfileCtx>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCtx;
    if p.is_null() {
        return;
    }
    if (*p).nEntry > 0 as libc::c_int {
        memset(
            &mut eocd as *mut ZipfileEOCD as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<ZipfileEOCD>() as libc::c_ulong,
        );
        eocd.nEntry = (*p).nEntry as u16_0;
        eocd.nEntryTotal = (*p).nEntry as u16_0;
        eocd.nSize = (*p).cds.n as u32_0;
        eocd.iOffset = (*p).body.n as u32_0;
        nZip = ((*p).body.n + (*p).cds.n + 22 as libc::c_int) as sqlite3_int64;
        aZip = sqlite3_malloc64(nZip as sqlite3_uint64) as *mut u8_0;
        if aZip.is_null() {
            sqlite3_result_error_nomem(pCtx);
        } else {
            memcpy(
                aZip as *mut libc::c_void,
                (*p).body.a as *const libc::c_void,
                (*p).body.n as libc::c_ulong,
            );
            memcpy(
                &mut *aZip.offset((*p).body.n as isize) as *mut u8_0
                    as *mut libc::c_void,
                (*p).cds.a as *const libc::c_void,
                (*p).cds.n as libc::c_ulong,
            );
            zipfileSerializeEOCD(
                &mut eocd,
                &mut *aZip.offset(((*p).body.n + (*p).cds.n) as isize),
            );
            sqlite3_result_blob(
                pCtx,
                aZip as *const libc::c_void,
                nZip as libc::c_int,
                Some(zipfileFree as unsafe extern "C" fn(*mut libc::c_void) -> ()),
            );
        }
    }
    sqlite3_free((*p).body.a as *mut libc::c_void);
    sqlite3_free((*p).cds.a as *mut libc::c_void);
}
unsafe extern "C" fn zipfileRegister(db: *mut sqlite3) -> libc::c_int {
    static mut zipfileModule: sqlite3_module = unsafe {
        {
            let init = sqlite3_module {
                iVersion: 1 as libc::c_int,
                xCreate: Some(
                    zipfileConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    zipfileConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    zipfileBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    zipfileDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    zipfileDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    zipfileOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    zipfileClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    zipfileFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    zipfileNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    zipfileEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    zipfileColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: None,
                xUpdate: Some(
                    zipfileUpdate
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: Some(
                    zipfileBegin
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xSync: None,
                xCommit: Some(
                    zipfileCommit
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xRollback: Some(
                    zipfileRollback
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xFindFunction: Some(
                    zipfileFindFunction
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *const libc::c_char,
                            *mut Option::<
                                unsafe extern "C" fn(
                                    *mut sqlite3_context,
                                    libc::c_int,
                                    *mut *mut sqlite3_value,
                                ) -> (),
                            >,
                            *mut *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"zipfile\0" as *const u8 as *const libc::c_char,
        &mut zipfileModule,
        0 as *mut libc::c_void,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_overload_function(
            db,
            b"zipfile_cds\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"zipfile\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int,
            0 as *mut libc::c_void,
            None,
            Some(
                zipfileStep
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(zipfileFinal as unsafe extern "C" fn(*mut sqlite3_context) -> ()),
        );
    }
    if ::core::mem::size_of::<i64_0>() as libc::c_ulong
        == 8 as libc::c_int as libc::c_ulong
    {} else {
        __assert_fail(
            b"sizeof(i64)==8\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10714 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 31],
                &[libc::c_char; 31],
            >(b"int zipfileRegister(sqlite3 *)\0"))
                .as_ptr(),
        );
    }
    'c_52899: {
        if ::core::mem::size_of::<i64_0>() as libc::c_ulong
            == 8 as libc::c_int as libc::c_ulong
        {} else {
            __assert_fail(
                b"sizeof(i64)==8\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10714 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 31],
                    &[libc::c_char; 31],
                >(b"int zipfileRegister(sqlite3 *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ::core::mem::size_of::<u32_0>() as libc::c_ulong
        == 4 as libc::c_int as libc::c_ulong
    {} else {
        __assert_fail(
            b"sizeof(u32)==4\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10715 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 31],
                &[libc::c_char; 31],
            >(b"int zipfileRegister(sqlite3 *)\0"))
                .as_ptr(),
        );
    }
    'c_52863: {
        if ::core::mem::size_of::<u32_0>() as libc::c_ulong
            == 4 as libc::c_int as libc::c_ulong
        {} else {
            __assert_fail(
                b"sizeof(u32)==4\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10715 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 31],
                    &[libc::c_char; 31],
                >(b"int zipfileRegister(sqlite3 *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ::core::mem::size_of::<u16_0>() as libc::c_ulong
        == 2 as libc::c_int as libc::c_ulong
    {} else {
        __assert_fail(
            b"sizeof(u16)==2\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10716 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 31],
                &[libc::c_char; 31],
            >(b"int zipfileRegister(sqlite3 *)\0"))
                .as_ptr(),
        );
    }
    'c_52827: {
        if ::core::mem::size_of::<u16_0>() as libc::c_ulong
            == 2 as libc::c_int as libc::c_ulong
        {} else {
            __assert_fail(
                b"sizeof(u16)==2\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10716 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 31],
                    &[libc::c_char; 31],
                >(b"int zipfileRegister(sqlite3 *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ::core::mem::size_of::<u8_0>() as libc::c_ulong
        == 1 as libc::c_int as libc::c_ulong
    {} else {
        __assert_fail(
            b"sizeof(u8)==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10717 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 31],
                &[libc::c_char; 31],
            >(b"int zipfileRegister(sqlite3 *)\0"))
                .as_ptr(),
        );
    }
    'c_52791: {
        if ::core::mem::size_of::<u8_0>() as libc::c_ulong
            == 1 as libc::c_int as libc::c_ulong
        {} else {
            __assert_fail(
                b"sizeof(u8)==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10717 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 31],
                    &[libc::c_char; 31],
                >(b"int zipfileRegister(sqlite3 *)\0"))
                    .as_ptr(),
            );
        }
    };
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_zipfile_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return zipfileRegister(db);
}
unsafe extern "C" fn sqlarCompressFunc(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    if argc == 1 as libc::c_int {} else {
        __assert_fail(
            b"argc==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10780 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 65],
                &[libc::c_char; 65],
            >(b"void sqlarCompressFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_53153: {
        if argc == 1 as libc::c_int {} else {
            __assert_fail(
                b"argc==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10780 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 65],
                    &[libc::c_char; 65],
                >(b"void sqlarCompressFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int {
        let pData: *const Bytef = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const Bytef;
        let nData: uLong = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        ) as uLong;
        let mut nOut: uLongf = compressBound(nData);
        let mut pOut: *mut Bytef = 0 as *mut Bytef;
        pOut = sqlite3_malloc(nOut as libc::c_int) as *mut Bytef;
        if pOut.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        } else {
            if 0 as libc::c_int != compress(pOut, &mut nOut, pData, nData) {
                sqlite3_result_error(
                    context,
                    b"error in compress()\0" as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                );
            } else if nOut < nData {
                sqlite3_result_blob(
                    context,
                    pOut as *const libc::c_void,
                    nOut as libc::c_int,
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            } else {
                sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
            }
            sqlite3_free(pOut as *mut libc::c_void);
        }
    } else {
        sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
    };
}
unsafe extern "C" fn sqlarUncompressFunc(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut nData: uLong = 0;
    let mut sz: uLongf = 0;
    if argc == 2 as libc::c_int {} else {
        __assert_fail(
            b"argc==2\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            10824 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 67],
                &[libc::c_char; 67],
            >(b"void sqlarUncompressFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_53329: {
        if argc == 2 as libc::c_int {} else {
            __assert_fail(
                b"argc==2\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                10824 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 67],
                    &[libc::c_char; 67],
                >(
                    b"void sqlarUncompressFunc(sqlite3_context *, int, sqlite3_value **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    sz = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize)) as uLongf;
    if sz <= 0 as libc::c_int as libc::c_ulong
        || {
            nData = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
                as uLong;
            sz == nData
        }
    {
        sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
    } else {
        let pData: *const Bytef = sqlite3_value_blob(
            *argv.offset(0 as libc::c_int as isize),
        ) as *const Bytef;
        let pOut: *mut Bytef = sqlite3_malloc(sz as libc::c_int) as *mut Bytef;
        if pOut.is_null() {
            sqlite3_result_error_nomem(context);
        } else if 0 as libc::c_int != uncompress(pOut, &mut sz, pData, nData) {
            sqlite3_result_error(
                context,
                b"error in uncompress()\0" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            sqlite3_result_blob(
                context,
                pOut as *const libc::c_void,
                sz as libc::c_int,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        sqlite3_free(pOut as *mut libc::c_void);
    };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_sqlar_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sqlar_compress\0" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sqlarCompressFunc
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sqlar_uncompress\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sqlarUncompressFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    return rc;
}
unsafe extern "C" fn idxMalloc(
    pRc: *mut libc::c_int,
    nByte: libc::c_int,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    if *pRc == 0 as libc::c_int {} else {
        __assert_fail(
            b"*pRc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11215 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 28],
                &[libc::c_char; 28],
            >(b"void *idxMalloc(int *, int)\0"))
                .as_ptr(),
        );
    }
    'c_54143: {
        if *pRc == 0 as libc::c_int {} else {
            __assert_fail(
                b"*pRc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11215 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 28],
                    &[libc::c_char; 28],
                >(b"void *idxMalloc(int *, int)\0"))
                    .as_ptr(),
            );
        }
    };
    if nByte > 0 as libc::c_int {} else {
        __assert_fail(
            b"nByte>0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11216 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 28],
                &[libc::c_char; 28],
            >(b"void *idxMalloc(int *, int)\0"))
                .as_ptr(),
        );
    }
    'c_54106: {
        if nByte > 0 as libc::c_int {} else {
            __assert_fail(
                b"nByte>0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11216 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 28],
                    &[libc::c_char; 28],
                >(b"void *idxMalloc(int *, int)\0"))
                    .as_ptr(),
            );
        }
    };
    pRet = sqlite3_malloc(nByte);
    if !pRet.is_null() {
        memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
    } else {
        *pRc = 7 as libc::c_int;
    }
    return pRet;
}
unsafe extern "C" fn idxHashInit(pHash: *mut IdxHash) {
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
unsafe extern "C" fn idxHashClear(pHash: *mut IdxHash) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1023 as libc::c_int {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pNext: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        pEntry = (*pHash).aHash[i as usize];
        while !pEntry.is_null() {
            pNext = (*pEntry).pHashNext;
            sqlite3_free((*pEntry).zVal2 as *mut libc::c_void);
            sqlite3_free(pEntry as *mut libc::c_void);
            pEntry = pNext;
        }
        i += 1;
        i;
    }
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
unsafe extern "C" fn idxHashString(
    z: *const libc::c_char,
    n: libc::c_int,
) -> libc::c_int {
    let mut ret: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < n {
        ret = ret
            .wrapping_add(
                (ret << 3 as libc::c_int)
                    .wrapping_add(*z.offset(i as isize) as libc::c_uchar as libc::c_uint),
            );
        i += 1;
        i;
    }
    return ret.wrapping_rem(1023 as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn idxHashAdd(
    pRc: *mut libc::c_int,
    pHash: *mut IdxHash,
    zKey: *const libc::c_char,
    zVal: *const libc::c_char,
) -> libc::c_int {
    let nKey: libc::c_int = strlen(zKey) as libc::c_int;
    let iHash: libc::c_int = idxHashString(zKey, nKey);
    let nVal: libc::c_int = if !zVal.is_null() {
        strlen(zVal) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    if iHash >= 0 as libc::c_int {} else {
        __assert_fail(
            b"iHash>=0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11278 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 61],
                &[libc::c_char; 61],
            >(b"int idxHashAdd(int *, IdxHash *, const char *, const char *)\0"))
                .as_ptr(),
        );
    }
    'c_57893: {
        if iHash >= 0 as libc::c_int {} else {
            __assert_fail(
                b"iHash>=0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11278 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 61],
                    &[libc::c_char; 61],
                >(b"int idxHashAdd(int *, IdxHash *, const char *, const char *)\0"))
                    .as_ptr(),
            );
        }
    };
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return 1 as libc::c_int;
        }
        pEntry = (*pEntry).pHashNext;
    }
    pEntry = idxMalloc(
        pRc,
        (::core::mem::size_of::<IdxHashEntry>() as libc::c_ulong)
            .wrapping_add(nKey as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(nVal as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxHashEntry;
    if !pEntry.is_null() {
        (*pEntry)
            .zKey = &mut *pEntry.offset(1 as libc::c_int as isize) as *mut IdxHashEntry
            as *mut libc::c_char;
        memcpy(
            (*pEntry).zKey as *mut libc::c_void,
            zKey as *const libc::c_void,
            nKey as libc::c_ulong,
        );
        if !zVal.is_null() {
            (*pEntry)
                .zVal = &mut *((*pEntry).zKey).offset((nKey + 1 as libc::c_int) as isize)
                as *mut libc::c_char;
            memcpy(
                (*pEntry).zVal as *mut libc::c_void,
                zVal as *const libc::c_void,
                nVal as libc::c_ulong,
            );
        }
        (*pEntry).pHashNext = (*pHash).aHash[iHash as usize];
        (*pHash).aHash[iHash as usize] = pEntry;
        (*pEntry).pNext = (*pHash).pFirst;
        (*pHash).pFirst = pEntry;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxHashFind(
    pHash: *mut IdxHash,
    zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *mut IdxHashEntry {
    let mut iHash: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    if nKey < 0 as libc::c_int {
        nKey = strlen(zKey) as libc::c_int;
    }
    iHash = idxHashString(zKey, nKey);
    if iHash >= 0 as libc::c_int {} else {
        __assert_fail(
            b"iHash>=0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11310 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"IdxHashEntry *idxHashFind(IdxHash *, const char *, int)\0"))
                .as_ptr(),
        );
    }
    'c_58050: {
        if iHash >= 0 as libc::c_int {} else {
            __assert_fail(
                b"iHash>=0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11310 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 56],
                    &[libc::c_char; 56],
                >(b"IdxHashEntry *idxHashFind(IdxHash *, const char *, int)\0"))
                    .as_ptr(),
            );
        }
    };
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return pEntry;
        }
        pEntry = (*pEntry).pHashNext;
    }
    return 0 as *mut IdxHashEntry;
}
unsafe extern "C" fn idxHashSearch(
    pHash: *mut IdxHash,
    zKey: *const libc::c_char,
    nKey: libc::c_int,
) -> *const libc::c_char {
    let pEntry: *mut IdxHashEntry = idxHashFind(pHash, zKey, nKey);
    if !pEntry.is_null() {
        return (*pEntry).zVal;
    }
    return 0 as *const libc::c_char;
}
unsafe extern "C" fn idxNewConstraint(
    pRc: *mut libc::c_int,
    zColl: *const libc::c_char,
) -> *mut IdxConstraint {
    let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let nColl: libc::c_int = strlen(zColl) as libc::c_int;
    if *pRc == 0 as libc::c_int {} else {
        __assert_fail(
            b"*pRc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11339 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 53],
                &[libc::c_char; 53],
            >(b"IdxConstraint *idxNewConstraint(int *, const char *)\0"))
                .as_ptr(),
        );
    }
    'c_55084: {
        if *pRc == 0 as libc::c_int {} else {
            __assert_fail(
                b"*pRc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11339 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 53],
                    &[libc::c_char; 53],
                >(b"IdxConstraint *idxNewConstraint(int *, const char *)\0"))
                    .as_ptr(),
            );
        }
    };
    pNew = idxMalloc(
        pRc,
        (::core::mem::size_of::<IdxConstraint>() as libc::c_ulong)
            .wrapping_mul(nColl as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxConstraint;
    if !pNew.is_null() {
        (*pNew)
            .zColl = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxConstraint
            as *mut libc::c_char;
        memcpy(
            (*pNew).zColl as *mut libc::c_void,
            zColl as *const libc::c_void,
            (nColl + 1 as libc::c_int) as libc::c_ulong,
        );
    }
    return pNew;
}
unsafe extern "C" fn idxDatabaseError(
    db: *mut sqlite3,
    pzErrmsg: *mut *mut libc::c_char,
) {
    *pzErrmsg = sqlite3_mprintf(
        b"%s\0" as *const u8 as *const libc::c_char,
        sqlite3_errmsg(db),
    );
}
unsafe extern "C" fn idxPrepareStmt(
    db: *mut sqlite3,
    ppStmt: *mut *mut sqlite3_stmt,
    pzErrmsg: *mut *mut libc::c_char,
    zSql: *const libc::c_char,
) -> libc::c_int {
    let rc: libc::c_int = sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        ppStmt,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int {
        *ppStmt = 0 as *mut sqlite3_stmt;
        idxDatabaseError(db, pzErrmsg);
    }
    return rc;
}
unsafe extern "C" fn idxPrintfPrepareStmt(
    db: *mut sqlite3,
    ppStmt: *mut *mut sqlite3_stmt,
    pzErrmsg: *mut *mut libc::c_char,
    zFmt: *const libc::c_char,
    args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    zSql = sqlite3_vmprintf(zFmt, ap.as_va_list());
    if zSql.is_null() {
        rc = 7 as libc::c_int;
    } else {
        rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn expertDequote(zIn: *const libc::c_char) -> *mut libc::c_char {
    let n: libc::c_int = strlen(zIn) as libc::c_int;
    let zRet: *mut libc::c_char = sqlite3_malloc(n) as *mut libc::c_char;
    if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32 {} else {
        __assert_fail(
            b"zIn[0]=='\\''\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11422 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 34],
                &[libc::c_char; 34],
            >(b"char *expertDequote(const char *)\0"))
                .as_ptr(),
        );
    }
    'c_55639: {
        if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32 {} else {
            __assert_fail(
                b"zIn[0]=='\\''\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11422 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 34],
                    &[libc::c_char; 34],
                >(b"char *expertDequote(const char *)\0"))
                    .as_ptr(),
            );
        }
    };
    if *zIn.offset((n - 1 as libc::c_int) as isize) as libc::c_int == '\'' as i32
    {} else {
        __assert_fail(
            b"zIn[n-1]=='\\''\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11423 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 34],
                &[libc::c_char; 34],
            >(b"char *expertDequote(const char *)\0"))
                .as_ptr(),
        );
    }
    'c_55589: {
        if *zIn.offset((n - 1 as libc::c_int) as isize) as libc::c_int == '\'' as i32
        {} else {
            __assert_fail(
                b"zIn[n-1]=='\\''\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11423 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 34],
                    &[libc::c_char; 34],
                >(b"char *expertDequote(const char *)\0"))
                    .as_ptr(),
            );
        }
    };
    if !zRet.is_null() {
        let mut iOut: libc::c_int = 0 as libc::c_int;
        let mut iIn: libc::c_int = 0 as libc::c_int;
        iIn = 1 as libc::c_int;
        while iIn < n - 1 as libc::c_int {
            if *zIn.offset(iIn as isize) as libc::c_int == '\'' as i32 {
                if *zIn.offset((iIn + 1 as libc::c_int) as isize) as libc::c_int
                    == '\'' as i32
                {} else {
                    __assert_fail(
                        b"zIn[iIn+1]=='\\''\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        11430 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 34],
                            &[libc::c_char; 34],
                        >(b"char *expertDequote(const char *)\0"))
                            .as_ptr(),
                    );
                }
                'c_55519: {
                    if *zIn.offset((iIn + 1 as libc::c_int) as isize) as libc::c_int
                        == '\'' as i32
                    {} else {
                        __assert_fail(
                            b"zIn[iIn+1]=='\\''\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            11430 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 34],
                                &[libc::c_char; 34],
                            >(b"char *expertDequote(const char *)\0"))
                                .as_ptr(),
                        );
                    }
                };
                iIn += 1;
                iIn;
            }
            let fresh49 = iOut;
            iOut = iOut + 1;
            *zRet.offset(fresh49 as isize) = *zIn.offset(iIn as isize);
            iIn += 1;
            iIn;
        }
        *zRet.offset(iOut as isize) = '\0' as i32 as libc::c_char;
    }
    return zRet;
}
unsafe extern "C" fn expertConnect(
    db: *mut sqlite3,
    pAux: *mut libc::c_void,
    argc: libc::c_int,
    argv: *const *const libc::c_char,
    ppVtab: *mut *mut sqlite3_vtab,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let pExpert: *mut sqlite3expert = pAux as *mut sqlite3expert;
    let mut p: *mut ExpertVtab = 0 as *mut ExpertVtab;
    let mut rc: libc::c_int = 0;
    if argc != 4 as libc::c_int {
        *pzErr = sqlite3_mprintf(
            b"internal error!\0" as *const u8 as *const libc::c_char,
        );
        rc = 1 as libc::c_int;
    } else {
        let zCreateTable: *mut libc::c_char = expertDequote(
            *argv.offset(3 as libc::c_int as isize),
        );
        if !zCreateTable.is_null() {
            rc = sqlite3_declare_vtab(db, zCreateTable);
            if rc == 0 as libc::c_int {
                p = idxMalloc(
                    &mut rc,
                    ::core::mem::size_of::<ExpertVtab>() as libc::c_ulong as libc::c_int,
                ) as *mut ExpertVtab;
            }
            if rc == 0 as libc::c_int {
                (*p).pExpert = pExpert;
                (*p).pTab = (*pExpert).pTable;
                if sqlite3_stricmp(
                    (*(*p).pTab).zName,
                    *argv.offset(2 as libc::c_int as isize),
                ) == 0 as libc::c_int
                {} else {
                    __assert_fail(
                        b"sqlite3_stricmp(p->pTab->zName, argv[2])==0\0" as *const u8
                            as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        11474 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 89],
                            &[libc::c_char; 89],
                        >(
                            b"int expertConnect(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_55689: {
                    if sqlite3_stricmp(
                        (*(*p).pTab).zName,
                        *argv.offset(2 as libc::c_int as isize),
                    ) == 0 as libc::c_int
                    {} else {
                        __assert_fail(
                            b"sqlite3_stricmp(p->pTab->zName, argv[2])==0\0" as *const u8
                                as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            11474 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 89],
                                &[libc::c_char; 89],
                            >(
                                b"int expertConnect(sqlite3 *, void *, int, const char *const *, sqlite3_vtab **, char **)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
            }
            sqlite3_free(zCreateTable as *mut libc::c_void);
        } else {
            rc = 7 as libc::c_int;
        }
    }
    *ppVtab = p as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn expertDisconnect(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    sqlite3_free(p as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertBestIndex(
    pVtab: *mut sqlite3_vtab,
    pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pScan: *mut IdxScan = 0 as *mut IdxScan;
    let opmask: libc::c_int = 2 as libc::c_int | 4 as libc::c_int | 16 as libc::c_int
        | 32 as libc::c_int | 8 as libc::c_int;
    pScan = idxMalloc(
        &mut rc,
        ::core::mem::size_of::<IdxScan>() as libc::c_ulong as libc::c_int,
    ) as *mut IdxScan;
    if !pScan.is_null() {
        let mut i: libc::c_int = 0;
        (*pScan).pTab = (*p).pTab;
        (*pScan).pNextScan = (*(*p).pExpert).pScan;
        (*(*p).pExpert).pScan = pScan;
        i = 0 as libc::c_int;
        while i < (*pIdxInfo).nConstraint {
            let pCons: *mut sqlite3_index_constraint = &mut *((*pIdxInfo)
                .aConstraint)
                .offset(i as isize) as *mut sqlite3_index_constraint;
            if (*pCons).usable as libc::c_int != 0
                && (*pCons).iColumn >= 0 as libc::c_int
                && (*((*(*p).pTab).aCol).offset((*pCons).iColumn as isize)).iPk
                    == 0 as libc::c_int && (*pCons).op as libc::c_int & opmask != 0
            {
                let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
                let zColl: *const libc::c_char = sqlite3_vtab_collation(pIdxInfo, i);
                pNew = idxNewConstraint(&mut rc, zColl);
                if !pNew.is_null() {
                    (*pNew).iCol = (*pCons).iColumn;
                    if (*pCons).op as libc::c_int == 2 as libc::c_int {
                        (*pNew).pNext = (*pScan).pEq;
                        (*pScan).pEq = pNew;
                    } else {
                        (*pNew).bRange = 1 as libc::c_int;
                        (*pNew).pNext = (*pScan).pRange;
                        (*pScan).pRange = pNew;
                    }
                }
                n += 1;
                n;
                (*((*pIdxInfo).aConstraintUsage).offset(i as isize)).argvIndex = n;
            }
            i += 1;
            i;
        }
        i = (*pIdxInfo).nOrderBy - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let iCol: libc::c_int = (*((*pIdxInfo).aOrderBy).offset(i as isize))
                .iColumn;
            if iCol >= 0 as libc::c_int {
                let pNew_0: *mut IdxConstraint = idxNewConstraint(
                    &mut rc,
                    (*((*(*p).pTab).aCol).offset(iCol as isize)).zColl,
                );
                if !pNew_0.is_null() {
                    (*pNew_0).iCol = iCol;
                    (*pNew_0)
                        .bDesc = (*((*pIdxInfo).aOrderBy).offset(i as isize)).desc
                        as libc::c_int;
                    (*pNew_0).pNext = (*pScan).pOrder;
                    (*pNew_0).pLink = (*pScan).pOrder;
                    (*pScan).pOrder = pNew_0;
                    n += 1;
                    n;
                }
            }
            i -= 1;
            i;
        }
    }
    (*pIdxInfo).estimatedCost = 1000000.0f64 / (n + 1 as libc::c_int) as libc::c_double;
    return rc;
}
unsafe extern "C" fn expertUpdate(
    _pVtab: *mut sqlite3_vtab,
    _nData: libc::c_int,
    _azData: *mut *mut sqlite3_value,
    _pRowid: *mut sqlite_int64,
) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertOpen(
    _pVTab: *mut sqlite3_vtab,
    ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pCsr: *mut ExpertCsr = 0 as *mut ExpertCsr;
    pCsr = idxMalloc(
        &mut rc,
        ::core::mem::size_of::<ExpertCsr>() as libc::c_ulong as libc::c_int,
    ) as *mut ExpertCsr;
    *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
    return rc;
}
unsafe extern "C" fn expertClose(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    sqlite3_finalize((*pCsr).pData);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertEof(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    return ((*pCsr).pData == 0 as *mut sqlite3_stmt) as libc::c_int;
}
unsafe extern "C" fn expertNext(cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !((*pCsr).pData).is_null() {} else {
        __assert_fail(
            b"pCsr->pData\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11612 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 38],
                &[libc::c_char; 38],
            >(b"int expertNext(sqlite3_vtab_cursor *)\0"))
                .as_ptr(),
        );
    }
    'c_54537: {
        if !((*pCsr).pData).is_null() {} else {
            __assert_fail(
                b"pCsr->pData\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11612 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 38],
                    &[libc::c_char; 38],
                >(b"int expertNext(sqlite3_vtab_cursor *)\0"))
                    .as_ptr(),
            );
        }
    };
    rc = sqlite3_step((*pCsr).pData);
    if rc != 100 as libc::c_int {
        rc = sqlite3_finalize((*pCsr).pData);
        (*pCsr).pData = 0 as *mut sqlite3_stmt;
    } else {
        rc = 0 as libc::c_int;
    }
    return rc;
}
unsafe extern "C" fn expertRowid(
    _cur: *mut sqlite3_vtab_cursor,
    pRowid: *mut sqlite_int64,
) -> libc::c_int {
    *pRowid = 0 as libc::c_int as sqlite_int64;
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertColumn(
    cur: *mut sqlite3_vtab_cursor,
    ctx: *mut sqlite3_context,
    i: libc::c_int,
) -> libc::c_int {
    let pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVal: *mut sqlite3_value = 0 as *mut sqlite3_value;
    pVal = sqlite3_column_value((*pCsr).pData, i);
    if !pVal.is_null() {
        sqlite3_result_value(ctx, pVal);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertFilter(
    cur: *mut sqlite3_vtab_cursor,
    _idxNum: libc::c_int,
    _idxStr: *const libc::c_char,
    _argc: libc::c_int,
    _argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let pVtab: *mut ExpertVtab = (*cur).pVtab as *mut ExpertVtab;
    let pExpert: *mut sqlite3expert = (*pVtab).pExpert;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_finalize((*pCsr).pData);
    (*pCsr).pData = 0 as *mut sqlite3_stmt;
    if rc == 0 as libc::c_int {
        rc = idxPrintfPrepareStmt(
            (*pExpert).db,
            &mut (*pCsr).pData as *mut *mut sqlite3_stmt,
            &mut (*pVtab).base.zErrMsg as *mut *mut libc::c_char,
            b"SELECT * FROM main.%Q WHERE sample()\0" as *const u8
                as *const libc::c_char,
            (*(*pVtab).pTab).zName,
        );
    }
    if rc == 0 as libc::c_int {
        rc = expertNext(cur);
    }
    return rc;
}
unsafe extern "C" fn idxRegisterVtab(p: *mut sqlite3expert) -> libc::c_int {
    static mut expertModule: sqlite3_module = unsafe {
        {
            let init = sqlite3_module {
                iVersion: 2 as libc::c_int,
                xCreate: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    expertBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    expertDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    expertDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    expertOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    expertClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    expertFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    expertNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    expertEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    expertColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    expertRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: Some(
                    expertUpdate
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    return sqlite3_create_module(
        (*p).dbv,
        b"expert\0" as *const u8 as *const libc::c_char,
        &mut expertModule,
        p as *mut libc::c_void,
    );
}
unsafe extern "C" fn idxFinalize(
    pRc: *mut libc::c_int,
    pStmt: *mut sqlite3_stmt,
) {
    let rc: libc::c_int = sqlite3_finalize(pStmt);
    if *pRc == 0 as libc::c_int {
        *pRc = rc;
    }
}
unsafe extern "C" fn idxGetTableInfo(
    db: *mut sqlite3,
    zTab: *const libc::c_char,
    ppOut: *mut *mut IdxTable,
    pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut p1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nTab: libc::c_int = 0;
    let mut nByte: libc::c_int = 0;
    let mut pNew: *mut IdxTable = 0 as *mut IdxTable;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut pCsr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nPk: libc::c_int = 0 as libc::c_int;
    *ppOut = 0 as *mut IdxTable;
    if zTab.is_null() {
        return 1 as libc::c_int;
    }
    nTab = strlen(zTab) as libc::c_int;
    nByte = (::core::mem::size_of::<IdxTable>() as libc::c_ulong)
        .wrapping_add(nTab as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    rc = idxPrintfPrepareStmt(
        db,
        &mut p1 as *mut *mut sqlite3_stmt,
        pzErrmsg,
        b"PRAGMA table_xinfo=%Q\0" as *const u8 as *const libc::c_char,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let zCol: *const libc::c_char = sqlite3_column_text(p1, 1 as libc::c_int)
            as *const libc::c_char;
        let mut zColSeq: *const libc::c_char = 0 as *const libc::c_char;
        if zCol.is_null() {
            rc = 1 as libc::c_int;
            break;
        } else {
            nByte += 1 as libc::c_int + strlen(zCol) as libc::c_int;
            rc = sqlite3_table_column_metadata(
                db,
                b"main\0" as *const u8 as *const libc::c_char,
                zTab,
                zCol,
                0 as *mut *const libc::c_char,
                &mut zColSeq,
                0 as *mut libc::c_int,
                0 as *mut libc::c_int,
                0 as *mut libc::c_int,
            );
            if zColSeq.is_null() {
                zColSeq = b"binary\0" as *const u8 as *const libc::c_char;
            }
            nByte += 1 as libc::c_int + strlen(zColSeq) as libc::c_int;
            nCol += 1;
            nCol;
            nPk
                += (sqlite3_column_int(p1, 5 as libc::c_int) > 0 as libc::c_int)
                    as libc::c_int;
        }
    }
    rc2 = sqlite3_reset(p1);
    if rc == 0 as libc::c_int {
        rc = rc2;
    }
    nByte = (nByte as libc::c_ulong)
        .wrapping_add(
            (::core::mem::size_of::<IdxColumn>() as libc::c_ulong)
                .wrapping_mul(nCol as libc::c_ulong),
        ) as libc::c_int as libc::c_int;
    if rc == 0 as libc::c_int {
        pNew = idxMalloc(&mut rc, nByte) as *mut IdxTable;
    }
    if rc == 0 as libc::c_int {
        (*pNew)
            .aCol = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxTable
            as *mut IdxColumn;
        (*pNew).nCol = nCol;
        pCsr = &mut *((*pNew).aCol).offset(nCol as isize) as *mut IdxColumn
            as *mut libc::c_char;
    }
    nCol = 0 as libc::c_int;
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let zCol_0: *const libc::c_char = sqlite3_column_text(p1, 1 as libc::c_int)
            as *const libc::c_char;
        let mut zColSeq_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCopy: libc::c_int = 0;
        if zCol_0.is_null() {
            continue;
        }
        nCopy = strlen(zCol_0) as libc::c_int + 1 as libc::c_int;
        let ref mut fresh50 = (*((*pNew).aCol).offset(nCol as isize)).zName;
        *fresh50 = pCsr;
        (*((*pNew).aCol).offset(nCol as isize))
            .iPk = (sqlite3_column_int(p1, 5 as libc::c_int) == 1 as libc::c_int
            && nPk == 1 as libc::c_int) as libc::c_int;
        memcpy(
            pCsr as *mut libc::c_void,
            zCol_0 as *const libc::c_void,
            nCopy as libc::c_ulong,
        );
        pCsr = pCsr.offset(nCopy as isize);
        rc = sqlite3_table_column_metadata(
            db,
            b"main\0" as *const u8 as *const libc::c_char,
            zTab,
            zCol_0,
            0 as *mut *const libc::c_char,
            &mut zColSeq_0,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
        if rc == 0 as libc::c_int {
            if zColSeq_0.is_null() {
                zColSeq_0 = b"binary\0" as *const u8 as *const libc::c_char;
            }
            nCopy = strlen(zColSeq_0) as libc::c_int + 1 as libc::c_int;
            let ref mut fresh51 = (*((*pNew).aCol).offset(nCol as isize)).zColl;
            *fresh51 = pCsr;
            memcpy(
                pCsr as *mut libc::c_void,
                zColSeq_0 as *const libc::c_void,
                nCopy as libc::c_ulong,
            );
            pCsr = pCsr.offset(nCopy as isize);
        }
        nCol += 1;
        nCol;
    }
    idxFinalize(&mut rc, p1);
    if rc != 0 as libc::c_int {
        sqlite3_free(pNew as *mut libc::c_void);
        pNew = 0 as *mut IdxTable;
    } else if if !pNew.is_null() {
        1 as libc::c_int
    } else {
        __assert_fail(
            b"0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            11809 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 67],
                &[libc::c_char; 67],
            >(b"int idxGetTableInfo(sqlite3 *, const char *, IdxTable **, char **)\0"))
                .as_ptr(),
        );
        'c_56366: {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11809 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 67],
                    &[libc::c_char; 67],
                >(
                    b"int idxGetTableInfo(sqlite3 *, const char *, IdxTable **, char **)\0",
                ))
                    .as_ptr(),
            );
        };
        0 as libc::c_int
    } != 0
    {
        (*pNew).zName = pCsr;
        if if !((*pNew).zName).is_null() {
            1 as libc::c_int
        } else {
            __assert_fail(
                b"0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                11811 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 67],
                    &[libc::c_char; 67],
                >(
                    b"int idxGetTableInfo(sqlite3 *, const char *, IdxTable **, char **)\0",
                ))
                    .as_ptr(),
            );
            'c_56314: {
                __assert_fail(
                    b"0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    11811 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 67],
                        &[libc::c_char; 67],
                    >(
                        b"int idxGetTableInfo(sqlite3 *, const char *, IdxTable **, char **)\0",
                    ))
                        .as_ptr(),
                );
            };
            0 as libc::c_int
        } != 0
        {
            memcpy(
                (*pNew).zName as *mut libc::c_void,
                zTab as *const libc::c_void,
                (nTab + 1 as libc::c_int) as libc::c_ulong,
            );
        }
    }
    *ppOut = pNew;
    return rc;
}
unsafe extern "C" fn idxAppendText(
    pRc: *mut libc::c_int,
    zIn: *mut libc::c_char,
    zFmt: *const libc::c_char,
    args: ...
) -> *mut libc::c_char {
    let mut ap: ::core::ffi::VaListImpl;
    let mut zAppend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    let nIn: libc::c_int = if !zIn.is_null() {
        strlen(zIn) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut nAppend: libc::c_int = 0 as libc::c_int;
    ap = args.clone();
    if *pRc == 0 as libc::c_int {
        zAppend = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if !zAppend.is_null() {
            nAppend = strlen(zAppend) as libc::c_int;
            zRet = sqlite3_malloc(nIn + nAppend + 1 as libc::c_int) as *mut libc::c_char;
        }
        if !zAppend.is_null() && !zRet.is_null() {
            if nIn != 0 {
                memcpy(
                    zRet as *mut libc::c_void,
                    zIn as *const libc::c_void,
                    nIn as libc::c_ulong,
                );
            }
            memcpy(
                &mut *zRet.offset(nIn as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                zAppend as *const libc::c_void,
                (nAppend + 1 as libc::c_int) as libc::c_ulong,
            );
        } else {
            sqlite3_free(zRet as *mut libc::c_void);
            zRet = 0 as *mut libc::c_char;
            *pRc = 7 as libc::c_int;
        }
        sqlite3_free(zAppend as *mut libc::c_void);
        sqlite3_free(zIn as *mut libc::c_void);
    }
    return zRet;
}
unsafe extern "C" fn idxIdentifierRequiresQuotes(
    zId: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let nId: libc::c_int = strlen(zId) as libc::c_int;
    if sqlite3_keyword_check(zId, nId) != 0 {
        return 1 as libc::c_int;
    }
    i = 0 as libc::c_int;
    while *zId.offset(i as isize) != 0 {
        if !(*zId.offset(i as isize) as libc::c_int == '_' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= '0' as i32
                && *zId.offset(i as isize) as libc::c_int <= '9' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'a' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'z' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'A' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'Z' as i32)
        {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxAppendColDefn(
    pRc: *mut libc::c_int,
    zIn: *mut libc::c_char,
    pTab: *mut IdxTable,
    pCons: *mut IdxConstraint,
) -> *mut libc::c_char {
    let mut zRet: *mut libc::c_char = zIn;
    let p: *mut IdxColumn = &mut *((*pTab).aCol).offset((*pCons).iCol as isize)
        as *mut IdxColumn;
    if !zRet.is_null() {
        zRet = idxAppendText(pRc, zRet, b", \0" as *const u8 as *const libc::c_char);
    }
    if idxIdentifierRequiresQuotes((*p).zName) != 0 {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%Q\0" as *const u8 as *const libc::c_char,
            (*p).zName,
        );
    } else {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%s\0" as *const u8 as *const libc::c_char,
            (*p).zName,
        );
    }
    if sqlite3_stricmp((*p).zColl, (*pCons).zColl) != 0 {
        if idxIdentifierRequiresQuotes((*pCons).zColl) != 0 {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %Q\0" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            );
        } else {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %s\0" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            );
        }
    }
    if (*pCons).bDesc != 0 {
        zRet = idxAppendText(pRc, zRet, b" DESC\0" as *const u8 as *const libc::c_char);
    }
    return zRet;
}
unsafe extern "C" fn idxFindCompatible(
    pRc: *mut libc::c_int,
    dbm: *mut sqlite3,
    pScan: *mut IdxScan,
    pEq: *mut IdxConstraint,
    pTail: *mut IdxConstraint,
) -> libc::c_int {
    let zTbl: *const libc::c_char = (*(*pScan).pTab).zName;
    let mut pIdxList: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIter: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nEq: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0;
    pIter = pEq;
    while !pIter.is_null() {
        nEq += 1;
        nEq;
        pIter = (*pIter).pLink;
    }
    rc = idxPrintfPrepareStmt(
        dbm,
        &mut pIdxList as *mut *mut sqlite3_stmt,
        0 as *mut *mut libc::c_char,
        b"PRAGMA index_list=%Q\0" as *const u8 as *const libc::c_char,
        zTbl,
    );
    while rc == 0 as libc::c_int && sqlite3_step(pIdxList) == 100 as libc::c_int {
        let mut bMatch: libc::c_int = 1 as libc::c_int;
        let mut pT: *mut IdxConstraint = pTail;
        let mut pInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let zIdx: *const libc::c_char = sqlite3_column_text(
            pIdxList,
            1 as libc::c_int,
        ) as *const libc::c_char;
        if zIdx.is_null() {
            continue;
        }
        pIter = pEq;
        while !pIter.is_null() {
            (*pIter).bFlag = 0 as libc::c_int;
            pIter = (*pIter).pLink;
        }
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pInfo as *mut *mut sqlite3_stmt,
            0 as *mut *mut libc::c_char,
            b"PRAGMA index_xInfo=%Q\0" as *const u8 as *const libc::c_char,
            zIdx,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pInfo) == 100 as libc::c_int {
            let iIdx: libc::c_int = sqlite3_column_int(pInfo, 0 as libc::c_int);
            let iCol: libc::c_int = sqlite3_column_int(pInfo, 1 as libc::c_int);
            let zColl: *const libc::c_char = sqlite3_column_text(
                pInfo,
                4 as libc::c_int,
            ) as *const libc::c_char;
            if iIdx < nEq {
                pIter = pEq;
                while !pIter.is_null() {
                    if !((*pIter).bFlag != 0) {
                        if !((*pIter).iCol != iCol) {
                            if !(sqlite3_stricmp((*pIter).zColl, zColl) != 0) {
                                (*pIter).bFlag = 1 as libc::c_int;
                                break;
                            }
                        }
                    }
                    pIter = (*pIter).pLink;
                }
                if !pIter.is_null() {
                    continue;
                }
                bMatch = 0 as libc::c_int;
                break;
            } else {
                if pT.is_null() {
                    continue;
                }
                if (*pT).iCol != iCol || sqlite3_stricmp((*pT).zColl, zColl) != 0 {
                    bMatch = 0 as libc::c_int;
                    break;
                } else {
                    pT = (*pT).pLink;
                }
            }
        }
        idxFinalize(&mut rc, pInfo);
        if rc == 0 as libc::c_int && bMatch != 0 {
            sqlite3_finalize(pIdxList);
            return 1 as libc::c_int;
        }
    }
    idxFinalize(&mut rc, pIdxList);
    *pRc = rc;
    return 0 as libc::c_int;
}
unsafe extern "C" fn countNonzeros(
    pCount: *mut libc::c_void,
    nc: libc::c_int,
    azResults: *mut *mut libc::c_char,
    _azColumns: *mut *mut libc::c_char,
) -> libc::c_int {
    if nc > 0 as libc::c_int
        && (*(*azResults.offset(0 as libc::c_int as isize))
            .offset(0 as libc::c_int as isize) as libc::c_int != '0' as i32
            || *(*azResults.offset(0 as libc::c_int as isize))
                .offset(1 as libc::c_int as isize) as libc::c_int != 0 as libc::c_int)
    {
        *(pCount as *mut libc::c_int) += 1 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromCons(
    p: *mut sqlite3expert,
    pScan: *mut IdxScan,
    pEq: *mut IdxConstraint,
    pTail: *mut IdxConstraint,
) -> libc::c_int {
    let dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (!pEq.is_null() || !pTail.is_null())
        && 0 as libc::c_int == idxFindCompatible(&mut rc, dbm, pScan, pEq, pTail)
    {
        let pTab: *mut IdxTable = (*pScan).pTab;
        let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zIdx: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pCons: *mut IdxConstraint = 0 as *mut IdxConstraint;
        let mut h: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut zFmt: *const libc::c_char = 0 as *const libc::c_char;
        pCons = pEq;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink;
        }
        pCons = pTail;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink;
        }
        if rc == 0 as libc::c_int {
            let zTable: *const libc::c_char = (*(*pScan).pTab).zName;
            let quoteTable: libc::c_int = idxIdentifierRequiresQuotes(zTable);
            let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut collisions: libc::c_int = 0 as libc::c_int;
            loop {
                let mut i: libc::c_int = 0;
                let mut zFind: *mut libc::c_char = 0 as *mut libc::c_char;
                i = 0 as libc::c_int;
                while *zCols.offset(i as isize) != 0 {
                    h = h
                        .wrapping_add(
                            (h << 3 as libc::c_int)
                                .wrapping_add(*zCols.offset(i as isize) as libc::c_uint),
                        );
                    i += 1;
                    i;
                }
                sqlite3_free(zName as *mut libc::c_void);
                zName = sqlite3_mprintf(
                    b"%s_idx_%08x\0" as *const u8 as *const libc::c_char,
                    zTable,
                    h,
                );
                if zName.is_null() {
                    break;
                }
                zFmt = b"SELECT count(*) FROM sqlite_schema WHERE name=%Q AND type in ('index','table','view')\0"
                    as *const u8 as *const libc::c_char;
                zFind = sqlite3_mprintf(zFmt, zName);
                i = 0 as libc::c_int;
                rc = sqlite3_exec(
                    dbm,
                    zFind,
                    Some(
                        countNonzeros
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *mut *mut libc::c_char,
                                *mut *mut libc::c_char,
                            ) -> libc::c_int,
                    ),
                    &mut i as *mut libc::c_int as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                if rc == 0 as libc::c_int {} else {
                    __assert_fail(
                        b"rc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        12044 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 84],
                            &[libc::c_char; 84],
                        >(
                            b"int idxCreateFromCons(sqlite3expert *, IdxScan *, IdxConstraint *, IdxConstraint *)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_60814: {
                    if rc == 0 as libc::c_int {} else {
                        __assert_fail(
                            b"rc==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            12044 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 84],
                                &[libc::c_char; 84],
                            >(
                                b"int idxCreateFromCons(sqlite3expert *, IdxScan *, IdxConstraint *, IdxConstraint *)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                sqlite3_free(zFind as *mut libc::c_void);
                if i == 0 as libc::c_int {
                    collisions = 0 as libc::c_int;
                    break;
                } else {
                    collisions += 1;
                    collisions;
                    if !(collisions < 50 as libc::c_int && !zName.is_null()) {
                        break;
                    }
                }
            }
            if collisions != 0 {
                rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int;
            } else if zName.is_null() {
                rc = 7 as libc::c_int;
            } else {
                if quoteTable != 0 {
                    zFmt = b"CREATE INDEX \"%w\" ON \"%w\"(%s)\0" as *const u8
                        as *const libc::c_char;
                } else {
                    zFmt = b"CREATE INDEX %s ON %s(%s)\0" as *const u8
                        as *const libc::c_char;
                }
                zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
                if zIdx.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    rc = sqlite3_exec(
                        dbm,
                        zIdx,
                        None,
                        0 as *mut libc::c_void,
                        (*p).pzErrmsg,
                    );
                    if rc != 0 as libc::c_int {
                        rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int;
                    } else {
                        idxHashAdd(&mut rc, &mut (*p).hIdx, zName, zIdx);
                    }
                }
                sqlite3_free(zName as *mut libc::c_void);
                sqlite3_free(zIdx as *mut libc::c_void);
            }
        }
        sqlite3_free(zCols as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn idxFindConstraint(
    pList: *mut IdxConstraint,
    p: *mut IdxConstraint,
) -> libc::c_int {
    let mut pCmp: *mut IdxConstraint = 0 as *mut IdxConstraint;
    pCmp = pList;
    while !pCmp.is_null() {
        if (*p).iCol == (*pCmp).iCol {
            return 1 as libc::c_int;
        }
        pCmp = (*pCmp).pLink;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromWhere(
    p: *mut sqlite3expert,
    pScan: *mut IdxScan,
    pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut p1: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut pCon: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut rc: libc::c_int = 0;
    pCon = (*pScan).pEq;
    while !pCon.is_null() {
        if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
            (*pCon).pLink = p1;
            p1 = pCon;
        }
        pCon = (*pCon).pNext;
    }
    rc = idxCreateFromCons(p, pScan, p1, pTail);
    if pTail.is_null() {
        pCon = (*pScan).pRange;
        while rc == 0 as libc::c_int && !pCon.is_null() {
            if ((*pCon).pLink).is_null() {} else {
                __assert_fail(
                    b"pCon->pLink==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    12121 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 68],
                        &[libc::c_char; 68],
                    >(
                        b"int idxCreateFromWhere(sqlite3expert *, IdxScan *, IdxConstraint *)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_61620: {
                if ((*pCon).pLink).is_null() {} else {
                    __assert_fail(
                        b"pCon->pLink==0\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        12121 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 68],
                            &[libc::c_char; 68],
                        >(
                            b"int idxCreateFromWhere(sqlite3expert *, IdxScan *, IdxConstraint *)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
                rc = idxCreateFromCons(p, pScan, p1, pCon);
            }
            pCon = (*pCon).pNext;
        }
    }
    return rc;
}
unsafe extern "C" fn idxCreateCandidates(p: *mut sqlite3expert) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pIter: *mut IdxScan = 0 as *mut IdxScan;
    pIter = (*p).pScan;
    while !pIter.is_null() && rc == 0 as libc::c_int {
        rc = idxCreateFromWhere(p, pIter, 0 as *mut IdxConstraint);
        if rc == 0 as libc::c_int && !((*pIter).pOrder).is_null() {
            rc = idxCreateFromWhere(p, pIter, (*pIter).pOrder);
        }
        pIter = (*pIter).pNextScan;
    }
    return rc;
}
unsafe extern "C" fn idxConstraintFree(pConstraint: *mut IdxConstraint) {
    let mut pNext: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut p: *mut IdxConstraint = 0 as *mut IdxConstraint;
    p = pConstraint;
    while !p.is_null() {
        pNext = (*p).pNext;
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxScanFree(pScan: *mut IdxScan, pLast: *mut IdxScan) {
    let mut p: *mut IdxScan = 0 as *mut IdxScan;
    let mut pNext: *mut IdxScan = 0 as *mut IdxScan;
    p = pScan;
    while p != pLast {
        pNext = (*p).pNextScan;
        idxConstraintFree((*p).pOrder);
        idxConstraintFree((*p).pEq);
        idxConstraintFree((*p).pRange);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxStatementFree(
    pStatement: *mut IdxStatement,
    pLast: *mut IdxStatement,
) {
    let mut p: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut pNext: *mut IdxStatement = 0 as *mut IdxStatement;
    p = pStatement;
    while p != pLast {
        pNext = (*p).pNext;
        sqlite3_free((*p).zEQP as *mut libc::c_void);
        sqlite3_free((*p).zIdx as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext;
    }
}
unsafe extern "C" fn idxTableFree(pTab: *mut IdxTable) {
    let mut pIter: *mut IdxTable = 0 as *mut IdxTable;
    let mut pNext: *mut IdxTable = 0 as *mut IdxTable;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext;
    }
}
unsafe extern "C" fn idxWriteFree(pTab: *mut IdxWrite) {
    let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pNext: *mut IdxWrite = 0 as *mut IdxWrite;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext;
    }
}
unsafe extern "C" fn idxFindIndexes(
    p: *mut sqlite3expert,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    let dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut hIdx: IdxHash = IdxHash {
        pFirst: 0 as *mut IdxHashEntry,
        aHash: [0 as *mut IdxHashEntry; 1023],
    };
    idxHashInit(&mut hIdx);
    pStmt = (*p).pStatement;
    's_13: while rc == 0 as libc::c_int && !pStmt.is_null() {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        idxHashClear(&mut hIdx);
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pExplain as *mut *mut sqlite3_stmt,
            pzErr,
            b"EXPLAIN QUERY PLAN %s\0" as *const u8 as *const libc::c_char,
            (*pStmt).zSql,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pExplain) == 100 as libc::c_int {
            let zDetail: *const libc::c_char = sqlite3_column_text(
                pExplain,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut nDetail: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            if zDetail.is_null() {
                continue;
            }
            nDetail = strlen(zDetail) as libc::c_int;
            i = 0 as libc::c_int;
            while i < nDetail {
                let mut zIdx: *const libc::c_char = 0 as *const libc::c_char;
                if (i + 13 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char
                            as *const libc::c_void,
                        b" USING INDEX \0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        13 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 13 as libc::c_int) as isize)
                        as *const libc::c_char;
                } else if (i + 22 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char
                            as *const libc::c_void,
                        b" USING COVERING INDEX \0" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        22 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 22 as libc::c_int) as isize)
                        as *const libc::c_char;
                }
                if !zIdx.is_null() {
                    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
                    let mut nIdx: libc::c_int = 0 as libc::c_int;
                    while *zIdx.offset(nIdx as isize) as libc::c_int != '\0' as i32
                        && (*zIdx.offset(nIdx as isize) as libc::c_int != ' ' as i32
                            || *zIdx.offset((nIdx + 1 as libc::c_int) as isize)
                                as libc::c_int != '(' as i32)
                    {
                        nIdx += 1;
                        nIdx;
                    }
                    zSql = idxHashSearch(&mut (*p).hIdx, zIdx, nIdx);
                    if zSql.is_null() {
                        break;
                    }
                    idxHashAdd(&mut rc, &mut hIdx, zSql, 0 as *const libc::c_char);
                    if rc != 0 {
                        break 's_13;
                    } else {
                        break;
                    }
                } else {
                    i += 1;
                    i;
                }
            }
            if *zDetail.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                (*pStmt)
                    .zEQP = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    (*pStmt).zEQP,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    zDetail,
                );
            }
        }
        pEntry = hIdx.pFirst;
        while !pEntry.is_null() {
            (*pStmt)
                .zIdx = idxAppendText(
                &mut rc as *mut libc::c_int,
                (*pStmt).zIdx,
                b"%s;\n\0" as *const u8 as *const libc::c_char,
                (*pEntry).zKey,
            );
            pEntry = (*pEntry).pNext;
        }
        idxFinalize(&mut rc, pExplain);
        pStmt = (*pStmt).pNext;
    }
    idxHashClear(&mut hIdx);
    return rc;
}
unsafe extern "C" fn idxAuthCallback(
    pCtx: *mut libc::c_void,
    eOp: libc::c_int,
    z3: *const libc::c_char,
    _z4: *const libc::c_char,
    zDb: *const libc::c_char,
    _zTrigger: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if eOp == 18 as libc::c_int || eOp == 23 as libc::c_int || eOp == 9 as libc::c_int {
        if sqlite3_stricmp(zDb, b"main\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            let p: *mut sqlite3expert = pCtx as *mut sqlite3expert;
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            pTab = (*p).pTable;
            while !pTab.is_null() {
                if 0 as libc::c_int == sqlite3_stricmp(z3, (*pTab).zName) {
                    break;
                }
                pTab = (*pTab).pNext;
            }
            if !pTab.is_null() {
                let mut pWrite: *mut IdxWrite = 0 as *mut IdxWrite;
                pWrite = (*p).pWrite;
                while !pWrite.is_null() {
                    if (*pWrite).pTab == pTab && (*pWrite).eOp == eOp {
                        break;
                    }
                    pWrite = (*pWrite).pNext;
                }
                if pWrite.is_null() {
                    pWrite = idxMalloc(
                        &mut rc,
                        ::core::mem::size_of::<IdxWrite>() as libc::c_ulong
                            as libc::c_int,
                    ) as *mut IdxWrite;
                    if rc == 0 as libc::c_int {
                        (*pWrite).pTab = pTab;
                        (*pWrite).eOp = eOp;
                        (*pWrite).pNext = (*p).pWrite;
                        (*p).pWrite = pWrite;
                    }
                }
            }
        }
    }
    return rc;
}
unsafe extern "C" fn idxProcessOneTrigger(
    p: *mut sqlite3expert,
    pWrite: *mut IdxWrite,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut zInt: *const libc::c_char = b"t592690916721053953805701627921227776\0"
        as *const u8 as *const libc::c_char;
    static mut zDrop: *const libc::c_char = b"DROP TABLE t592690916721053953805701627921227776\0"
        as *const u8 as *const libc::c_char;
    let pTab: *mut IdxTable = (*pWrite).pTab;
    let zTab: *const libc::c_char = (*pTab).zName;
    let zSql: *const libc::c_char = b"SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\0"
        as *const u8 as *const libc::c_char;
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zWrite: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = idxPrintfPrepareStmt(
        (*p).db,
        &mut pSelect as *mut *mut sqlite3_stmt,
        pzErr,
        zSql,
        zTab,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSelect) {
        let zCreate: *const libc::c_char = sqlite3_column_text(
            pSelect,
            0 as libc::c_int,
        ) as *const libc::c_char;
        if zCreate.is_null() {
            continue;
        }
        rc = sqlite3_exec((*p).dbv, zCreate, None, 0 as *mut libc::c_void, pzErr);
    }
    idxFinalize(&mut rc, pSelect);
    if rc == 0 as libc::c_int {
        let z: *mut libc::c_char = sqlite3_mprintf(
            b"ALTER TABLE temp.%Q RENAME TO %Q\0" as *const u8 as *const libc::c_char,
            zTab,
            zInt,
        );
        if z.is_null() {
            rc = 7 as libc::c_int;
        } else {
            rc = sqlite3_exec((*p).dbv, z, None, 0 as *mut libc::c_void, pzErr);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
    match (*pWrite).eOp {
        18 => {
            let mut i: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"INSERT INTO %Q VALUES(\0" as *const u8 as *const libc::c_char,
                zInt,
            );
            i = 0 as libc::c_int;
            while i < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s?\0" as *const u8 as *const libc::c_char,
                    if i == 0 as libc::c_int {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b", \0" as *const u8 as *const libc::c_char
                    },
                );
                i += 1;
                i;
            }
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b")\0" as *const u8 as *const libc::c_char,
            );
        }
        23 => {
            let mut i_0: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"UPDATE %Q SET \0" as *const u8 as *const libc::c_char,
                zInt,
            );
            i_0 = 0 as libc::c_int;
            while i_0 < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s%Q=?\0" as *const u8 as *const libc::c_char,
                    if i_0 == 0 as libc::c_int {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b", \0" as *const u8 as *const libc::c_char
                    },
                    (*((*pTab).aCol).offset(i_0 as isize)).zName,
                );
                i_0 += 1;
                i_0;
            }
        }
        _ => {
            if (*pWrite).eOp == 9 as libc::c_int {} else {
                __assert_fail(
                    b"pWrite->eOp==SQLITE_DELETE\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    12390 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 63],
                        &[libc::c_char; 63],
                    >(
                        b"int idxProcessOneTrigger(sqlite3expert *, IdxWrite *, char **)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_61999: {
                if (*pWrite).eOp == 9 as libc::c_int {} else {
                    __assert_fail(
                        b"pWrite->eOp==SQLITE_DELETE\0" as *const u8
                            as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        12390 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 63],
                            &[libc::c_char; 63],
                        >(
                            b"int idxProcessOneTrigger(sqlite3expert *, IdxWrite *, char **)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            if rc == 0 as libc::c_int {
                zWrite = sqlite3_mprintf(
                    b"DELETE FROM %Q\0" as *const u8 as *const libc::c_char,
                    zInt,
                );
                if zWrite.is_null() {
                    rc = 7 as libc::c_int;
                }
            }
        }
    }
    if rc == 0 as libc::c_int {
        let mut pX: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zWrite,
            -(1 as libc::c_int),
            &mut pX,
            0 as *mut *const libc::c_char,
        );
        idxFinalize(&mut rc, pX);
        if rc != 0 as libc::c_int {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    sqlite3_free(zWrite as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec((*p).dbv, zDrop, None, 0 as *mut libc::c_void, pzErr);
    }
    return rc;
}
unsafe extern "C" fn idxProcessTriggers(
    p: *mut sqlite3expert,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pEnd: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pFirst: *mut IdxWrite = (*p).pWrite;
    while rc == 0 as libc::c_int && pFirst != pEnd {
        let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
        pIter = pFirst;
        while rc == 0 as libc::c_int && pIter != pEnd {
            rc = idxProcessOneTrigger(p, pIter, pzErr);
            pIter = (*pIter).pNext;
        }
        pEnd = pFirst;
        pFirst = (*p).pWrite;
    }
    return rc;
}
unsafe extern "C" fn idxCreateVtabSchema(
    p: *mut sqlite3expert,
    pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = idxRegisterVtab(p);
    let mut pSchema: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    rc = idxPrepareStmt(
        (*p).db,
        &mut pSchema,
        pzErrmsg,
        b"SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') ORDER BY 4, 1\0"
            as *const u8 as *const libc::c_char,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSchema) {
        let zType: *const libc::c_char = sqlite3_column_text(
            pSchema,
            0 as libc::c_int,
        ) as *const libc::c_char;
        let zName: *const libc::c_char = sqlite3_column_text(
            pSchema,
            1 as libc::c_int,
        ) as *const libc::c_char;
        let zSql: *const libc::c_char = sqlite3_column_text(
            pSchema,
            2 as libc::c_int,
        ) as *const libc::c_char;
        if zType.is_null() || zName.is_null() {
            continue;
        }
        if *zType.offset(0 as libc::c_int as isize) as libc::c_int == 'v' as i32
            || *zType.offset(1 as libc::c_int as isize) as libc::c_int == 'r' as i32
        {
            if !zSql.is_null() {
                rc = sqlite3_exec(
                    (*p).dbv,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    pzErrmsg,
                );
            }
        } else {
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            rc = idxGetTableInfo((*p).db, zName, &mut pTab, pzErrmsg);
            if rc == 0 as libc::c_int {
                let mut i: libc::c_int = 0;
                let mut zInner: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zOuter: *mut libc::c_char = 0 as *mut libc::c_char;
                (*pTab).pNext = (*p).pTable;
                (*p).pTable = pTab;
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    0 as *mut libc::c_char,
                    b"CREATE TABLE x(\0" as *const u8 as *const libc::c_char,
                );
                i = 0 as libc::c_int;
                while i < (*pTab).nCol {
                    zInner = idxAppendText(
                        &mut rc as *mut libc::c_int,
                        zInner,
                        b"%s%Q COLLATE %s\0" as *const u8 as *const libc::c_char,
                        if i == 0 as libc::c_int {
                            b"\0" as *const u8 as *const libc::c_char
                        } else {
                            b", \0" as *const u8 as *const libc::c_char
                        },
                        (*((*pTab).aCol).offset(i as isize)).zName,
                        (*((*pTab).aCol).offset(i as isize)).zColl,
                    );
                    i += 1;
                    i;
                }
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zInner,
                    b")\0" as *const u8 as *const libc::c_char,
                );
                zOuter = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    0 as *mut libc::c_char,
                    b"CREATE VIRTUAL TABLE %Q USING expert(%Q)\0" as *const u8
                        as *const libc::c_char,
                    zName,
                    zInner,
                );
                if rc == 0 as libc::c_int {
                    rc = sqlite3_exec(
                        (*p).dbv,
                        zOuter,
                        None,
                        0 as *mut libc::c_void,
                        pzErrmsg,
                    );
                }
                sqlite3_free(zInner as *mut libc::c_void);
                sqlite3_free(zOuter as *mut libc::c_void);
            }
        }
    }
    idxFinalize(&mut rc, pSchema);
    return rc;
}
unsafe extern "C" fn idxSampleFunc(
    pCtx: *mut sqlite3_context,
    argc: libc::c_int,
    _argv: *mut *mut sqlite3_value,
) {
    let p: *mut IdxSampleCtx = sqlite3_user_data(pCtx) as *mut IdxSampleCtx;
    let mut bRet: libc::c_int = 0;
    if argc == 0 as libc::c_int {} else {
        __assert_fail(
            b"argc==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            12510 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 61],
                &[libc::c_char; 61],
            >(b"void idxSampleFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_59668: {
        if argc == 0 as libc::c_int {} else {
            __assert_fail(
                b"argc==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                12510 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 61],
                    &[libc::c_char; 61],
                >(b"void idxSampleFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    if (*p).nRow == 0.0f64 {
        bRet = 1 as libc::c_int;
    } else {
        bRet = ((*p).nRet / (*p).nRow <= (*p).target) as libc::c_int;
        if bRet == 0 as libc::c_int {
            let mut rnd: libc::c_ushort = 0;
            sqlite3_randomness(
                2 as libc::c_int,
                &mut rnd as *mut libc::c_ushort as *mut libc::c_void,
            );
            bRet = (rnd as libc::c_int % 100 as libc::c_int <= (*p).iTarget)
                as libc::c_int;
        }
    }
    sqlite3_result_int(pCtx, bRet);
    (*p).nRow += 1.0f64;
    (*p).nRet += bRet as libc::c_double;
}
unsafe extern "C" fn idxRemFunc(
    pCtx: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let p: *mut IdxRemCtx = sqlite3_user_data(pCtx) as *mut IdxRemCtx;
    let mut pSlot: *mut IdxRemSlot = 0 as *mut IdxRemSlot;
    let mut iSlot: libc::c_int = 0;
    if argc == 2 as libc::c_int {} else {
        __assert_fail(
            b"argc==2\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            12550 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"void idxRemFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_60108: {
        if argc == 2 as libc::c_int {} else {
            __assert_fail(
                b"argc==2\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                12550 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 58],
                    &[libc::c_char; 58],
                >(b"void idxRemFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    iSlot = sqlite3_value_int(*argv.offset(0 as libc::c_int as isize));
    if iSlot <= (*p).nSlot {} else {
        __assert_fail(
            b"iSlot<=p->nSlot\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            12553 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 58],
                &[libc::c_char; 58],
            >(b"void idxRemFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_60056: {
        if iSlot <= (*p).nSlot {} else {
            __assert_fail(
                b"iSlot<=p->nSlot\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                12553 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 58],
                    &[libc::c_char; 58],
                >(b"void idxRemFunc(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    pSlot = &mut *((*p).aSlot).as_mut_ptr().offset(iSlot as isize) as *mut IdxRemSlot;
    match (*pSlot).eType {
        1 => {
            sqlite3_result_int64(pCtx, (*pSlot).iVal);
        }
        2 => {
            sqlite3_result_double(pCtx, (*pSlot).rVal);
        }
        4 => {
            sqlite3_result_blob(
                pCtx,
                (*pSlot).z as *const libc::c_void,
                (*pSlot).n,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        3 => {
            sqlite3_result_text(
                pCtx,
                (*pSlot).z,
                (*pSlot).n,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
        }
        5 | _ => {}
    }
    (*pSlot).eType = sqlite3_value_type(*argv.offset(1 as libc::c_int as isize));
    match (*pSlot).eType {
        1 => {
            (*pSlot).iVal = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        }
        2 => {
            (*pSlot)
                .rVal = sqlite3_value_double(*argv.offset(1 as libc::c_int as isize));
        }
        4 | 3 => {
            let nByte: libc::c_int = sqlite3_value_bytes(
                *argv.offset(1 as libc::c_int as isize),
            );
            let mut pData: *const libc::c_void = 0 as *const libc::c_void;
            if nByte > (*pSlot).nByte {
                let zNew: *mut libc::c_char = sqlite3_realloc(
                    (*pSlot).z as *mut libc::c_void,
                    nByte * 2 as libc::c_int,
                ) as *mut libc::c_char;
                if zNew.is_null() {
                    sqlite3_result_error_nomem(pCtx);
                    return;
                }
                (*pSlot).nByte = nByte * 2 as libc::c_int;
                (*pSlot).z = zNew;
            }
            (*pSlot).n = nByte;
            if (*pSlot).eType == 4 as libc::c_int {
                pData = sqlite3_value_blob(*argv.offset(1 as libc::c_int as isize));
                if !pData.is_null() {
                    memcpy(
                        (*pSlot).z as *mut libc::c_void,
                        pData,
                        nByte as libc::c_ulong,
                    );
                }
            } else {
                pData = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
                    as *const libc::c_void;
                memcpy((*pSlot).z as *mut libc::c_void, pData, nByte as libc::c_ulong);
            }
        }
        5 | _ => {}
    };
}
unsafe extern "C" fn idxLargestIndex(
    db: *mut sqlite3,
    pnMax: *mut libc::c_int,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let zMax: *const libc::c_char = b"SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\0"
        as *const u8 as *const libc::c_char;
    let mut pMax: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    *pnMax = 0 as libc::c_int;
    rc = idxPrepareStmt(db, &mut pMax, pzErr, zMax);
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pMax) {
        *pnMax = sqlite3_column_int(pMax, 0 as libc::c_int) + 1 as libc::c_int;
    }
    idxFinalize(&mut rc, pMax);
    return rc;
}
unsafe extern "C" fn idxPopulateOneStat1(
    p: *mut sqlite3expert,
    pIndexXInfo: *mut sqlite3_stmt,
    pWriteStat: *mut sqlite3_stmt,
    zTab: *const libc::c_char,
    zIdx: *const libc::c_char,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zOrder: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aStat: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*p).iSample > 0 as libc::c_int {} else {
        __assert_fail(
            b"p->iSample>0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            12655 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 110],
                &[libc::c_char; 110],
            >(
                b"int idxPopulateOneStat1(sqlite3expert *, sqlite3_stmt *, sqlite3_stmt *, const char *, const char *, char **)\0",
            ))
                .as_ptr(),
        );
    }
    'c_59251: {
        if (*p).iSample > 0 as libc::c_int {} else {
            __assert_fail(
                b"p->iSample>0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                12655 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 110],
                    &[libc::c_char; 110],
                >(
                    b"int idxPopulateOneStat1(sqlite3expert *, sqlite3_stmt *, sqlite3_stmt *, const char *, const char *, char **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    sqlite3_bind_text(pIndexXInfo, 1 as libc::c_int, zIdx, -(1 as libc::c_int), None);
    while 0 as libc::c_int == rc && 100 as libc::c_int == sqlite3_step(pIndexXInfo) {
        let zComma: *const libc::c_char = if zCols.is_null() {
            b"\0" as *const u8 as *const libc::c_char
        } else {
            b", \0" as *const u8 as *const libc::c_char
        };
        let zName: *const libc::c_char = sqlite3_column_text(
            pIndexXInfo,
            0 as libc::c_int,
        ) as *const libc::c_char;
        let zColl: *const libc::c_char = sqlite3_column_text(
            pIndexXInfo,
            1 as libc::c_int,
        ) as *const libc::c_char;
        zCols = idxAppendText(
            &mut rc as *mut libc::c_int,
            zCols,
            b"%sx.%Q IS rem(%d, x.%Q) COLLATE %s\0" as *const u8 as *const libc::c_char,
            zComma,
            zName,
            nCol,
            zName,
            zColl,
        );
        nCol += 1;
        zOrder = idxAppendText(
            &mut rc as *mut libc::c_int,
            zOrder,
            b"%s%d\0" as *const u8 as *const libc::c_char,
            zComma,
            nCol,
        );
    }
    sqlite3_reset(pIndexXInfo);
    if rc == 0 as libc::c_int {
        if (*p).iSample == 100 as libc::c_int {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM %Q x ORDER BY %s\0" as *const u8 as *const libc::c_char,
                zCols,
                zTab,
                zOrder,
            );
        } else {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\0"
                    as *const u8 as *const libc::c_char,
                zCols,
                zOrder,
            );
        }
    }
    sqlite3_free(zCols as *mut libc::c_void);
    sqlite3_free(zOrder as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        let dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = idxPrepareStmt(dbrem, &mut pQuery, pzErr, zQuery);
    }
    sqlite3_free(zQuery as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        aStat = idxMalloc(
            &mut rc,
            (::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul((nCol + 1 as libc::c_int) as libc::c_ulong) as libc::c_int,
        ) as *mut libc::c_int;
    }
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut zStat: *mut libc::c_char = 0 as *mut libc::c_char;
        i = 0 as libc::c_int;
        while i <= nCol {
            *aStat.offset(i as isize) = 1 as libc::c_int;
            i += 1;
            i;
        }
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
            let ref mut fresh52 = *aStat.offset(0 as libc::c_int as isize);
            *fresh52 += 1;
            *fresh52;
            i = 0 as libc::c_int;
            while i < nCol {
                if sqlite3_column_int(pQuery, i) == 0 as libc::c_int {
                    break;
                }
                i += 1;
                i;
            }
            while i < nCol {
                let ref mut fresh53 = *aStat.offset((i + 1 as libc::c_int) as isize);
                *fresh53 += 1;
                *fresh53;
                i += 1;
                i;
            }
        }
        if rc == 0 as libc::c_int {
            let s0: libc::c_int = *aStat.offset(0 as libc::c_int as isize);
            zStat = sqlite3_mprintf(b"%d\0" as *const u8 as *const libc::c_char, s0);
            if zStat.is_null() {
                rc = 7 as libc::c_int;
            }
            i = 1 as libc::c_int;
            while rc == 0 as libc::c_int && i <= nCol {
                zStat = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zStat,
                    b" %d\0" as *const u8 as *const libc::c_char,
                    (s0 + *aStat.offset(i as isize) / 2 as libc::c_int)
                        / *aStat.offset(i as isize),
                );
                i += 1;
                i;
            }
        }
        if rc == 0 as libc::c_int {
            sqlite3_bind_text(
                pWriteStat,
                1 as libc::c_int,
                zTab,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                2 as libc::c_int,
                zIdx,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                3 as libc::c_int,
                zStat,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_step(pWriteStat);
            rc = sqlite3_reset(pWriteStat);
        }
        pEntry = idxHashFind(&mut (*p).hIdx, zIdx, strlen(zIdx) as libc::c_int);
        if !pEntry.is_null() {
            if ((*pEntry).zVal2).is_null() {} else {
                __assert_fail(
                    b"pEntry->zVal2==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    12726 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 110],
                        &[libc::c_char; 110],
                    >(
                        b"int idxPopulateOneStat1(sqlite3expert *, sqlite3_stmt *, sqlite3_stmt *, const char *, const char *, char **)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_58724: {
                if ((*pEntry).zVal2).is_null() {} else {
                    __assert_fail(
                        b"pEntry->zVal2==0\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        12726 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 110],
                            &[libc::c_char; 110],
                        >(
                            b"int idxPopulateOneStat1(sqlite3expert *, sqlite3_stmt *, sqlite3_stmt *, const char *, const char *, char **)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            (*pEntry).zVal2 = zStat;
        } else {
            sqlite3_free(zStat as *mut libc::c_void);
        }
    }
    sqlite3_free(aStat as *mut libc::c_void);
    idxFinalize(&mut rc, pQuery);
    return rc;
}
unsafe extern "C" fn idxBuildSampleTable(
    p: *mut sqlite3expert,
    zTab: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).dbv,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc != 0 as libc::c_int {
        return rc;
    }
    zSql = sqlite3_mprintf(
        b"CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\0"
            as *const u8 as *const libc::c_char,
        zTab,
    );
    if zSql.is_null() {
        return 7 as libc::c_int;
    }
    rc = sqlite3_exec(
        (*p).dbv,
        zSql,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn idxPopulateStat1(
    p: *mut sqlite3expert,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nMax: libc::c_int = 0 as libc::c_int;
    let mut pCtx: *mut IdxRemCtx = 0 as *mut IdxRemCtx;
    let mut samplectx: IdxSampleCtx = IdxSampleCtx {
        iTarget: 0,
        target: 0.,
        nRow: 0.,
        nRet: 0.,
    };
    let mut i: libc::c_int = 0;
    let mut iPrev: i64_0 = -(100000 as libc::c_int) as i64_0;
    let mut pAllIndex: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIndexXInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pWrite: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let zAllIndex: *const libc::c_char = b"SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\0"
        as *const u8 as *const libc::c_char;
    let zIndexXInfo: *const libc::c_char = b"SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\0"
        as *const u8 as *const libc::c_char;
    let zWrite: *const libc::c_char = b"INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\0"
        as *const u8 as *const libc::c_char;
    if (*p).iSample == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    rc = idxLargestIndex((*p).dbm, &mut nMax, pzErr);
    if nMax <= 0 as libc::c_int || rc != 0 as libc::c_int {
        return rc;
    }
    rc = sqlite3_exec(
        (*p).dbm,
        b"ANALYZE; PRAGMA writable_schema=1\0" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc == 0 as libc::c_int {
        let nByte: libc::c_int = (::core::mem::size_of::<IdxRemCtx>()
            as libc::c_ulong)
            .wrapping_add(
                (::core::mem::size_of::<IdxRemSlot>() as libc::c_ulong)
                    .wrapping_mul(nMax as libc::c_ulong),
            ) as libc::c_int;
        pCtx = idxMalloc(&mut rc, nByte) as *mut IdxRemCtx;
    }
    if rc == 0 as libc::c_int {
        let dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = sqlite3_create_function(
            dbrem,
            b"rem\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            pCtx as *mut libc::c_void,
            Some(
                idxRemFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            (*p).db,
            b"sample\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
            1 as libc::c_int,
            &mut samplectx as *mut IdxSampleCtx as *mut libc::c_void,
            Some(
                idxSampleFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
    }
    if rc == 0 as libc::c_int {
        (*pCtx).nSlot = nMax + 1 as libc::c_int;
        rc = idxPrepareStmt((*p).dbm, &mut pAllIndex, pzErr, zAllIndex);
    }
    if rc == 0 as libc::c_int {
        rc = idxPrepareStmt((*p).dbm, &mut pIndexXInfo, pzErr, zIndexXInfo);
    }
    if rc == 0 as libc::c_int {
        rc = idxPrepareStmt((*p).dbm, &mut pWrite, pzErr, zWrite);
    }
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pAllIndex) {
        let iRowid: i64_0 = sqlite3_column_int64(pAllIndex, 0 as libc::c_int);
        let zTab: *const libc::c_char = sqlite3_column_text(
            pAllIndex,
            1 as libc::c_int,
        ) as *const libc::c_char;
        let zIdx: *const libc::c_char = sqlite3_column_text(
            pAllIndex,
            2 as libc::c_int,
        ) as *const libc::c_char;
        if zTab.is_null() || zIdx.is_null() {
            continue;
        }
        if (*p).iSample < 100 as libc::c_int && iPrev != iRowid {
            samplectx.target = (*p).iSample as libc::c_double / 100.0f64;
            samplectx.iTarget = (*p).iSample;
            samplectx.nRow = 0.0f64;
            samplectx.nRet = 0.0f64;
            rc = idxBuildSampleTable(p, zTab);
            if rc != 0 as libc::c_int {
                break;
            }
        }
        rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
        iPrev = iRowid;
    }
    if rc == 0 as libc::c_int && (*p).iSample < 100 as libc::c_int {
        rc = sqlite3_exec(
            (*p).dbv,
            b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0"
                as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    idxFinalize(&mut rc, pAllIndex);
    idxFinalize(&mut rc, pIndexXInfo);
    idxFinalize(&mut rc, pWrite);
    if !pCtx.is_null() {
        i = 0 as libc::c_int;
        while i < (*pCtx).nSlot {
            sqlite3_free(
                (*((*pCtx).aSlot).as_mut_ptr().offset(i as isize)).z as *mut libc::c_void,
            );
            i += 1;
            i;
        }
        sqlite3_free(pCtx as *mut libc::c_void);
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec(
            (*p).dbm,
            b"ANALYZE sqlite_schema\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    sqlite3_exec(
        (*p).db,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\0" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_new(
    db: *mut sqlite3,
    pzErrmsg: *mut *mut libc::c_char,
) -> *mut sqlite3expert {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pNew: *mut sqlite3expert = 0 as *mut sqlite3expert;
    pNew = idxMalloc(
        &mut rc,
        ::core::mem::size_of::<sqlite3expert>() as libc::c_ulong as libc::c_int,
    ) as *mut sqlite3expert;
    if rc == 0 as libc::c_int {
        (*pNew).db = db;
        (*pNew).iSample = 100 as libc::c_int;
        rc = sqlite3_open(
            b":memory:\0" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbv,
        );
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_open(
            b":memory:\0" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbm,
        );
        if rc == 0 as libc::c_int {
            sqlite3_db_config(
                (*pNew).dbm,
                1008 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_int,
            );
        }
    }
    if rc == 0 as libc::c_int {
        let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = idxPrintfPrepareStmt(
            (*pNew).db,
            &mut pSql as *mut *mut sqlite3_stmt,
            pzErrmsg,
            b"SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\0"
                as *const u8 as *const libc::c_char,
        );
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            let zSql: *const libc::c_char = sqlite3_column_text(
                pSql,
                0 as libc::c_int,
            ) as *const libc::c_char;
            if !zSql.is_null() {
                rc = sqlite3_exec(
                    (*pNew).dbm,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    pzErrmsg,
                );
            }
        }
        idxFinalize(&mut rc, pSql);
    }
    if rc == 0 as libc::c_int {
        rc = idxCreateVtabSchema(pNew, pzErrmsg);
    }
    if rc == 0 as libc::c_int {
        sqlite3_set_authorizer(
            (*pNew).dbv,
            Some(
                idxAuthCallback
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                        *const libc::c_char,
                    ) -> libc::c_int,
            ),
            pNew as *mut libc::c_void,
        );
    }
    if rc != 0 as libc::c_int {
        sqlite3_expert_destroy(pNew);
        pNew = 0 as *mut sqlite3expert;
    }
    return pNew;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_config(
    p: *mut sqlite3expert,
    op: libc::c_int,
    args: ...
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    match op {
        1 => {
            let mut iVal: libc::c_int = ap.arg::<libc::c_int>();
            if iVal < 0 as libc::c_int {
                iVal = 0 as libc::c_int;
            }
            if iVal > 100 as libc::c_int {
                iVal = 100 as libc::c_int;
            }
            (*p).iSample = iVal;
        }
        _ => {
            rc = 12 as libc::c_int;
        }
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_sql(
    p: *mut sqlite3expert,
    zSql: *const libc::c_char,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let pScanOrig: *mut IdxScan = (*p).pScan;
    let pStmtOrig: *mut IdxStatement = (*p).pStatement;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zStmt: *const libc::c_char = zSql;
    if (*p).bRun != 0 {
        return 21 as libc::c_int;
    }
    while rc == 0 as libc::c_int && !zStmt.is_null()
        && *zStmt.offset(0 as libc::c_int as isize) as libc::c_int != 0
    {
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zStmt,
            -(1 as libc::c_int),
            &mut pStmt,
            &mut zStmt,
        );
        if rc == 0 as libc::c_int {
            if !pStmt.is_null() {
                let mut pNew: *mut IdxStatement = 0 as *mut IdxStatement;
                let z: *const libc::c_char = sqlite3_sql(pStmt);
                let n: libc::c_int = strlen(z) as libc::c_int;
                pNew = idxMalloc(
                    &mut rc,
                    (::core::mem::size_of::<IdxStatement>() as libc::c_ulong)
                        .wrapping_add(n as libc::c_ulong)
                        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
                ) as *mut IdxStatement;
                if rc == 0 as libc::c_int {
                    (*pNew)
                        .zSql = &mut *pNew.offset(1 as libc::c_int as isize)
                        as *mut IdxStatement as *mut libc::c_char;
                    memcpy(
                        (*pNew).zSql as *mut libc::c_void,
                        z as *const libc::c_void,
                        (n + 1 as libc::c_int) as libc::c_ulong,
                    );
                    (*pNew).pNext = (*p).pStatement;
                    if !((*p).pStatement).is_null() {
                        (*pNew).iId = (*(*p).pStatement).iId + 1 as libc::c_int;
                    }
                    (*p).pStatement = pNew;
                }
                sqlite3_finalize(pStmt);
            }
        } else {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    if rc != 0 as libc::c_int {
        idxScanFree((*p).pScan, pScanOrig);
        idxStatementFree((*p).pStatement, pStmtOrig);
        (*p).pScan = pScanOrig;
        (*p).pStatement = pStmtOrig;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_analyze(
    p: *mut sqlite3expert,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    rc = idxProcessTriggers(p, pzErr);
    if rc == 0 as libc::c_int {
        rc = idxCreateCandidates(p);
    } else if rc == 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int {
        if !pzErr.is_null() {
            *pzErr = sqlite3_mprintf(
                b"Cannot find a unique index name to propose.\0" as *const u8
                    as *const libc::c_char,
            );
        }
        return rc;
    }
    if rc == 0 as libc::c_int {
        rc = idxPopulateStat1(p, pzErr);
    }
    pEntry = (*p).hIdx.pFirst;
    while !pEntry.is_null() {
        (*p)
            .zCandidates = idxAppendText(
            &mut rc as *mut libc::c_int,
            (*p).zCandidates,
            b"%s;%s%s\n\0" as *const u8 as *const libc::c_char,
            (*pEntry).zVal,
            if !((*pEntry).zVal2).is_null() {
                b" -- stat1: \0" as *const u8 as *const libc::c_char
            } else {
                b"\0" as *const u8 as *const libc::c_char
            },
            (*pEntry).zVal2,
        );
        pEntry = (*pEntry).pNext;
    }
    if rc == 0 as libc::c_int {
        rc = idxFindIndexes(p, pzErr);
    }
    if rc == 0 as libc::c_int {
        (*p).bRun = 1 as libc::c_int;
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_count(p: *mut sqlite3expert) -> libc::c_int {
    let mut nRet: libc::c_int = 0 as libc::c_int;
    if !((*p).pStatement).is_null() {
        nRet = (*(*p).pStatement).iId + 1 as libc::c_int;
    }
    return nRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_report(
    p: *mut sqlite3expert,
    iStmt: libc::c_int,
    eReport: libc::c_int,
) -> *const libc::c_char {
    let mut zRet: *const libc::c_char = 0 as *const libc::c_char;
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    if (*p).bRun == 0 as libc::c_int {
        return 0 as *const libc::c_char;
    }
    pStmt = (*p).pStatement;
    while !pStmt.is_null() && (*pStmt).iId != iStmt {
        pStmt = (*pStmt).pNext;
    }
    match eReport {
        1 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zSql;
            }
        }
        2 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zIdx;
            }
        }
        3 => {
            if !pStmt.is_null() {
                zRet = (*pStmt).zEQP;
            }
        }
        4 => {
            zRet = (*p).zCandidates;
        }
        _ => {}
    }
    return zRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_expert_destroy(p: *mut sqlite3expert) {
    if !p.is_null() {
        sqlite3_close((*p).dbm);
        sqlite3_close((*p).dbv);
        idxScanFree((*p).pScan, 0 as *mut IdxScan);
        idxStatementFree((*p).pStatement, 0 as *mut IdxStatement);
        idxTableFree((*p).pTable);
        idxWriteFree((*p).pWrite);
        idxHashClear(&mut (*p).hIdx);
        sqlite3_free((*p).zCandidates as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
}
unsafe extern "C" fn dbdataConnect(
    db: *mut sqlite3,
    pAux: *mut libc::c_void,
    _argc: libc::c_int,
    _argv: *const *const libc::c_char,
    ppVtab: *mut *mut sqlite3_vtab,
    _pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = 0 as *mut DbdataTable;
    let mut rc: libc::c_int = sqlite3_declare_vtab(
        db,
        if !pAux.is_null() {
            b"CREATE TABLE x(  pgno INTEGER,  child INTEGER,  schema TEXT HIDDEN)\0"
                as *const u8 as *const libc::c_char
        } else {
            b"CREATE TABLE x(  pgno INTEGER,  cell INTEGER,  field INTEGER,  value ANY,  schema TEXT HIDDEN)\0"
                as *const u8 as *const libc::c_char
        },
    );
    sqlite3_vtab_config(db, 4 as libc::c_int);
    if rc == 0 as libc::c_int {
        pTab = sqlite3_malloc64(
            ::core::mem::size_of::<DbdataTable>() as libc::c_ulong as sqlite3_uint64,
        ) as *mut DbdataTable;
        if pTab.is_null() {
            rc = 7 as libc::c_int;
        } else {
            memset(
                pTab as *mut libc::c_void,
                0 as libc::c_int,
                ::core::mem::size_of::<DbdataTable>() as libc::c_ulong,
            );
            (*pTab).db = db;
            (*pTab).bPtr = (pAux != 0 as *mut libc::c_void) as libc::c_int;
        }
    }
    *ppVtab = pTab as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn dbdataDisconnect(pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let pTab: *mut DbdataTable = pVtab as *mut DbdataTable;
    if !pTab.is_null() {
        sqlite3_finalize((*pTab).pStmt);
        sqlite3_free(pVtab as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataBestIndex(
    tab: *mut sqlite3_vtab,
    pIdx: *mut sqlite3_index_info,
) -> libc::c_int {
    let pTab: *mut DbdataTable = tab as *mut DbdataTable;
    let mut i: libc::c_int = 0;
    let mut iSchema: libc::c_int = -(1 as libc::c_int);
    let mut iPgno: libc::c_int = -(1 as libc::c_int);
    let colSchema: libc::c_int = if (*pTab).bPtr != 0 {
        2 as libc::c_int
    } else {
        4 as libc::c_int
    };
    i = 0 as libc::c_int;
    while i < (*pIdx).nConstraint {
        let p: *mut sqlite3_index_constraint = &mut *((*pIdx).aConstraint)
            .offset(i as isize) as *mut sqlite3_index_constraint;
        if (*p).op as libc::c_int == 2 as libc::c_int {
            if (*p).iColumn == colSchema {
                if (*p).usable as libc::c_int == 0 as libc::c_int {
                    return 19 as libc::c_int;
                }
                iSchema = i;
            }
            if (*p).iColumn == 0 as libc::c_int && (*p).usable as libc::c_int != 0 {
                iPgno = i;
            }
        }
        i += 1;
        i;
    }
    if iSchema >= 0 as libc::c_int {
        (*((*pIdx).aConstraintUsage).offset(iSchema as isize))
            .argvIndex = 1 as libc::c_int;
        (*((*pIdx).aConstraintUsage).offset(iSchema as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
    }
    if iPgno >= 0 as libc::c_int {
        (*((*pIdx).aConstraintUsage).offset(iPgno as isize))
            .argvIndex = 1 as libc::c_int + (iSchema >= 0 as libc::c_int) as libc::c_int;
        (*((*pIdx).aConstraintUsage).offset(iPgno as isize))
            .omit = 1 as libc::c_int as libc::c_uchar;
        (*pIdx).estimatedCost = 100 as libc::c_int as libc::c_double;
        (*pIdx).estimatedRows = 50 as libc::c_int as sqlite3_int64;
        if (*pTab).bPtr == 0 as libc::c_int && (*pIdx).nOrderBy != 0
            && (*((*pIdx).aOrderBy).offset(0 as libc::c_int as isize)).desc
                as libc::c_int == 0 as libc::c_int
        {
            let iCol: libc::c_int = (*((*pIdx).aOrderBy)
                .offset(0 as libc::c_int as isize))
                .iColumn;
            if (*pIdx).nOrderBy == 1 as libc::c_int {
                (*pIdx)
                    .orderByConsumed = (iCol == 0 as libc::c_int
                    || iCol == 1 as libc::c_int) as libc::c_int;
            } else if (*pIdx).nOrderBy == 2 as libc::c_int
                && (*((*pIdx).aOrderBy).offset(1 as libc::c_int as isize)).desc
                    as libc::c_int == 0 as libc::c_int && iCol == 0 as libc::c_int
            {
                (*pIdx)
                    .orderByConsumed = ((*((*pIdx).aOrderBy)
                    .offset(1 as libc::c_int as isize))
                    .iColumn == 1 as libc::c_int) as libc::c_int;
            }
        }
    } else {
        (*pIdx).estimatedCost = 100000000 as libc::c_int as libc::c_double;
        (*pIdx).estimatedRows = 1000000000 as libc::c_int as sqlite3_int64;
    }
    (*pIdx)
        .idxNum = (if iSchema >= 0 as libc::c_int {
        0x1 as libc::c_int
    } else {
        0 as libc::c_int
    }) | (if iPgno >= 0 as libc::c_int { 0x2 as libc::c_int } else { 0 as libc::c_int });
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataOpen(
    pVTab: *mut sqlite3_vtab,
    ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = 0 as *mut DbdataCursor;
    pCsr = sqlite3_malloc64(
        ::core::mem::size_of::<DbdataCursor>() as libc::c_ulong as sqlite3_uint64,
    ) as *mut DbdataCursor;
    if pCsr.is_null() {
        return 7 as libc::c_int
    } else {
        memset(
            pCsr as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<DbdataCursor>() as libc::c_ulong,
        );
        (*pCsr).base.pVtab = pVTab;
    }
    *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataResetCursor(pCsr: *mut DbdataCursor) {
    let pTab: *mut DbdataTable = (*pCsr).base.pVtab as *mut DbdataTable;
    if ((*pTab).pStmt).is_null() {
        (*pTab).pStmt = (*pCsr).pStmt;
    } else {
        sqlite3_finalize((*pCsr).pStmt);
    }
    (*pCsr).pStmt = 0 as *mut sqlite3_stmt;
    (*pCsr).iPgno = 1 as libc::c_int;
    (*pCsr).iCell = 0 as libc::c_int;
    (*pCsr).iField = 0 as libc::c_int;
    (*pCsr).bOnePage = 0 as libc::c_int;
    sqlite3_free((*pCsr).aPage as *mut libc::c_void);
    sqlite3_free((*pCsr).pRec as *mut libc::c_void);
    (*pCsr).pRec = 0 as *mut u8_0;
    (*pCsr).aPage = 0 as *mut u8_0;
}
unsafe extern "C" fn dbdataClose(pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    dbdataResetCursor(pCsr);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn get_uint16(a: *mut libc::c_uchar) -> u32_0 {
    return ((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int
        | *a.offset(1 as libc::c_int as isize) as libc::c_int) as u32_0;
}
unsafe extern "C" fn get_uint32(a: *mut libc::c_uchar) -> u32_0 {
    return (*a.offset(0 as libc::c_int as isize) as u32_0) << 24 as libc::c_int
        | (*a.offset(1 as libc::c_int as isize) as u32_0) << 16 as libc::c_int
        | (*a.offset(2 as libc::c_int as isize) as u32_0) << 8 as libc::c_int
        | *a.offset(3 as libc::c_int as isize) as u32_0;
}
unsafe extern "C" fn dbdataLoadPage(
    pCsr: *mut DbdataCursor,
    pgno: u32_0,
    ppPage: *mut *mut u8_0,
    pnPage: *mut libc::c_int,
) -> libc::c_int {
    let mut rc2: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let pStmt: *mut sqlite3_stmt = (*pCsr).pStmt;
    *ppPage = 0 as *mut u8_0;
    *pnPage = 0 as libc::c_int;
    if pgno > 0 as libc::c_int as libc::c_uint {
        sqlite3_bind_int64(pStmt, 2 as libc::c_int, pgno as sqlite3_int64);
        if 100 as libc::c_int == sqlite3_step(pStmt) {
            let nCopy: libc::c_int = sqlite3_column_bytes(pStmt, 0 as libc::c_int);
            if nCopy > 0 as libc::c_int {
                let mut pPage: *mut u8_0 = 0 as *mut u8_0;
                pPage = sqlite3_malloc64((nCopy + 100 as libc::c_int) as sqlite3_uint64)
                    as *mut u8_0;
                if pPage.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    let pCopy: *const u8_0 = sqlite3_column_blob(
                        pStmt,
                        0 as libc::c_int,
                    ) as *const u8_0;
                    memcpy(
                        pPage as *mut libc::c_void,
                        pCopy as *const libc::c_void,
                        nCopy as libc::c_ulong,
                    );
                    memset(
                        &mut *pPage.offset(nCopy as isize) as *mut u8_0
                            as *mut libc::c_void,
                        0 as libc::c_int,
                        100 as libc::c_int as libc::c_ulong,
                    );
                }
                *ppPage = pPage;
                *pnPage = nCopy;
            }
        }
        rc2 = sqlite3_reset(pStmt);
        if rc == 0 as libc::c_int {
            rc = rc2;
        }
    }
    return rc;
}
unsafe extern "C" fn dbdataGetVarint(
    z: *const u8_0,
    pVal: *mut sqlite3_int64,
) -> libc::c_int {
    let mut u: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 8 as libc::c_int {
        u = (u << 7 as libc::c_int)
            .wrapping_add(
                (*z.offset(i as isize) as libc::c_int & 0x7f as libc::c_int)
                    as libc::c_ulonglong,
            );
        if *z.offset(i as isize) as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int
        {
            *pVal = u as sqlite3_int64;
            return i + 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    u = (u << 8 as libc::c_int)
        .wrapping_add(
            (*z.offset(i as isize) as libc::c_int & 0xff as libc::c_int)
                as libc::c_ulonglong,
        );
    *pVal = u as sqlite3_int64;
    return 9 as libc::c_int;
}
unsafe extern "C" fn dbdataGetVarintU32(
    z: *const u8_0,
    pVal: *mut sqlite3_int64,
) -> libc::c_int {
    let mut val: sqlite3_int64 = 0;
    let nRet: libc::c_int = dbdataGetVarint(z, &mut val);
    if val < 0 as libc::c_int as libc::c_longlong
        || val > 0xffffffff as libc::c_uint as libc::c_longlong
    {
        val = 0 as libc::c_int as sqlite3_int64;
    }
    *pVal = val;
    return nRet;
}
unsafe extern "C" fn dbdataValueBytes(eType: libc::c_int) -> libc::c_int {
    match eType {
        0 | 8 | 9 | 10 | 11 => return 0 as libc::c_int,
        1 => return 1 as libc::c_int,
        2 => return 2 as libc::c_int,
        3 => return 3 as libc::c_int,
        4 => return 4 as libc::c_int,
        5 => return 6 as libc::c_int,
        6 | 7 => return 8 as libc::c_int,
        _ => {
            if eType > 0 as libc::c_int {
                return (eType - 12 as libc::c_int) / 2 as libc::c_int;
            }
            return 0 as libc::c_int;
        }
    };
}
unsafe extern "C" fn dbdataValue(
    pCtx: *mut sqlite3_context,
    enc: u32_0,
    eType: libc::c_int,
    mut pData: *mut u8_0,
    nData: sqlite3_int64,
) {
    if eType >= 0 as libc::c_int && dbdataValueBytes(eType) as libc::c_longlong <= nData
    {
        match eType {
            0 | 10 | 11 => {
                sqlite3_result_null(pCtx);
            }
            8 => {
                sqlite3_result_int(pCtx, 0 as libc::c_int);
            }
            9 => {
                sqlite3_result_int(pCtx, 1 as libc::c_int);
            }
            1 | 2 | 3 | 4 | 5 | 6 | 7 => {
                let mut v: sqlite3_uint64 = *pData.offset(0 as libc::c_int as isize)
                    as libc::c_schar as sqlite3_uint64;
                pData = pData.offset(1);
                pData;
                let mut current_block_13: u64;
                match eType {
                    7 | 6 => {
                        v = (v << 16 as libc::c_int)
                            .wrapping_add(
                                ((*pData.offset(0 as libc::c_int as isize) as libc::c_int)
                                    << 8 as libc::c_int) as libc::c_ulonglong,
                            )
                            .wrapping_add(
                                *pData.offset(1 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(2 as libc::c_int as isize);
                        current_block_13 = 6780684019058957161;
                    }
                    5 => {
                        current_block_13 = 6780684019058957161;
                    }
                    4 => {
                        current_block_13 = 16238732563033592169;
                    }
                    3 => {
                        current_block_13 = 9577742939305649661;
                    }
                    2 => {
                        current_block_13 = 11242432845495741951;
                    }
                    _ => {
                        current_block_13 = 5143058163439228106;
                    }
                }
                match current_block_13 {
                    6780684019058957161 => {
                        v = (v << 16 as libc::c_int)
                            .wrapping_add(
                                ((*pData.offset(0 as libc::c_int as isize) as libc::c_int)
                                    << 8 as libc::c_int) as libc::c_ulonglong,
                            )
                            .wrapping_add(
                                *pData.offset(1 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(2 as libc::c_int as isize);
                        current_block_13 = 16238732563033592169;
                    }
                    _ => {}
                }
                match current_block_13 {
                    16238732563033592169 => {
                        v = (v << 8 as libc::c_int)
                            .wrapping_add(
                                *pData.offset(0 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(1);
                        pData;
                        current_block_13 = 9577742939305649661;
                    }
                    _ => {}
                }
                match current_block_13 {
                    9577742939305649661 => {
                        v = (v << 8 as libc::c_int)
                            .wrapping_add(
                                *pData.offset(0 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(1);
                        pData;
                        current_block_13 = 11242432845495741951;
                    }
                    _ => {}
                }
                match current_block_13 {
                    11242432845495741951 => {
                        v = (v << 8 as libc::c_int)
                            .wrapping_add(
                                *pData.offset(0 as libc::c_int as isize)
                                    as libc::c_ulonglong,
                            );
                        pData = pData.offset(1);
                        pData;
                    }
                    _ => {}
                }
                if eType == 7 as libc::c_int {
                    let mut r: libc::c_double = 0.;
                    memcpy(
                        &mut r as *mut libc::c_double as *mut libc::c_void,
                        &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                        ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    );
                    sqlite3_result_double(pCtx, r);
                } else {
                    sqlite3_result_int64(pCtx, v as sqlite3_int64);
                }
            }
            _ => {
                let n: libc::c_int = (eType - 12 as libc::c_int) / 2 as libc::c_int;
                if eType % 2 as libc::c_int != 0 {
                    match enc {
                        3 => {
                            sqlite3_result_text16be(
                                pCtx,
                                pData as *mut libc::c_void,
                                n,
                                ::core::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                        2 => {
                            sqlite3_result_text16le(
                                pCtx,
                                pData as *mut libc::c_void,
                                n,
                                ::core::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                        _ => {
                            sqlite3_result_text(
                                pCtx,
                                pData as *mut libc::c_char,
                                n,
                                ::core::mem::transmute::<
                                    libc::intptr_t,
                                    sqlite3_destructor_type,
                                >(-(1 as libc::c_int) as libc::intptr_t),
                            );
                        }
                    }
                } else {
                    sqlite3_result_blob(
                        pCtx,
                        pData as *const libc::c_void,
                        n,
                        ::core::mem::transmute::<
                            libc::intptr_t,
                            sqlite3_destructor_type,
                        >(-(1 as libc::c_int) as libc::intptr_t),
                    );
                }
            }
        }
    }
}
unsafe extern "C" fn dbdataNext(pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    (*pCsr).iRowid += 1;
    (*pCsr).iRowid;
    loop {
        let mut rc: libc::c_int = 0;
        let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
            100 as libc::c_int
        } else {
            0 as libc::c_int
        };
        let mut bNextPage: libc::c_int = 0 as libc::c_int;
        if ((*pCsr).aPage).is_null() {
            loop {
                if (*pCsr).bOnePage == 0 as libc::c_int && (*pCsr).iPgno > (*pCsr).szDb {
                    return 0 as libc::c_int;
                }
                rc = dbdataLoadPage(
                    pCsr,
                    (*pCsr).iPgno as u32_0,
                    &mut (*pCsr).aPage,
                    &mut (*pCsr).nPage,
                );
                if rc != 0 as libc::c_int {
                    return rc;
                }
                if !((*pCsr).aPage).is_null() && (*pCsr).nPage >= 256 as libc::c_int {
                    break;
                }
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                (*pCsr).aPage = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                }
                (*pCsr).iPgno += 1;
                (*pCsr).iPgno;
            }
            if iOff + 3 as libc::c_int + 2 as libc::c_int <= (*pCsr).nPage {} else {
                __assert_fail(
                    b"iOff+3+2<=pCsr->nPage\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    13871 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 38],
                        &[libc::c_char; 38],
                    >(b"int dbdataNext(sqlite3_vtab_cursor *)\0"))
                        .as_ptr(),
                );
            }
            'c_73295: {
                if iOff + 3 as libc::c_int + 2 as libc::c_int <= (*pCsr).nPage {} else {
                    __assert_fail(
                        b"iOff+3+2<=pCsr->nPage\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        13871 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 38],
                            &[libc::c_char; 38],
                        >(b"int dbdataNext(sqlite3_vtab_cursor *)\0"))
                            .as_ptr(),
                    );
                }
            };
            (*pCsr)
                .iCell = if (*pTab).bPtr != 0 {
                -(2 as libc::c_int)
            } else {
                0 as libc::c_int
            };
            (*pCsr)
                .nCell = get_uint16(
                &mut *((*pCsr).aPage).offset((iOff + 3 as libc::c_int) as isize),
            ) as libc::c_int;
        }
        if (*pTab).bPtr != 0 {
            if *((*pCsr).aPage).offset(iOff as isize) as libc::c_int
                != 0x2 as libc::c_int
                && *((*pCsr).aPage).offset(iOff as isize) as libc::c_int
                    != 0x5 as libc::c_int
            {
                (*pCsr).iCell = (*pCsr).nCell;
            }
            (*pCsr).iCell += 1;
            (*pCsr).iCell;
            if (*pCsr).iCell >= (*pCsr).nCell {
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                (*pCsr).aPage = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                }
                (*pCsr).iPgno += 1;
                (*pCsr).iPgno;
            } else {
                return 0 as libc::c_int
            }
        } else {
            if ((*pCsr).pRec).is_null() {
                let mut bHasRowid: libc::c_int = 0 as libc::c_int;
                let mut nPointer: libc::c_int = 0 as libc::c_int;
                let mut nPayload: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
                let mut nHdr: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
                let mut iHdr: libc::c_int = 0;
                let mut U: libc::c_int = 0;
                let mut X: libc::c_int = 0;
                let mut nLocal: libc::c_int = 0;
                match *((*pCsr).aPage).offset(iOff as isize) as libc::c_int {
                    2 => {
                        nPointer = 4 as libc::c_int;
                    }
                    10 => {}
                    13 => {
                        bHasRowid = 1 as libc::c_int;
                    }
                    _ => {
                        (*pCsr).iCell = (*pCsr).nCell;
                    }
                }
                if (*pCsr).iCell >= (*pCsr).nCell {
                    bNextPage = 1 as libc::c_int;
                } else {
                    iOff
                        += 8 as libc::c_int + nPointer
                            + (*pCsr).iCell * 2 as libc::c_int;
                    if iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        iOff = get_uint16(&mut *((*pCsr).aPage).offset(iOff as isize))
                            as libc::c_int;
                    }
                    iOff += nPointer;
                    if bNextPage != 0 || iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        iOff
                            += dbdataGetVarintU32(
                                &mut *((*pCsr).aPage).offset(iOff as isize),
                                &mut nPayload,
                            );
                    }
                    if bHasRowid != 0 && bNextPage == 0 && iOff < (*pCsr).nPage {
                        iOff
                            += dbdataGetVarint(
                                &mut *((*pCsr).aPage).offset(iOff as isize),
                                &mut (*pCsr).iIntkey,
                            );
                    }
                    U = (*pCsr).nPage;
                    if bHasRowid != 0 {
                        X = U - 35 as libc::c_int;
                    } else {
                        X = (U - 12 as libc::c_int) * 64 as libc::c_int
                            / 255 as libc::c_int - 23 as libc::c_int;
                    }
                    if nPayload <= X as libc::c_longlong {
                        nLocal = nPayload as libc::c_int;
                    } else {
                        let mut M: libc::c_int = 0;
                        let mut K: libc::c_int = 0;
                        M = (U - 12 as libc::c_int) * 32 as libc::c_int
                            / 255 as libc::c_int - 23 as libc::c_int;
                        K = (M as libc::c_longlong
                            + (nPayload - M as libc::c_longlong)
                                % (U - 4 as libc::c_int) as libc::c_longlong)
                            as libc::c_int;
                        if K <= X {
                            nLocal = K;
                        } else {
                            nLocal = M;
                        }
                    }
                    if bNextPage != 0 || nLocal + iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        (*pCsr)
                            .pRec = sqlite3_malloc64(
                            (nPayload + 100 as libc::c_int as libc::c_longlong)
                                as sqlite3_uint64,
                        ) as *mut u8_0;
                        if ((*pCsr).pRec).is_null() {
                            return 7 as libc::c_int;
                        }
                        memset(
                            (*pCsr).pRec as *mut libc::c_void,
                            0 as libc::c_int,
                            (nPayload + 100 as libc::c_int as libc::c_longlong)
                                as libc::c_ulong,
                        );
                        (*pCsr).nRec = nPayload;
                        memcpy(
                            (*pCsr).pRec as *mut libc::c_void,
                            &mut *((*pCsr).aPage).offset(iOff as isize) as *mut u8_0
                                as *const libc::c_void,
                            nLocal as libc::c_ulong,
                        );
                        iOff += nLocal;
                        if nPayload > nLocal as libc::c_longlong {
                            let mut nRem: sqlite3_int64 = nPayload
                                - nLocal as libc::c_longlong;
                            let mut pgnoOvfl: u32_0 = get_uint32(
                                &mut *((*pCsr).aPage).offset(iOff as isize),
                            );
                            while nRem > 0 as libc::c_int as libc::c_longlong {
                                let mut aOvfl: *mut u8_0 = 0 as *mut u8_0;
                                let mut nOvfl: libc::c_int = 0 as libc::c_int;
                                let mut nCopy: libc::c_int = 0;
                                rc = dbdataLoadPage(pCsr, pgnoOvfl, &mut aOvfl, &mut nOvfl);
                                if rc != 0 as libc::c_int || aOvfl.is_null()
                                    || nOvfl == (*pCsr).nPage
                                {} else {
                                    __assert_fail(
                                        b"rc!=SQLITE_OK || aOvfl==0 || nOvfl==pCsr->nPage\0"
                                            as *const u8 as *const libc::c_char,
                                        b"shell.c\0" as *const u8 as *const libc::c_char,
                                        13986 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 38],
                                            &[libc::c_char; 38],
                                        >(b"int dbdataNext(sqlite3_vtab_cursor *)\0"))
                                            .as_ptr(),
                                    );
                                }
                                'c_72548: {
                                    if rc != 0 as libc::c_int || aOvfl.is_null()
                                        || nOvfl == (*pCsr).nPage
                                    {} else {
                                        __assert_fail(
                                            b"rc!=SQLITE_OK || aOvfl==0 || nOvfl==pCsr->nPage\0"
                                                as *const u8 as *const libc::c_char,
                                            b"shell.c\0" as *const u8 as *const libc::c_char,
                                            13986 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 38],
                                                &[libc::c_char; 38],
                                            >(b"int dbdataNext(sqlite3_vtab_cursor *)\0"))
                                                .as_ptr(),
                                        );
                                    }
                                };
                                if rc != 0 as libc::c_int {
                                    return rc;
                                }
                                if aOvfl.is_null() {
                                    break;
                                }
                                nCopy = U - 4 as libc::c_int;
                                if nCopy as libc::c_longlong > nRem {
                                    nCopy = nRem as libc::c_int;
                                }
                                memcpy(
                                    &mut *((*pCsr).pRec).offset((nPayload - nRem) as isize)
                                        as *mut u8_0 as *mut libc::c_void,
                                    &mut *aOvfl.offset(4 as libc::c_int as isize) as *mut u8_0
                                        as *const libc::c_void,
                                    nCopy as libc::c_ulong,
                                );
                                nRem -= nCopy as libc::c_longlong;
                                pgnoOvfl = get_uint32(aOvfl);
                                sqlite3_free(aOvfl as *mut libc::c_void);
                            }
                        }
                        iHdr = dbdataGetVarintU32((*pCsr).pRec, &mut nHdr);
                        if nHdr > nPayload {
                            nHdr = 0 as libc::c_int as sqlite3_int64;
                        }
                        (*pCsr).nHdr = nHdr;
                        (*pCsr)
                            .pHdrPtr = &mut *((*pCsr).pRec).offset(iHdr as isize)
                            as *mut u8_0;
                        (*pCsr)
                            .pPtr = &mut *((*pCsr).pRec).offset((*pCsr).nHdr as isize)
                            as *mut u8_0;
                        (*pCsr)
                            .iField = if bHasRowid != 0 {
                            -(1 as libc::c_int)
                        } else {
                            0 as libc::c_int
                        };
                    }
                }
            } else {
                (*pCsr).iField += 1;
                (*pCsr).iField;
                if (*pCsr).iField > 0 as libc::c_int {
                    let mut iType: sqlite3_int64 = 0;
                    if (*pCsr).pHdrPtr
                        > &mut *((*pCsr).pRec).offset((*pCsr).nRec as isize) as *mut u8_0
                    {
                        bNextPage = 1 as libc::c_int;
                    } else {
                        let mut szField: libc::c_int = 0 as libc::c_int;
                        (*pCsr)
                            .pHdrPtr = ((*pCsr).pHdrPtr)
                            .offset(
                                dbdataGetVarintU32((*pCsr).pHdrPtr, &mut iType) as isize,
                            );
                        szField = dbdataValueBytes(iType as libc::c_int);
                        if ((*pCsr).nRec
                            - ((*pCsr).pPtr).offset_from((*pCsr).pRec) as libc::c_long
                                as libc::c_longlong) < szField as libc::c_longlong
                        {
                            (*pCsr)
                                .pPtr = &mut *((*pCsr).pRec).offset((*pCsr).nRec as isize)
                                as *mut u8_0;
                        } else {
                            (*pCsr).pPtr = ((*pCsr).pPtr).offset(szField as isize);
                        }
                    }
                }
            }
            if bNextPage != 0 {
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                sqlite3_free((*pCsr).pRec as *mut libc::c_void);
                (*pCsr).aPage = 0 as *mut u8_0;
                (*pCsr).pRec = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                }
                (*pCsr).iPgno += 1;
                (*pCsr).iPgno;
            } else {
                if (*pCsr).iField < 0 as libc::c_int
                    || (*pCsr).pHdrPtr
                        < &mut *((*pCsr).pRec).offset((*pCsr).nHdr as isize) as *mut u8_0
                {
                    return 0 as libc::c_int;
                }
                sqlite3_free((*pCsr).pRec as *mut libc::c_void);
                (*pCsr).pRec = 0 as *mut u8_0;
                (*pCsr).iCell += 1;
                (*pCsr).iCell;
            }
        }
    };
}
unsafe extern "C" fn dbdataEof(pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    return ((*pCsr).aPage == 0 as *mut u8_0) as libc::c_int;
}
unsafe extern "C" fn dbdataIsFunction(zSchema: *const libc::c_char) -> libc::c_int {
    let n: size_t = strlen(zSchema);
    if n > 2 as libc::c_int as libc::c_ulong
        && *zSchema.offset(n.wrapping_sub(2 as libc::c_int as libc::c_ulong) as isize)
            as libc::c_int == '(' as i32
        && *zSchema.offset(n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize)
            as libc::c_int == ')' as i32
    {
        return n as libc::c_int - 2 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataDbsize(
    pCsr: *mut DbdataCursor,
    zSchema: *const libc::c_char,
) -> libc::c_int {
    let pTab: *mut DbdataTable = (*pCsr).base.pVtab as *mut DbdataTable;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut nFunc: libc::c_int = 0 as libc::c_int;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    nFunc = dbdataIsFunction(zSchema);
    if nFunc > 0 as libc::c_int {
        zSql = sqlite3_mprintf(
            b"SELECT %.*s(0)\0" as *const u8 as *const libc::c_char,
            nFunc,
            zSchema,
        );
    } else {
        zSql = sqlite3_mprintf(
            b"PRAGMA %Q.page_count\0" as *const u8 as *const libc::c_char,
            zSchema,
        );
    }
    if zSql.is_null() {
        return 7 as libc::c_int;
    }
    rc = sqlite3_prepare_v2(
        (*pTab).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    if rc == 0 as libc::c_int && sqlite3_step(pStmt) == 100 as libc::c_int {
        (*pCsr).szDb = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    rc2 = sqlite3_finalize(pStmt);
    if rc == 0 as libc::c_int {
        rc = rc2;
    }
    return rc;
}
unsafe extern "C" fn dbdataGetEncoding(pCsr: *mut DbdataCursor) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nPg1: libc::c_int = 0 as libc::c_int;
    let mut aPg1: *mut u8_0 = 0 as *mut u8_0;
    rc = dbdataLoadPage(pCsr, 1 as libc::c_int as u32_0, &mut aPg1, &mut nPg1);
    if rc == 0 as libc::c_int && nPg1 >= 56 as libc::c_int + 4 as libc::c_int {
        (*pCsr).enc = get_uint32(&mut *aPg1.offset(56 as libc::c_int as isize));
    }
    sqlite3_free(aPg1 as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn dbdataFilter(
    pCursor: *mut sqlite3_vtab_cursor,
    idxNum: libc::c_int,
    _idxStr: *const libc::c_char,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zSchema: *const libc::c_char = b"main\0" as *const u8 as *const libc::c_char;
    dbdataResetCursor(pCsr);
    if (*pCsr).iPgno == 1 as libc::c_int {} else {
        __assert_fail(
            b"pCsr->iPgno==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14136 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 82],
                &[libc::c_char; 82],
            >(
                b"int dbdataFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
            ))
                .as_ptr(),
        );
    }
    'c_74002: {
        if (*pCsr).iPgno == 1 as libc::c_int {} else {
            __assert_fail(
                b"pCsr->iPgno==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                14136 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 82],
                    &[libc::c_char; 82],
                >(
                    b"int dbdataFilter(sqlite3_vtab_cursor *, int, const char *, int, sqlite3_value **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    if idxNum & 0x1 as libc::c_int != 0 {
        zSchema = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
            as *const libc::c_char;
        if zSchema.is_null() {
            zSchema = b"\0" as *const u8 as *const libc::c_char;
        }
    }
    if idxNum & 0x2 as libc::c_int != 0 {
        (*pCsr)
            .iPgno = sqlite3_value_int(
            *argv.offset((idxNum & 0x1 as libc::c_int) as isize),
        );
        (*pCsr).bOnePage = 1 as libc::c_int;
    } else {
        rc = dbdataDbsize(pCsr, zSchema);
    }
    if rc == 0 as libc::c_int {
        let mut nFunc: libc::c_int = 0 as libc::c_int;
        if !((*pTab).pStmt).is_null() {
            (*pCsr).pStmt = (*pTab).pStmt;
            (*pTab).pStmt = 0 as *mut sqlite3_stmt;
        } else {
            nFunc = dbdataIsFunction(zSchema);
            if nFunc > 0 as libc::c_int {
                let zSql: *mut libc::c_char = sqlite3_mprintf(
                    b"SELECT %.*s(?2)\0" as *const u8 as *const libc::c_char,
                    nFunc,
                    zSchema,
                );
                if zSql.is_null() {
                    rc = 7 as libc::c_int;
                } else {
                    rc = sqlite3_prepare_v2(
                        (*pTab).db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut (*pCsr).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql as *mut libc::c_void);
                }
            } else {
                rc = sqlite3_prepare_v2(
                    (*pTab).db,
                    b"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\0" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut (*pCsr).pStmt,
                    0 as *mut *const libc::c_char,
                );
            }
        }
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_bind_text(
            (*pCsr).pStmt,
            1 as libc::c_int,
            zSchema,
            -(1 as libc::c_int),
            ::core::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
    }
    if rc == 0 as libc::c_int {
        rc = dbdataGetEncoding(pCsr);
    }
    if rc != 0 as libc::c_int {
        (*pTab)
            .base
            .zErrMsg = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg((*pTab).db),
        );
    }
    if rc == 0 as libc::c_int {
        rc = dbdataNext(pCursor);
    }
    return rc;
}
unsafe extern "C" fn dbdataColumn(
    pCursor: *mut sqlite3_vtab_cursor,
    ctx: *mut sqlite3_context,
    i: libc::c_int,
) -> libc::c_int {
    let pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    if (*pTab).bPtr != 0 {
        match i {
            0 => {
                sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
            }
            1 => {
                let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
                    100 as libc::c_int
                } else {
                    0 as libc::c_int
                };
                if (*pCsr).iCell < 0 as libc::c_int {
                    iOff += 8 as libc::c_int;
                } else {
                    iOff += 12 as libc::c_int + (*pCsr).iCell * 2 as libc::c_int;
                    if iOff > (*pCsr).nPage {
                        return 0 as libc::c_int;
                    }
                    iOff = get_uint16(&mut *((*pCsr).aPage).offset(iOff as isize))
                        as libc::c_int;
                }
                if iOff <= (*pCsr).nPage {
                    sqlite3_result_int64(
                        ctx,
                        get_uint32(&mut *((*pCsr).aPage).offset(iOff as isize))
                            as sqlite3_int64,
                    );
                }
            }
            _ => {}
        }
    } else {
        match i {
            0 => {
                sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
            }
            1 => {
                sqlite3_result_int(ctx, (*pCsr).iCell);
            }
            2 => {
                sqlite3_result_int(ctx, (*pCsr).iField);
            }
            3 => {
                if (*pCsr).iField < 0 as libc::c_int {
                    sqlite3_result_int64(ctx, (*pCsr).iIntkey);
                } else if &mut *((*pCsr).pRec).offset((*pCsr).nRec as isize) as *mut u8_0
                    >= (*pCsr).pPtr
                {
                    let mut iType: sqlite3_int64 = 0;
                    dbdataGetVarintU32((*pCsr).pHdrPtr, &mut iType);
                    dbdataValue(
                        ctx,
                        (*pCsr).enc,
                        iType as libc::c_int,
                        (*pCsr).pPtr,
                        (&mut *((*pCsr).pRec).offset((*pCsr).nRec as isize) as *mut u8_0)
                            .offset_from((*pCsr).pPtr) as libc::c_long as sqlite3_int64,
                    );
                }
            }
            _ => {}
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn dbdataRowid(
    pCursor: *mut sqlite3_vtab_cursor,
    pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    *pRowid = (*pCsr).iRowid;
    return 0 as libc::c_int;
}
unsafe extern "C" fn sqlite3DbdataRegister(db: *mut sqlite3) -> libc::c_int {
    static mut dbdata_module: sqlite3_module = unsafe {
        {
            let init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    dbdataConnect
                        as unsafe extern "C" fn(
                            *mut sqlite3,
                            *mut libc::c_void,
                            libc::c_int,
                            *const *const libc::c_char,
                            *mut *mut sqlite3_vtab,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    dbdataBestIndex
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    dbdataDisconnect
                        as unsafe extern "C" fn(*mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    dbdataOpen
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab,
                            *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    dbdataClose
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    dbdataFilter
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            libc::c_int,
                            *const libc::c_char,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    dbdataNext
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    dbdataEof
                        as unsafe extern "C" fn(*mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    dbdataColumn
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite3_context,
                            libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    dbdataRowid
                        as unsafe extern "C" fn(
                            *mut sqlite3_vtab_cursor,
                            *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"sqlite_dbdata\0" as *const u8 as *const libc::c_char,
        &mut dbdata_module,
        0 as *mut libc::c_void,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_module(
            db,
            b"sqlite_dbptr\0" as *const u8 as *const libc::c_char,
            &mut dbdata_module,
            1 as libc::c_int as *mut libc::c_void,
        );
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_dbdata_init(
    db: *mut sqlite3,
    _pzErrMsg: *mut *mut libc::c_char,
    _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3DbdataRegister(db);
}
static mut recover_g: RecoverGlobal = RecoverGlobal {
    pMethods: 0 as *const sqlite3_io_methods,
    p: 0 as *const sqlite3_recover as *mut sqlite3_recover,
};
unsafe extern "C" fn recoverEnterMutex() {
    sqlite3_mutex_enter(sqlite3_mutex_alloc(9 as libc::c_int));
}
unsafe extern "C" fn recoverLeaveMutex() {
    sqlite3_mutex_leave(sqlite3_mutex_alloc(9 as libc::c_int));
}
unsafe extern "C" fn recoverStrlen(zStr: *const libc::c_char) -> libc::c_int {
    if zStr.is_null() {
        return 0 as libc::c_int;
    }
    return (strlen(zStr) & 0x7fffffff as libc::c_int as libc::c_ulong) as libc::c_int;
}
unsafe extern "C" fn recoverMalloc(
    p: *mut sqlite3_recover,
    nByte: i64_0,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    if nByte > 0 as libc::c_int as libc::c_longlong {} else {
        __assert_fail(
            b"nByte>0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14638 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 44],
                &[libc::c_char; 44],
            >(b"void *recoverMalloc(sqlite3_recover *, i64)\0"))
                .as_ptr(),
        );
    }
    'c_65044: {
        if nByte > 0 as libc::c_int as libc::c_longlong {} else {
            __assert_fail(
                b"nByte>0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                14638 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 44],
                    &[libc::c_char; 44],
                >(b"void *recoverMalloc(sqlite3_recover *, i64)\0"))
                    .as_ptr(),
            );
        }
    };
    if (*p).errCode == 0 as libc::c_int {
        pRet = sqlite3_malloc64(nByte as sqlite3_uint64);
        if !pRet.is_null() {
            memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
        } else {
            (*p).errCode = 7 as libc::c_int;
        }
    }
    return pRet;
}
unsafe extern "C" fn recoverError(
    p: *mut sqlite3_recover,
    errCode: libc::c_int,
    zFmt: *const libc::c_char,
    args: ...
) -> libc::c_int {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::core::ffi::VaListImpl;
    ap = args.clone();
    if !zFmt.is_null() {
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    }
    sqlite3_free((*p).zErrMsg as *mut libc::c_void);
    (*p).zErrMsg = z;
    (*p).errCode = errCode;
    return errCode;
}
unsafe extern "C" fn recoverBitmapAlloc(
    p: *mut sqlite3_recover,
    nPg: i64_0,
) -> *mut RecoverBitmap {
    let nElem: libc::c_int = ((nPg + 1 as libc::c_int as libc::c_longlong
        + 31 as libc::c_int as libc::c_longlong) / 32 as libc::c_int as libc::c_longlong)
        as libc::c_int;
    let nByte: libc::c_int = (::core::mem::size_of::<RecoverBitmap>()
        as libc::c_ulong)
        .wrapping_add(
            (nElem as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<u32_0>() as libc::c_ulong),
        ) as libc::c_int;
    let pRet: *mut RecoverBitmap = recoverMalloc(p, nByte as i64_0)
        as *mut RecoverBitmap;
    if !pRet.is_null() {
        (*pRet).nPg = nPg;
    }
    return pRet;
}
unsafe extern "C" fn recoverBitmapFree(pMap: *mut RecoverBitmap) {
    sqlite3_free(pMap as *mut libc::c_void);
}
unsafe extern "C" fn recoverBitmapSet(pMap: *mut RecoverBitmap, iPg: i64_0) {
    if iPg <= (*pMap).nPg {
        let iElem: libc::c_int = (iPg / 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        let iBit: libc::c_int = (iPg % 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        let ref mut fresh54 = *((*pMap).aElem).as_mut_ptr().offset(iElem as isize);
        *fresh54 |= (1 as libc::c_int as u32_0) << iBit;
    }
}
unsafe extern "C" fn recoverBitmapQuery(
    pMap: *mut RecoverBitmap,
    iPg: i64_0,
) -> libc::c_int {
    let mut ret: libc::c_int = 1 as libc::c_int;
    if iPg <= (*pMap).nPg && iPg > 0 as libc::c_int as libc::c_longlong {
        let iElem: libc::c_int = (iPg / 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        let iBit: libc::c_int = (iPg % 32 as libc::c_int as libc::c_longlong)
            as libc::c_int;
        ret = if *((*pMap).aElem).as_mut_ptr().offset(iElem as isize)
            & (1 as libc::c_int as u32_0) << iBit != 0
        {
            1 as libc::c_int
        } else {
            0 as libc::c_int
        };
    }
    return ret;
}
unsafe extern "C" fn recoverDbError(
    p: *mut sqlite3_recover,
    db: *mut sqlite3,
) -> libc::c_int {
    return recoverError(
        p,
        sqlite3_errcode(db),
        b"%s\0" as *const u8 as *const libc::c_char,
        sqlite3_errmsg(db),
    );
}
unsafe extern "C" fn recoverPrepare(
    p: *mut sqlite3_recover,
    db: *mut sqlite3,
    zSql: *const libc::c_char,
) -> *mut sqlite3_stmt {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if (*p).errCode == 0 as libc::c_int {
        if sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        ) != 0
        {
            recoverDbError(p, db);
        }
    }
    return pStmt;
}
unsafe extern "C" fn recoverPreparePrintf(
    p: *mut sqlite3_recover,
    db: *mut sqlite3,
    zFmt: *const libc::c_char,
    args: ...
) -> *mut sqlite3_stmt {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if (*p).errCode == 0 as libc::c_int {
        let mut ap: ::core::ffi::VaListImpl;
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            (*p).errCode = 7 as libc::c_int;
        } else {
            pStmt = recoverPrepare(p, db, z);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
    return pStmt;
}
unsafe extern "C" fn recoverReset(
    p: *mut sqlite3_recover,
    pStmt: *mut sqlite3_stmt,
) -> *mut sqlite3_stmt {
    let rc: libc::c_int = sqlite3_reset(pStmt);
    if rc != 0 as libc::c_int && rc != 19 as libc::c_int
        && (*p).errCode == 0 as libc::c_int
    {
        recoverDbError(p, sqlite3_db_handle(pStmt));
    }
    return pStmt;
}
unsafe extern "C" fn recoverFinalize(
    p: *mut sqlite3_recover,
    pStmt: *mut sqlite3_stmt,
) {
    let db: *mut sqlite3 = sqlite3_db_handle(pStmt);
    let rc: libc::c_int = sqlite3_finalize(pStmt);
    if rc != 0 as libc::c_int && (*p).errCode == 0 as libc::c_int {
        recoverDbError(p, db);
    }
}
unsafe extern "C" fn recoverExec(
    p: *mut sqlite3_recover,
    db: *mut sqlite3,
    zSql: *const libc::c_char,
) -> libc::c_int {
    if (*p).errCode == 0 as libc::c_int {
        let rc: libc::c_int = sqlite3_exec(
            db,
            zSql,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        if rc != 0 {
            recoverDbError(p, db);
        }
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverBindValue(
    p: *mut sqlite3_recover,
    pStmt: *mut sqlite3_stmt,
    iBind: libc::c_int,
    pVal: *mut sqlite3_value,
) {
    if (*p).errCode == 0 as libc::c_int {
        let rc: libc::c_int = sqlite3_bind_value(pStmt, iBind, pVal);
        if rc != 0 {
            recoverError(p, rc, 0 as *const libc::c_char);
        }
    }
}
unsafe extern "C" fn recoverMPrintf(
    p: *mut sqlite3_recover,
    zFmt: *const libc::c_char,
    args: ...
) -> *mut libc::c_char {
    let mut ap: ::core::ffi::VaListImpl;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    if (*p).errCode == 0 as libc::c_int {
        if z.is_null() {
            (*p).errCode = 7 as libc::c_int;
        }
    } else {
        sqlite3_free(z as *mut libc::c_void);
        z = 0 as *mut libc::c_char;
    }
    return z;
}
unsafe extern "C" fn recoverPageCount(p: *mut sqlite3_recover) -> i64_0 {
    let mut nPg: i64_0 = 0 as libc::c_int as i64_0;
    if (*p).errCode == 0 as libc::c_int {
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        pStmt = recoverPreparePrintf(
            p,
            (*p).dbIn,
            b"PRAGMA %Q.page_count\0" as *const u8 as *const libc::c_char,
            (*p).zDb,
        );
        if !pStmt.is_null() {
            sqlite3_step(pStmt);
            nPg = sqlite3_column_int64(pStmt, 0 as libc::c_int);
        }
        recoverFinalize(p, pStmt);
    }
    return nPg;
}
unsafe extern "C" fn recoverReadI32(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut pBlob: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut nBlob: libc::c_int = 0;
    let mut iInt: libc::c_int = 0;
    if argc == 2 as libc::c_int {} else {
        __assert_fail(
            b"argc==2\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14934 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 62],
                &[libc::c_char; 62],
            >(b"void recoverReadI32(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_70455: {
        if argc == 2 as libc::c_int {} else {
            __assert_fail(
                b"argc==2\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                14934 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 62],
                    &[libc::c_char; 62],
                >(b"void recoverReadI32(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    nBlob = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
    pBlob = sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize))
        as *const libc::c_uchar;
    iInt = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize))
        & 0xffff as libc::c_int;
    if (iInt + 1 as libc::c_int) * 4 as libc::c_int <= nBlob {
        let a: *const libc::c_uchar = &*pBlob
            .offset((iInt * 4 as libc::c_int) as isize) as *const libc::c_uchar;
        let iVal: i64_0 = ((*a.offset(0 as libc::c_int as isize) as i64_0)
            << 24 as libc::c_int)
            + ((*a.offset(1 as libc::c_int as isize) as i64_0) << 16 as libc::c_int)
            + ((*a.offset(2 as libc::c_int as isize) as i64_0) << 8 as libc::c_int)
            + ((*a.offset(3 as libc::c_int as isize) as i64_0) << 0 as libc::c_int);
        sqlite3_result_int64(context, iVal);
    }
}
unsafe extern "C" fn recoverPageIsUsed(
    pCtx: *mut sqlite3_context,
    nArg: libc::c_int,
    apArg: *mut *mut sqlite3_value,
) {
    let p: *mut sqlite3_recover = sqlite3_user_data(pCtx) as *mut sqlite3_recover;
    let pgno: i64_0 = sqlite3_value_int64(*apArg.offset(0 as libc::c_int as isize));
    if nArg == 1 as libc::c_int {} else {
        __assert_fail(
            b"nArg==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14968 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 65],
                &[libc::c_char; 65],
            >(b"void recoverPageIsUsed(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_70536: {
        if nArg == 1 as libc::c_int {} else {
            __assert_fail(
                b"nArg==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                14968 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 65],
                    &[libc::c_char; 65],
                >(b"void recoverPageIsUsed(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    sqlite3_result_int(pCtx, recoverBitmapQuery((*p).laf.pUsed, pgno));
}
unsafe extern "C" fn recoverGetPage(
    pCtx: *mut sqlite3_context,
    nArg: libc::c_int,
    apArg: *mut *mut sqlite3_value,
) {
    let p: *mut sqlite3_recover = sqlite3_user_data(pCtx) as *mut sqlite3_recover;
    let pgno: i64_0 = sqlite3_value_int64(*apArg.offset(0 as libc::c_int as isize));
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if nArg == 1 as libc::c_int {} else {
        __assert_fail(
            b"nArg==1\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            14995 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 62],
                &[libc::c_char; 62],
            >(b"void recoverGetPage(sqlite3_context *, int, sqlite3_value **)\0"))
                .as_ptr(),
        );
    }
    'c_70863: {
        if nArg == 1 as libc::c_int {} else {
            __assert_fail(
                b"nArg==1\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                14995 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 62],
                    &[libc::c_char; 62],
                >(b"void recoverGetPage(sqlite3_context *, int, sqlite3_value **)\0"))
                    .as_ptr(),
            );
        }
    };
    if pgno == 0 as libc::c_int as libc::c_longlong {
        let nPg: i64_0 = recoverPageCount(p);
        sqlite3_result_int64(pCtx, nPg);
        return;
    } else {
        if ((*p).pGetPage).is_null() {
            (*p)
                .pGetPage = recoverPreparePrintf(
                p,
                (*p).dbIn,
                b"SELECT data FROM sqlite_dbpage(%Q) WHERE pgno=?\0" as *const u8
                    as *const libc::c_char,
                (*p).zDb,
            );
            pStmt = (*p).pGetPage;
        } else if (*p).errCode == 0 as libc::c_int {
            pStmt = (*p).pGetPage;
        }
        if !pStmt.is_null() {
            sqlite3_bind_int64(pStmt, 1 as libc::c_int, pgno);
            if 100 as libc::c_int == sqlite3_step(pStmt) {
                let mut aPg: *const u8_0 = 0 as *const u8_0;
                let mut nPg_0: libc::c_int = 0;
                if (*p).errCode == 0 as libc::c_int {} else {
                    __assert_fail(
                        b"p->errCode==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        15014 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 62],
                            &[libc::c_char; 62],
                        >(
                            b"void recoverGetPage(sqlite3_context *, int, sqlite3_value **)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_70743: {
                    if (*p).errCode == 0 as libc::c_int {} else {
                        __assert_fail(
                            b"p->errCode==SQLITE_OK\0" as *const u8
                                as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            15014 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 62],
                                &[libc::c_char; 62],
                            >(
                                b"void recoverGetPage(sqlite3_context *, int, sqlite3_value **)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                aPg = sqlite3_column_blob(pStmt, 0 as libc::c_int) as *const u8_0;
                nPg_0 = sqlite3_column_bytes(pStmt, 0 as libc::c_int);
                if pgno == 1 as libc::c_int as libc::c_longlong && nPg_0 == (*p).pgsz
                    && 0 as libc::c_int
                        == memcmp(
                            (*p).pPage1Cache as *const libc::c_void,
                            aPg as *const libc::c_void,
                            nPg_0 as libc::c_ulong,
                        )
                {
                    aPg = (*p).pPage1Disk;
                }
                sqlite3_result_blob(
                    pCtx,
                    aPg as *const libc::c_void,
                    nPg_0 - (*p).nReserve,
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            }
            recoverReset(p, pStmt);
        }
    }
    if (*p).errCode != 0 {
        if !((*p).zErrMsg).is_null() {
            sqlite3_result_error(pCtx, (*p).zErrMsg, -(1 as libc::c_int));
        }
        sqlite3_result_error_code(pCtx, (*p).errCode);
    }
}
unsafe extern "C" fn recoverUnusedString(
    z: *const libc::c_char,
    zA: *const libc::c_char,
    zB: *const libc::c_char,
    zBuf: *mut libc::c_char,
) -> *const libc::c_char {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if (strstr(z, zA)).is_null() {
        return zA;
    }
    if (strstr(z, zB)).is_null() {
        return zB;
    }
    loop {
        let fresh55 = i;
        i = i.wrapping_add(1);
        sqlite3_snprintf(
            20 as libc::c_int,
            zBuf,
            b"(%s%u)\0" as *const u8 as *const libc::c_char,
            zA,
            fresh55,
        );
        if (strstr(z, zBuf)).is_null() {
            break;
        }
    }
    return zBuf;
}
unsafe extern "C" fn recoverEscapeCrnl(
    context: *mut sqlite3_context,
    _argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let zText: *const libc::c_char = sqlite3_value_text(
        *argv.offset(0 as libc::c_int as isize),
    ) as *const libc::c_char;
    if !zText.is_null()
        && *zText.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32
    {
        let nText: libc::c_int = sqlite3_value_bytes(
            *argv.offset(0 as libc::c_int as isize),
        );
        let mut i: libc::c_int = 0;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while *zText.offset(i as isize) != 0 {
            if zNL.is_null() && *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                zNL = recoverUnusedString(
                    zText,
                    b"\\n\0" as *const u8 as *const libc::c_char,
                    b"\\012\0" as *const u8 as *const libc::c_char,
                    zBuf1.as_mut_ptr(),
                );
                nNL = strlen(zNL) as libc::c_int;
            }
            if zCR.is_null() && *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                zCR = recoverUnusedString(
                    zText,
                    b"\\r\0" as *const u8 as *const libc::c_char,
                    b"\\015\0" as *const u8 as *const libc::c_char,
                    zBuf2.as_mut_ptr(),
                );
                nCR = strlen(zCR) as libc::c_int;
            }
            i += 1;
            i;
        }
        if !zNL.is_null() || !zCR.is_null() {
            let mut iOut: libc::c_int = 0 as libc::c_int;
            let nMax: i64_0 = (if nNL > nCR { nNL } else { nCR }) as i64_0;
            let nAlloc: i64_0 = nMax * nText as libc::c_longlong
                + (nMax + 64 as libc::c_int as libc::c_longlong)
                    * 2 as libc::c_int as libc::c_longlong;
            let zOut: *mut libc::c_char = sqlite3_malloc64(nAlloc as sqlite3_uint64)
                as *mut libc::c_char;
            if zOut.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            }
            if !zNL.is_null() && !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    16 as libc::c_int as libc::c_ulong,
                );
                iOut += 16 as libc::c_int;
            } else {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"replace(\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    8 as libc::c_int as libc::c_ulong,
                );
                iOut += 8 as libc::c_int;
            }
            i = 0 as libc::c_int;
            while *zText.offset(i as isize) != 0 {
                if *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zNL as *const libc::c_void,
                        nNL as libc::c_ulong,
                    );
                    iOut += nNL;
                } else if *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                            as *mut libc::c_void,
                        zCR as *const libc::c_void,
                        nCR as libc::c_ulong,
                    );
                    iOut += nCR;
                } else {
                    *zOut.offset(iOut as isize) = *zText.offset(i as isize);
                    iOut += 1;
                    iOut;
                }
                i += 1;
                i;
            }
            if !zNL.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zNL as *const libc::c_void,
                    nNL as libc::c_ulong,
                );
                iOut += nNL;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(10))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int;
            }
            if !zCR.is_null() {
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b",'\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
                iOut += 2 as libc::c_int;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    zCR as *const libc::c_void,
                    nCR as libc::c_ulong,
                );
                iOut += nCR;
                memcpy(
                    &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                        as *mut libc::c_void,
                    b"', char(13))\0" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    12 as libc::c_int as libc::c_ulong,
                );
                iOut += 12 as libc::c_int;
            }
            sqlite3_result_text(
                context,
                zOut,
                iOut,
                ::core::mem::transmute::<
                    libc::intptr_t,
                    sqlite3_destructor_type,
                >(-(1 as libc::c_int) as libc::intptr_t),
            );
            sqlite3_free(zOut as *mut libc::c_void);
            return;
        }
    }
    sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn recoverCacheSchema(p: *mut sqlite3_recover) -> libc::c_int {
    return recoverExec(
        p,
        (*p).dbOut,
        b"WITH RECURSIVE pages(p) AS (  SELECT 1    UNION  SELECT child FROM sqlite_dbptr('getpage()'), pages WHERE pgno=p)INSERT INTO recovery.schema SELECT  max(CASE WHEN field=0 THEN value ELSE NULL END),  max(CASE WHEN field=1 THEN value ELSE NULL END),  max(CASE WHEN field=2 THEN value ELSE NULL END),  max(CASE WHEN field=3 THEN value ELSE NULL END),  max(CASE WHEN field=4 THEN value ELSE NULL END)FROM sqlite_dbdata('getpage()') WHERE pgno IN (  SELECT p FROM pages) GROUP BY pgno, cell\0"
            as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn recoverSqlCallback(
    p: *mut sqlite3_recover,
    zSql: *const libc::c_char,
) {
    if (*p).errCode == 0 as libc::c_int && ((*p).xSql).is_some() {
        let res: libc::c_int = ((*p).xSql)
            .expect("non-null function pointer")((*p).pSqlCtx, zSql);
        if res != 0 {
            recoverError(
                p,
                1 as libc::c_int,
                b"callback returned an error - %d\0" as *const u8 as *const libc::c_char,
                res,
            );
        }
    }
}
unsafe extern "C" fn recoverTransferSettings(p: *mut sqlite3_recover) {
    let aPragma: [*const libc::c_char; 5] = [
        b"encoding\0" as *const u8 as *const libc::c_char,
        b"page_size\0" as *const u8 as *const libc::c_char,
        b"auto_vacuum\0" as *const u8 as *const libc::c_char,
        b"user_version\0" as *const u8 as *const libc::c_char,
        b"application_id\0" as *const u8 as *const libc::c_char,
    ];
    let mut ii: libc::c_int = 0;
    if (*p).errCode == 0 as libc::c_int {
        let mut db2: *mut sqlite3 = 0 as *mut sqlite3;
        let rc: libc::c_int = sqlite3_open(
            b"\0" as *const u8 as *const libc::c_char,
            &mut db2,
        );
        if rc != 0 as libc::c_int {
            recoverDbError(p, db2);
            return;
        }
        ii = 0 as libc::c_int;
        while ii
            < (::core::mem::size_of::<[*const libc::c_char; 5]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            let zPrag: *const libc::c_char = aPragma[ii as usize];
            let mut p1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            p1 = recoverPreparePrintf(
                p,
                (*p).dbIn,
                b"PRAGMA %Q.%s\0" as *const u8 as *const libc::c_char,
                (*p).zDb,
                zPrag,
            );
            if (*p).errCode == 0 as libc::c_int && sqlite3_step(p1) == 100 as libc::c_int
            {
                let zArg: *const libc::c_char = sqlite3_column_text(
                    p1,
                    0 as libc::c_int,
                ) as *const libc::c_char;
                let z2: *mut libc::c_char = recoverMPrintf(
                    p,
                    b"PRAGMA %s = %Q\0" as *const u8 as *const libc::c_char,
                    zPrag,
                    zArg,
                );
                recoverSqlCallback(p, z2);
                recoverExec(p, db2, z2);
                sqlite3_free(z2 as *mut libc::c_void);
                if zArg.is_null() {
                    recoverError(p, 7 as libc::c_int, 0 as *const libc::c_char);
                }
            }
            recoverFinalize(p, p1);
            ii += 1;
            ii;
        }
        recoverExec(
            p,
            db2,
            b"CREATE TABLE t1(a); DROP TABLE t1;\0" as *const u8 as *const libc::c_char,
        );
        if (*p).errCode == 0 as libc::c_int {
            let db: *mut sqlite3 = (*p).dbOut;
            let pBackup: *mut sqlite3_backup = sqlite3_backup_init(
                db,
                b"main\0" as *const u8 as *const libc::c_char,
                db2,
                b"main\0" as *const u8 as *const libc::c_char,
            );
            if !pBackup.is_null() {
                sqlite3_backup_step(pBackup, -(1 as libc::c_int));
                (*p).errCode = sqlite3_backup_finish(pBackup);
            } else {
                recoverDbError(p, db);
            }
        }
        sqlite3_close(db2);
    }
}
unsafe extern "C" fn recoverOpenOutput(p: *mut sqlite3_recover) -> libc::c_int {
    let aFunc: [Func; 4] = [
        {
            let init = Func {
                zName: b"getpage\0" as *const u8 as *const libc::c_char,
                nArg: 1 as libc::c_int,
                xFunc: Some(
                    recoverGetPage
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
        {
            let init = Func {
                zName: b"page_is_used\0" as *const u8 as *const libc::c_char,
                nArg: 1 as libc::c_int,
                xFunc: Some(
                    recoverPageIsUsed
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
        {
            let init = Func {
                zName: b"read_i32\0" as *const u8 as *const libc::c_char,
                nArg: 2 as libc::c_int,
                xFunc: Some(
                    recoverReadI32
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
        {
            let init = Func {
                zName: b"escape_crnl\0" as *const u8 as *const libc::c_char,
                nArg: 1 as libc::c_int,
                xFunc: Some(
                    recoverEscapeCrnl
                        as unsafe extern "C" fn(
                            *mut sqlite3_context,
                            libc::c_int,
                            *mut *mut sqlite3_value,
                        ) -> (),
                ),
            };
            init
        },
    ];
    let flags: libc::c_int = 0x40 as libc::c_int | 0x4 as libc::c_int
        | 0x2 as libc::c_int;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut ii: libc::c_int = 0;
    if ((*p).dbOut).is_null() {} else {
        __assert_fail(
            b"p->dbOut==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            15287 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 41],
                &[libc::c_char; 41],
            >(b"int recoverOpenOutput(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_74771: {
        if ((*p).dbOut).is_null() {} else {
            __assert_fail(
                b"p->dbOut==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                15287 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 41],
                    &[libc::c_char; 41],
                >(b"int recoverOpenOutput(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    if sqlite3_open_v2((*p).zUri, &mut db, flags, 0 as *const libc::c_char) != 0 {
        recoverDbError(p, db);
    }
    if (*p).errCode == 0 as libc::c_int {
        (*p)
            .errCode = sqlite3_dbdata_init(
            db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
    }
    ii = 0 as libc::c_int;
    while (*p).errCode == 0 as libc::c_int
        && ii
            < (::core::mem::size_of::<[Func; 4]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<Func>() as libc::c_ulong)
                as libc::c_int
    {
        (*p)
            .errCode = sqlite3_create_function(
            db,
            aFunc[ii as usize].zName,
            aFunc[ii as usize].nArg,
            1 as libc::c_int,
            p as *mut libc::c_void,
            aFunc[ii as usize].xFunc,
            None,
            None,
        );
        ii += 1;
        ii;
    }
    (*p).dbOut = db;
    return (*p).errCode;
}
unsafe extern "C" fn recoverOpenRecovery(p: *mut sqlite3_recover) {
    let zSql: *mut libc::c_char = recoverMPrintf(
        p,
        b"ATTACH %Q AS recovery;\0" as *const u8 as *const libc::c_char,
        (*p).zStateDb,
    );
    recoverExec(p, (*p).dbOut, zSql);
    recoverExec(
        p,
        (*p).dbOut,
        b"PRAGMA writable_schema = 1;CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, parent INT);CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);\0"
            as *const u8 as *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
}
unsafe extern "C" fn recoverAddTable(
    p: *mut sqlite3_recover,
    zName: *const libc::c_char,
    iRoot: i64_0,
) {
    let mut pStmt: *mut sqlite3_stmt = recoverPreparePrintf(
        p,
        (*p).dbOut,
        b"PRAGMA table_xinfo(%Q)\0" as *const u8 as *const libc::c_char,
        zName,
    );
    if !pStmt.is_null() {
        let mut iPk: libc::c_int = -(1 as libc::c_int);
        let mut iBind: libc::c_int = 1 as libc::c_int;
        let mut pNew: *mut RecoverTable = 0 as *mut RecoverTable;
        let mut nCol: libc::c_int = 0 as libc::c_int;
        let nName: libc::c_int = recoverStrlen(zName);
        let mut nByte: libc::c_int = 0 as libc::c_int;
        while sqlite3_step(pStmt) == 100 as libc::c_int {
            nCol += 1;
            nCol;
            nByte += sqlite3_column_bytes(pStmt, 1 as libc::c_int) + 1 as libc::c_int;
        }
        nByte = (nByte as libc::c_ulong)
            .wrapping_add(
                (::core::mem::size_of::<RecoverTable>() as libc::c_ulong)
                    .wrapping_add(
                        (nCol as libc::c_ulong)
                            .wrapping_mul(
                                ::core::mem::size_of::<RecoverColumn>() as libc::c_ulong,
                            ),
                    )
                    .wrapping_add(nName as libc::c_ulong)
                    .wrapping_add(1 as libc::c_int as libc::c_ulong),
            ) as libc::c_int as libc::c_int;
        recoverReset(p, pStmt);
        pNew = recoverMalloc(p, nByte as i64_0) as *mut RecoverTable;
        if !pNew.is_null() {
            let mut i: libc::c_int = 0 as libc::c_int;
            let mut iField: libc::c_int = 0 as libc::c_int;
            let mut csr: *mut libc::c_char = 0 as *mut libc::c_char;
            (*pNew)
                .aCol = &mut *pNew.offset(1 as libc::c_int as isize) as *mut RecoverTable
                as *mut RecoverColumn;
            csr = &mut *((*pNew).aCol).offset(nCol as isize) as *mut RecoverColumn
                as *mut libc::c_char;
            (*pNew).zTab = csr;
            (*pNew).nCol = nCol;
            (*pNew).iRoot = iRoot as u32_0;
            memcpy(
                csr as *mut libc::c_void,
                zName as *const libc::c_void,
                nName as libc::c_ulong,
            );
            csr = csr.offset((nName + 1 as libc::c_int) as isize);
            i = 0 as libc::c_int;
            while sqlite3_step(pStmt) == 100 as libc::c_int {
                let iPKF: libc::c_int = sqlite3_column_int(pStmt, 5 as libc::c_int);
                let n: libc::c_int = sqlite3_column_bytes(pStmt, 1 as libc::c_int);
                let z: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                let zType: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    2 as libc::c_int,
                ) as *const libc::c_char;
                let eHidden: libc::c_int = sqlite3_column_int(
                    pStmt,
                    6 as libc::c_int,
                );
                if iPk == -(1 as libc::c_int) && iPKF == 1 as libc::c_int
                    && sqlite3_stricmp(
                        b"integer\0" as *const u8 as *const libc::c_char,
                        zType,
                    ) == 0
                {
                    iPk = i;
                }
                if iPKF > 1 as libc::c_int {
                    iPk = -(2 as libc::c_int);
                }
                let ref mut fresh56 = (*((*pNew).aCol).offset(i as isize)).zCol;
                *fresh56 = csr;
                (*((*pNew).aCol).offset(i as isize)).eHidden = eHidden;
                if eHidden == 2 as libc::c_int {
                    (*((*pNew).aCol).offset(i as isize)).iField = -(1 as libc::c_int);
                } else {
                    let fresh57 = iField;
                    iField = iField + 1;
                    (*((*pNew).aCol).offset(i as isize)).iField = fresh57;
                }
                if eHidden != 2 as libc::c_int && eHidden != 3 as libc::c_int {
                    let fresh58 = iBind;
                    iBind = iBind + 1;
                    (*((*pNew).aCol).offset(i as isize)).iBind = fresh58;
                }
                memcpy(
                    csr as *mut libc::c_void,
                    z as *const libc::c_void,
                    n as libc::c_ulong,
                );
                csr = csr.offset((n + 1 as libc::c_int) as isize);
                i += 1;
                i;
            }
            (*pNew).pNext = (*p).pTblList;
            (*p).pTblList = pNew;
            (*pNew).bIntkey = 1 as libc::c_int;
        }
        recoverFinalize(p, pStmt);
        pStmt = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"PRAGMA index_xinfo(%Q)\0" as *const u8 as *const libc::c_char,
            zName,
        );
        while !pStmt.is_null() && sqlite3_step(pStmt) == 100 as libc::c_int {
            let iField_0: libc::c_int = sqlite3_column_int(pStmt, 0 as libc::c_int);
            let iCol: libc::c_int = sqlite3_column_int(pStmt, 1 as libc::c_int);
            if iCol < (*pNew).nCol {} else {
                __assert_fail(
                    b"iCol<pNew->nCol\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    15416 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 59],
                        &[libc::c_char; 59],
                    >(b"void recoverAddTable(sqlite3_recover *, const char *, i64)\0"))
                        .as_ptr(),
                );
            }
            'c_68567: {
                if iCol < (*pNew).nCol {} else {
                    __assert_fail(
                        b"iCol<pNew->nCol\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        15416 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 59],
                            &[libc::c_char; 59],
                        >(
                            b"void recoverAddTable(sqlite3_recover *, const char *, i64)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            (*((*pNew).aCol).offset(iCol as isize)).iField = iField_0;
            (*pNew).bIntkey = 0 as libc::c_int;
            iPk = -(2 as libc::c_int);
        }
        recoverFinalize(p, pStmt);
        if (*p).errCode == 0 as libc::c_int {
            if iPk >= 0 as libc::c_int {
                (*((*pNew).aCol).offset(iPk as isize)).bIPK = 1 as libc::c_int;
            } else if (*pNew).bIntkey != 0 {
                let fresh59 = iBind;
                iBind = iBind + 1;
                (*pNew).iRowidBind = fresh59;
            }
        }
    }
}
unsafe extern "C" fn recoverWriteSchema1(p: *mut sqlite3_recover) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pTblname: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    pSelect = recoverPrepare(
        p,
        (*p).dbOut,
        b"WITH dbschema(rootpage, name, sql, tbl, isVirtual, isIndex) AS (  SELECT rootpage, name, sql,     type='table',     sql LIKE 'create virtual%',    (type='index' AND (sql LIKE '%unique%' OR ?1))  FROM recovery.schema)SELECT rootpage, tbl, isVirtual, name, sql FROM dbschema   WHERE tbl OR isIndex  ORDER BY tbl DESC, name=='sqlite_sequence' DESC\0"
            as *const u8 as *const libc::c_char,
    );
    pTblname = recoverPrepare(
        p,
        (*p).dbOut,
        b"SELECT name FROM sqlite_schema WHERE type='table' ORDER BY rowid DESC LIMIT 1\0"
            as *const u8 as *const libc::c_char,
    );
    if !pSelect.is_null() {
        sqlite3_bind_int(pSelect, 1 as libc::c_int, (*p).bSlowIndexes);
        while sqlite3_step(pSelect) == 100 as libc::c_int {
            let iRoot: i64_0 = sqlite3_column_int64(pSelect, 0 as libc::c_int);
            let bTable: libc::c_int = sqlite3_column_int(pSelect, 1 as libc::c_int);
            let bVirtual: libc::c_int = sqlite3_column_int(
                pSelect,
                2 as libc::c_int,
            );
            let zName: *const libc::c_char = sqlite3_column_text(
                pSelect,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let mut zSql: *const libc::c_char = sqlite3_column_text(
                pSelect,
                4 as libc::c_int,
            ) as *const libc::c_char;
            let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut rc: libc::c_int = 0 as libc::c_int;
            if bVirtual != 0 {
                zFree = recoverMPrintf(
                    p,
                    b"INSERT INTO sqlite_schema VALUES('table', %Q, %Q, 0, %Q)\0"
                        as *const u8 as *const libc::c_char,
                    zName,
                    zName,
                    zSql,
                );
                zSql = zFree as *const libc::c_char;
            }
            rc = sqlite3_exec(
                (*p).dbOut,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                recoverSqlCallback(p, zSql);
                if bTable != 0 && bVirtual == 0 {
                    if 100 as libc::c_int == sqlite3_step(pTblname) {
                        let zTbl: *const libc::c_char = sqlite3_column_text(
                            pTblname,
                            0 as libc::c_int,
                        ) as *const libc::c_char;
                        recoverAddTable(p, zTbl, iRoot);
                    }
                    recoverReset(p, pTblname);
                }
            } else if rc != 1 as libc::c_int {
                recoverDbError(p, (*p).dbOut);
            }
            sqlite3_free(zFree as *mut libc::c_void);
        }
    }
    recoverFinalize(p, pSelect);
    recoverFinalize(p, pTblname);
    return (*p).errCode;
}
unsafe extern "C" fn recoverWriteSchema2(p: *mut sqlite3_recover) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    pSelect = recoverPrepare(
        p,
        (*p).dbOut,
        if (*p).bSlowIndexes != 0 {
            b"SELECT rootpage, sql FROM recovery.schema   WHERE type!='table' AND type!='index'\0"
                as *const u8 as *const libc::c_char
        } else {
            b"SELECT rootpage, sql FROM recovery.schema   WHERE type!='table' AND (type!='index' OR sql NOT LIKE '%unique%')\0"
                as *const u8 as *const libc::c_char
        },
    );
    if !pSelect.is_null() {
        while sqlite3_step(pSelect) == 100 as libc::c_int {
            let zSql: *const libc::c_char = sqlite3_column_text(
                pSelect,
                1 as libc::c_int,
            ) as *const libc::c_char;
            let rc: libc::c_int = sqlite3_exec(
                (*p).dbOut,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                recoverSqlCallback(p, zSql);
            } else if rc != 1 as libc::c_int {
                recoverDbError(p, (*p).dbOut);
            }
        }
    }
    recoverFinalize(p, pSelect);
    return (*p).errCode;
}
unsafe extern "C" fn recoverInsertStmt(
    p: *mut sqlite3_recover,
    pTab: *mut RecoverTable,
    nField: libc::c_int,
) -> *mut sqlite3_stmt {
    let mut pRet: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSep: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zSqlSep: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zFinal: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zBind: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ii: libc::c_int = 0;
    let bSql: libc::c_int = if ((*p).xSql).is_some() {
        1 as libc::c_int
    } else {
        0 as libc::c_int
    };
    if nField <= 0 as libc::c_int {
        return 0 as *mut sqlite3_stmt;
    }
    if nField <= (*pTab).nCol {} else {
        __assert_fail(
            b"nField<=pTab->nCol\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            15607 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 72],
                &[libc::c_char; 72],
            >(
                b"sqlite3_stmt *recoverInsertStmt(sqlite3_recover *, RecoverTable *, int)\0",
            ))
                .as_ptr(),
        );
    }
    'c_67628: {
        if nField <= (*pTab).nCol {} else {
            __assert_fail(
                b"nField<=pTab->nCol\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                15607 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 72],
                    &[libc::c_char; 72],
                >(
                    b"sqlite3_stmt *recoverInsertStmt(sqlite3_recover *, RecoverTable *, int)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    zSql = recoverMPrintf(
        p,
        b"INSERT OR IGNORE INTO %Q(\0" as *const u8 as *const libc::c_char,
        (*pTab).zTab,
    );
    if (*pTab).iRowidBind != 0 {
        if (*pTab).bIntkey != 0 {} else {
            __assert_fail(
                b"pTab->bIntkey\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                15612 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 72],
                    &[libc::c_char; 72],
                >(
                    b"sqlite3_stmt *recoverInsertStmt(sqlite3_recover *, RecoverTable *, int)\0",
                ))
                    .as_ptr(),
            );
        }
        'c_67576: {
            if (*pTab).bIntkey != 0 {} else {
                __assert_fail(
                    b"pTab->bIntkey\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    15612 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 72],
                        &[libc::c_char; 72],
                    >(
                        b"sqlite3_stmt *recoverInsertStmt(sqlite3_recover *, RecoverTable *, int)\0",
                    ))
                        .as_ptr(),
                );
            }
        };
        zSql = recoverMPrintf(
            p,
            b"%z_rowid_\0" as *const u8 as *const libc::c_char,
            zSql,
        );
        if bSql != 0 {
            zBind = recoverMPrintf(
                p,
                b"%zquote(?%d)\0" as *const u8 as *const libc::c_char,
                zBind,
                (*pTab).iRowidBind,
            );
        } else {
            zBind = recoverMPrintf(
                p,
                b"%z?%d\0" as *const u8 as *const libc::c_char,
                zBind,
                (*pTab).iRowidBind,
            );
        }
        zSqlSep = b"||', '||\0" as *const u8 as *const libc::c_char;
        zSep = b", \0" as *const u8 as *const libc::c_char;
    }
    ii = 0 as libc::c_int;
    while ii < nField {
        let eHidden: libc::c_int = (*((*pTab).aCol).offset(ii as isize)).eHidden;
        if eHidden != 2 as libc::c_int && eHidden != 3 as libc::c_int {
            if (*((*pTab).aCol).offset(ii as isize)).iField >= 0 as libc::c_int
                && (*((*pTab).aCol).offset(ii as isize)).iBind >= 1 as libc::c_int
            {} else {
                __assert_fail(
                    b"pTab->aCol[ii].iField>=0 && pTab->aCol[ii].iBind>=1\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    15628 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 72],
                        &[libc::c_char; 72],
                    >(
                        b"sqlite3_stmt *recoverInsertStmt(sqlite3_recover *, RecoverTable *, int)\0",
                    ))
                        .as_ptr(),
                );
            }
            'c_67411: {
                if (*((*pTab).aCol).offset(ii as isize)).iField >= 0 as libc::c_int
                    && (*((*pTab).aCol).offset(ii as isize)).iBind >= 1 as libc::c_int
                {} else {
                    __assert_fail(
                        b"pTab->aCol[ii].iField>=0 && pTab->aCol[ii].iBind>=1\0"
                            as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        15628 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 72],
                            &[libc::c_char; 72],
                        >(
                            b"sqlite3_stmt *recoverInsertStmt(sqlite3_recover *, RecoverTable *, int)\0",
                        ))
                            .as_ptr(),
                    );
                }
            };
            zSql = recoverMPrintf(
                p,
                b"%z%s%Q\0" as *const u8 as *const libc::c_char,
                zSql,
                zSep,
                (*((*pTab).aCol).offset(ii as isize)).zCol,
            );
            if bSql != 0 {
                zBind = recoverMPrintf(
                    p,
                    b"%z%sescape_crnl(quote(?%d))\0" as *const u8 as *const libc::c_char,
                    zBind,
                    zSqlSep,
                    (*((*pTab).aCol).offset(ii as isize)).iBind,
                );
                zSqlSep = b"||', '||\0" as *const u8 as *const libc::c_char;
            } else {
                zBind = recoverMPrintf(
                    p,
                    b"%z%s?%d\0" as *const u8 as *const libc::c_char,
                    zBind,
                    zSep,
                    (*((*pTab).aCol).offset(ii as isize)).iBind,
                );
            }
            zSep = b", \0" as *const u8 as *const libc::c_char;
        }
        ii += 1;
        ii;
    }
    if bSql != 0 {
        zFinal = recoverMPrintf(
            p,
            b"SELECT %Q || ') VALUES (' || %s || ')'\0" as *const u8
                as *const libc::c_char,
            zSql,
            zBind,
        );
    } else {
        zFinal = recoverMPrintf(
            p,
            b"%s) VALUES (%s)\0" as *const u8 as *const libc::c_char,
            zSql,
            zBind,
        );
    }
    pRet = recoverPrepare(p, (*p).dbOut, zFinal);
    sqlite3_free(zSql as *mut libc::c_void);
    sqlite3_free(zBind as *mut libc::c_void);
    sqlite3_free(zFinal as *mut libc::c_void);
    return pRet;
}
unsafe extern "C" fn recoverFindTable(
    p: *mut sqlite3_recover,
    iRoot: u32_0,
) -> *mut RecoverTable {
    let mut pRet: *mut RecoverTable = 0 as *mut RecoverTable;
    pRet = (*p).pTblList;
    while !pRet.is_null() && (*pRet).iRoot != iRoot {
        pRet = (*pRet).pNext;
    }
    return pRet;
}
unsafe extern "C" fn recoverLostAndFoundCreate(
    p: *mut sqlite3_recover,
    nField: libc::c_int,
) -> *mut libc::c_char {
    let mut zTbl: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pProbe: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut ii: libc::c_int = 0 as libc::c_int;
    pProbe = recoverPrepare(
        p,
        (*p).dbOut,
        b"SELECT 1 FROM sqlite_schema WHERE name=?\0" as *const u8 as *const libc::c_char,
    );
    ii = -(1 as libc::c_int);
    while zTbl.is_null() && (*p).errCode == 0 as libc::c_int && ii < 1000 as libc::c_int
    {
        let mut bFail: libc::c_int = 0 as libc::c_int;
        if ii < 0 as libc::c_int {
            zTbl = recoverMPrintf(
                p,
                b"%s\0" as *const u8 as *const libc::c_char,
                (*p).zLostAndFound,
            );
        } else {
            zTbl = recoverMPrintf(
                p,
                b"%s_%d\0" as *const u8 as *const libc::c_char,
                (*p).zLostAndFound,
                ii,
            );
        }
        if (*p).errCode == 0 as libc::c_int {
            sqlite3_bind_text(pProbe, 1 as libc::c_int, zTbl, -(1 as libc::c_int), None);
            if 100 as libc::c_int == sqlite3_step(pProbe) {
                bFail = 1 as libc::c_int;
            }
            recoverReset(p, pProbe);
        }
        if bFail != 0 {
            sqlite3_clear_bindings(pProbe);
            sqlite3_free(zTbl as *mut libc::c_void);
            zTbl = 0 as *mut libc::c_char;
        }
        ii += 1;
        ii;
    }
    recoverFinalize(p, pProbe);
    if !zTbl.is_null() {
        let mut zSep: *const libc::c_char = 0 as *const libc::c_char;
        let mut zField: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        zSep = b"rootpgno INTEGER, pgno INTEGER, nfield INTEGER, id INTEGER, \0"
            as *const u8 as *const libc::c_char;
        ii = 0 as libc::c_int;
        while (*p).errCode == 0 as libc::c_int && ii < nField {
            zField = recoverMPrintf(
                p,
                b"%z%sc%d\0" as *const u8 as *const libc::c_char,
                zField,
                zSep,
                ii,
            );
            zSep = b", \0" as *const u8 as *const libc::c_char;
            ii += 1;
            ii;
        }
        zSql = recoverMPrintf(
            p,
            b"CREATE TABLE %s(%s)\0" as *const u8 as *const libc::c_char,
            zTbl,
            zField,
        );
        sqlite3_free(zField as *mut libc::c_void);
        recoverExec(p, (*p).dbOut, zSql);
        recoverSqlCallback(p, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
    } else if (*p).errCode == 0 as libc::c_int {
        recoverError(
            p,
            1 as libc::c_int,
            b"failed to create %s output table\0" as *const u8 as *const libc::c_char,
            (*p).zLostAndFound,
        );
    }
    return zTbl;
}
unsafe extern "C" fn recoverLostAndFoundInsert(
    p: *mut sqlite3_recover,
    zTab: *const libc::c_char,
    nField: libc::c_int,
) -> *mut sqlite3_stmt {
    let nTotal: libc::c_int = nField + 4 as libc::c_int;
    let mut ii: libc::c_int = 0;
    let mut zBind: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pRet: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if ((*p).xSql).is_none() {
        ii = 0 as libc::c_int;
        while ii < nTotal {
            zBind = recoverMPrintf(
                p,
                b"%z%s?\0" as *const u8 as *const libc::c_char,
                zBind,
                if !zBind.is_null() {
                    b", \0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
                ii,
            );
            ii += 1;
            ii;
        }
        pRet = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"INSERT INTO %s VALUES(%s)\0" as *const u8 as *const libc::c_char,
            zTab,
            zBind,
        );
    } else {
        let mut zSep: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
        ii = 0 as libc::c_int;
        while ii < nTotal {
            zBind = recoverMPrintf(
                p,
                b"%z%squote(?)\0" as *const u8 as *const libc::c_char,
                zBind,
                zSep,
            );
            zSep = b"|| ', ' ||\0" as *const u8 as *const libc::c_char;
            ii += 1;
            ii;
        }
        pRet = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"SELECT 'INSERT INTO %s VALUES(' || %s || ')'\0" as *const u8
                as *const libc::c_char,
            zTab,
            zBind,
        );
    }
    sqlite3_free(zBind as *mut libc::c_void);
    return pRet;
}
unsafe extern "C" fn recoverLostAndFoundFindRoot(
    p: *mut sqlite3_recover,
    iPg: i64_0,
    piRoot: *mut i64_0,
) -> libc::c_int {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if ((*pLaf).pFindRoot).is_null() {
        (*pLaf)
            .pFindRoot = recoverPrepare(
            p,
            (*p).dbOut,
            b"WITH RECURSIVE p(pgno) AS (  SELECT ?    UNION  SELECT parent FROM recovery.map AS m, p WHERE m.pgno=p.pgno) SELECT p.pgno FROM p, recovery.map m WHERE m.pgno=p.pgno     AND m.parent IS NULL\0"
                as *const u8 as *const libc::c_char,
        );
    }
    if (*p).errCode == 0 as libc::c_int {
        sqlite3_bind_int64((*pLaf).pFindRoot, 1 as libc::c_int, iPg);
        if sqlite3_step((*pLaf).pFindRoot) == 100 as libc::c_int {
            *piRoot = sqlite3_column_int64((*pLaf).pFindRoot, 0 as libc::c_int);
        } else {
            *piRoot = iPg;
        }
        recoverReset(p, (*pLaf).pFindRoot);
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverLostAndFoundOnePage(
    p: *mut sqlite3_recover,
    iPage: i64_0,
) {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let apVal: *mut *mut sqlite3_value = (*pLaf).apVal;
    let pPageData: *mut sqlite3_stmt = (*pLaf).pPageData;
    let pInsert: *mut sqlite3_stmt = (*pLaf).pInsert;
    let mut nVal: libc::c_int = -(1 as libc::c_int);
    let mut iPrevCell: libc::c_int = 0 as libc::c_int;
    let mut iRoot: i64_0 = 0 as libc::c_int as i64_0;
    let mut bHaveRowid: libc::c_int = 0 as libc::c_int;
    let mut iRowid: i64_0 = 0 as libc::c_int as i64_0;
    let mut ii: libc::c_int = 0 as libc::c_int;
    if recoverLostAndFoundFindRoot(p, iPage, &mut iRoot) != 0 {
        return;
    }
    sqlite3_bind_int64(pPageData, 1 as libc::c_int, iPage);
    while (*p).errCode == 0 as libc::c_int
        && 100 as libc::c_int == sqlite3_step(pPageData)
    {
        let iCell: libc::c_int = sqlite3_column_int64(pPageData, 0 as libc::c_int)
            as libc::c_int;
        let iField: libc::c_int = sqlite3_column_int64(pPageData, 1 as libc::c_int)
            as libc::c_int;
        if iPrevCell != iCell && nVal >= 0 as libc::c_int {
            sqlite3_bind_int64(pInsert, 1 as libc::c_int, iRoot);
            sqlite3_bind_int64(pInsert, 2 as libc::c_int, iPage);
            sqlite3_bind_int(pInsert, 3 as libc::c_int, nVal);
            if bHaveRowid != 0 {
                sqlite3_bind_int64(pInsert, 4 as libc::c_int, iRowid);
            }
            ii = 0 as libc::c_int;
            while ii < nVal {
                recoverBindValue(
                    p,
                    pInsert,
                    5 as libc::c_int + ii,
                    *apVal.offset(ii as isize),
                );
                ii += 1;
                ii;
            }
            if sqlite3_step(pInsert) == 100 as libc::c_int {
                recoverSqlCallback(
                    p,
                    sqlite3_column_text(pInsert, 0 as libc::c_int) as *const libc::c_char,
                );
            }
            recoverReset(p, pInsert);
            ii = 0 as libc::c_int;
            while ii < nVal {
                sqlite3_value_free(*apVal.offset(ii as isize));
                let ref mut fresh60 = *apVal.offset(ii as isize);
                *fresh60 = 0 as *mut sqlite3_value;
                ii += 1;
                ii;
            }
            sqlite3_clear_bindings(pInsert);
            bHaveRowid = 0 as libc::c_int;
            nVal = -(1 as libc::c_int);
        }
        if iCell < 0 as libc::c_int {
            break;
        }
        if iField < 0 as libc::c_int {
            if nVal == -(1 as libc::c_int) {} else {
                __assert_fail(
                    b"nVal==-1\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    15869 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 56],
                        &[libc::c_char; 56],
                    >(b"void recoverLostAndFoundOnePage(sqlite3_recover *, i64)\0"))
                        .as_ptr(),
                );
            }
            'c_64449: {
                if nVal == -(1 as libc::c_int) {} else {
                    __assert_fail(
                        b"nVal==-1\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        15869 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 56],
                            &[libc::c_char; 56],
                        >(b"void recoverLostAndFoundOnePage(sqlite3_recover *, i64)\0"))
                            .as_ptr(),
                    );
                }
            };
            iRowid = sqlite3_column_int64(pPageData, 2 as libc::c_int);
            bHaveRowid = 1 as libc::c_int;
            nVal = 0 as libc::c_int;
        } else if iField < (*pLaf).nMaxField {
            let pVal: *mut sqlite3_value = sqlite3_column_value(
                pPageData,
                2 as libc::c_int,
            );
            let ref mut fresh61 = *apVal.offset(iField as isize);
            *fresh61 = sqlite3_value_dup(pVal);
            if iField == nVal
                || nVal == -(1 as libc::c_int) && iField == 0 as libc::c_int
            {} else {
                __assert_fail(
                    b"iField==nVal || (nVal==-1 && iField==0)\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    15876 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 56],
                        &[libc::c_char; 56],
                    >(b"void recoverLostAndFoundOnePage(sqlite3_recover *, i64)\0"))
                        .as_ptr(),
                );
            }
            'c_64338: {
                if iField == nVal
                    || nVal == -(1 as libc::c_int) && iField == 0 as libc::c_int
                {} else {
                    __assert_fail(
                        b"iField==nVal || (nVal==-1 && iField==0)\0" as *const u8
                            as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        15876 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 56],
                            &[libc::c_char; 56],
                        >(b"void recoverLostAndFoundOnePage(sqlite3_recover *, i64)\0"))
                            .as_ptr(),
                    );
                }
            };
            nVal = iField + 1 as libc::c_int;
            if (*apVal.offset(iField as isize)).is_null() {
                recoverError(p, 7 as libc::c_int, 0 as *const libc::c_char);
            }
        }
        iPrevCell = iCell;
    }
    recoverReset(p, pPageData);
    ii = 0 as libc::c_int;
    while ii < nVal {
        sqlite3_value_free(*apVal.offset(ii as isize));
        let ref mut fresh62 = *apVal.offset(ii as isize);
        *fresh62 = 0 as *mut sqlite3_value;
        ii += 1;
        ii;
    }
}
unsafe extern "C" fn recoverLostAndFound3Step(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if (*p).errCode == 0 as libc::c_int {
        if ((*pLaf).pInsert).is_null() {
            return 101 as libc::c_int
        } else if (*p).errCode == 0 as libc::c_int {
            let res: libc::c_int = sqlite3_step((*pLaf).pAllPage);
            if res == 100 as libc::c_int {
                let iPage: i64_0 = sqlite3_column_int64(
                    (*pLaf).pAllPage,
                    0 as libc::c_int,
                );
                if recoverBitmapQuery((*pLaf).pUsed, iPage) == 0 as libc::c_int {
                    recoverLostAndFoundOnePage(p, iPage);
                }
            } else {
                recoverReset(p, (*pLaf).pAllPage);
                return 101 as libc::c_int;
            }
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverLostAndFound3Init(p: *mut sqlite3_recover) {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if (*pLaf).nMaxField > 0 as libc::c_int {
        let mut zTab: *mut libc::c_char = 0 as *mut libc::c_char;
        zTab = recoverLostAndFoundCreate(p, (*pLaf).nMaxField);
        (*pLaf).pInsert = recoverLostAndFoundInsert(p, zTab, (*pLaf).nMaxField);
        sqlite3_free(zTab as *mut libc::c_void);
        (*pLaf)
            .pAllPage = recoverPreparePrintf(
            p,
            (*p).dbOut,
            b"WITH RECURSIVE seq(ii) AS (  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii<%lld)SELECT ii FROM seq\0"
                as *const u8 as *const libc::c_char,
            (*p).laf.nPg,
        );
        (*pLaf)
            .pPageData = recoverPrepare(
            p,
            (*p).dbOut,
            b"SELECT cell, field, value FROM sqlite_dbdata('getpage()') d WHERE d.pgno=? UNION ALL SELECT -1, -1, -1\0"
                as *const u8 as *const libc::c_char,
        );
        (*pLaf)
            .apVal = recoverMalloc(
            p,
            ((*pLaf).nMaxField as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut sqlite3_value>() as libc::c_ulong,
                ) as i64_0,
        ) as *mut *mut sqlite3_value;
    }
}
unsafe extern "C" fn recoverWriteDataInit(p: *mut sqlite3_recover) -> libc::c_int {
    let p1: *mut RecoverStateW1 = &mut (*p).w1;
    let mut pTbl: *mut RecoverTable = 0 as *mut RecoverTable;
    let mut nByte: libc::c_int = 0 as libc::c_int;
    if (*p1).nMax == 0 as libc::c_int {} else {
        __assert_fail(
            b"p1->nMax==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            15969 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 44],
                &[libc::c_char; 44],
            >(b"int recoverWriteDataInit(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_68251: {
        if (*p1).nMax == 0 as libc::c_int {} else {
            __assert_fail(
                b"p1->nMax==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                15969 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 44],
                    &[libc::c_char; 44],
                >(b"int recoverWriteDataInit(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    pTbl = (*p).pTblList;
    while !pTbl.is_null() {
        if (*pTbl).nCol > (*p1).nMax {
            (*p1).nMax = (*pTbl).nCol;
        }
        pTbl = (*pTbl).pNext;
    }
    nByte = (::core::mem::size_of::<*mut sqlite3_value>() as libc::c_ulong)
        .wrapping_mul(((*p1).nMax + 1 as libc::c_int) as libc::c_ulong) as libc::c_int;
    (*p1).apVal = recoverMalloc(p, nByte as i64_0) as *mut *mut sqlite3_value;
    if ((*p1).apVal).is_null() {
        return (*p).errCode;
    }
    (*p1)
        .pTbls = recoverPrepare(
        p,
        (*p).dbOut,
        b"SELECT rootpage FROM recovery.schema   WHERE type='table' AND (sql NOT LIKE 'create virtual%')  ORDER BY (tbl_name='sqlite_sequence') ASC\0"
            as *const u8 as *const libc::c_char,
    );
    (*p1)
        .pSel = recoverPrepare(
        p,
        (*p).dbOut,
        b"WITH RECURSIVE pages(page) AS (  SELECT ?1    UNION  SELECT child FROM sqlite_dbptr('getpage()'), pages     WHERE pgno=page) SELECT page, cell, field, value FROM sqlite_dbdata('getpage()') d, pages p WHERE p.page=d.pgno UNION ALL SELECT 0, 0, 0, 0\0"
            as *const u8 as *const libc::c_char,
    );
    return (*p).errCode;
}
unsafe extern "C" fn recoverWriteDataCleanup(p: *mut sqlite3_recover) {
    let p1: *mut RecoverStateW1 = &mut (*p).w1;
    let mut ii: libc::c_int = 0;
    ii = 0 as libc::c_int;
    while ii < (*p1).nVal {
        sqlite3_value_free(*((*p1).apVal).offset(ii as isize));
        ii += 1;
        ii;
    }
    sqlite3_free((*p1).apVal as *mut libc::c_void);
    recoverFinalize(p, (*p1).pInsert);
    recoverFinalize(p, (*p1).pTbls);
    recoverFinalize(p, (*p1).pSel);
    memset(
        p1 as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<RecoverStateW1>() as libc::c_ulong,
    );
}
unsafe extern "C" fn recoverWriteDataStep(p: *mut sqlite3_recover) -> libc::c_int {
    let p1: *mut RecoverStateW1 = &mut (*p).w1;
    let pSel: *mut sqlite3_stmt = (*p1).pSel;
    let apVal: *mut *mut sqlite3_value = (*p1).apVal;
    if (*p).errCode == 0 as libc::c_int && ((*p1).pTab).is_null() {
        if sqlite3_step((*p1).pTbls) == 100 as libc::c_int {
            let iRoot: i64_0 = sqlite3_column_int64((*p1).pTbls, 0 as libc::c_int);
            (*p1).pTab = recoverFindTable(p, iRoot as u32_0);
            recoverFinalize(p, (*p1).pInsert);
            (*p1).pInsert = 0 as *mut sqlite3_stmt;
            if ((*p1).pTab).is_null() {
                return (*p).errCode;
            }
            if sqlite3_stricmp(
                b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
                (*(*p1).pTab).zTab,
            ) == 0 as libc::c_int
            {
                recoverExec(
                    p,
                    (*p).dbOut,
                    b"DELETE FROM sqlite_sequence\0" as *const u8 as *const libc::c_char,
                );
                recoverSqlCallback(
                    p,
                    b"DELETE FROM sqlite_sequence\0" as *const u8 as *const libc::c_char,
                );
            }
            sqlite3_bind_int64(pSel, 1 as libc::c_int, iRoot);
            (*p1).nVal = 0 as libc::c_int;
            (*p1).bHaveRowid = 0 as libc::c_int;
            (*p1).iPrevPage = -(1 as libc::c_int) as i64_0;
            (*p1).iPrevCell = -(1 as libc::c_int);
        } else {
            return 101 as libc::c_int
        }
    }
    if (*p).errCode != 0 as libc::c_int || !((*p1).pTab).is_null() {} else {
        __assert_fail(
            b"p->errCode!=SQLITE_OK || p1->pTab\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16066 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 44],
                &[libc::c_char; 44],
            >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_67868: {
        if (*p).errCode != 0 as libc::c_int || !((*p1).pTab).is_null() {} else {
            __assert_fail(
                b"p->errCode!=SQLITE_OK || p1->pTab\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16066 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 44],
                    &[libc::c_char; 44],
                >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    if (*p).errCode == 0 as libc::c_int && sqlite3_step(pSel) == 100 as libc::c_int {
        let pTab: *mut RecoverTable = (*p1).pTab;
        let iPage: i64_0 = sqlite3_column_int64(pSel, 0 as libc::c_int);
        let iCell: libc::c_int = sqlite3_column_int(pSel, 1 as libc::c_int);
        let iField: libc::c_int = sqlite3_column_int(pSel, 2 as libc::c_int);
        let pVal: *mut sqlite3_value = sqlite3_column_value(pSel, 3 as libc::c_int);
        let bNewCell: libc::c_int = ((*p1).iPrevPage != iPage
            || (*p1).iPrevCell != iCell) as libc::c_int;
        if bNewCell == 0 as libc::c_int
            || (iField == -(1 as libc::c_int) || iField == 0 as libc::c_int)
        {} else {
            __assert_fail(
                b"bNewCell==0 || (iField==-1 || iField==0)\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16077 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 44],
                    &[libc::c_char; 44],
                >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
        'c_67795: {
            if bNewCell == 0 as libc::c_int
                || (iField == -(1 as libc::c_int) || iField == 0 as libc::c_int)
            {} else {
                __assert_fail(
                    b"bNewCell==0 || (iField==-1 || iField==0)\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    16077 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 44],
                        &[libc::c_char; 44],
                    >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                        .as_ptr(),
                );
            }
        };
        if bNewCell != 0 || iField == (*p1).nVal || (*p1).nVal == (*pTab).nCol {} else {
            __assert_fail(
                b"bNewCell || iField==p1->nVal || p1->nVal==pTab->nCol\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16078 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 44],
                    &[libc::c_char; 44],
                >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
        'c_67727: {
            if bNewCell != 0 || iField == (*p1).nVal || (*p1).nVal == (*pTab).nCol
            {} else {
                __assert_fail(
                    b"bNewCell || iField==p1->nVal || p1->nVal==pTab->nCol\0"
                        as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    16078 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 44],
                        &[libc::c_char; 44],
                    >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                        .as_ptr(),
                );
            }
        };
        if bNewCell != 0 {
            let mut ii: libc::c_int = 0 as libc::c_int;
            if (*p1).nVal >= 0 as libc::c_int {
                if ((*p1).pInsert).is_null() || (*p1).nVal != (*p1).nInsert {
                    recoverFinalize(p, (*p1).pInsert);
                    (*p1).pInsert = recoverInsertStmt(p, pTab, (*p1).nVal);
                    (*p1).nInsert = (*p1).nVal;
                }
                if (*p1).nVal > 0 as libc::c_int {
                    let pInsert: *mut sqlite3_stmt = (*p1).pInsert;
                    ii = 0 as libc::c_int;
                    while ii < (*pTab).nCol {
                        let pCol: *mut RecoverColumn = &mut *((*pTab).aCol)
                            .offset(ii as isize) as *mut RecoverColumn;
                        let iBind: libc::c_int = (*pCol).iBind;
                        if iBind > 0 as libc::c_int {
                            if (*pCol).bIPK != 0 {
                                sqlite3_bind_int64(pInsert, iBind, (*p1).iRowid);
                            } else if (*pCol).iField < (*p1).nVal {
                                recoverBindValue(
                                    p,
                                    pInsert,
                                    iBind,
                                    *apVal.offset((*pCol).iField as isize),
                                );
                            }
                        }
                        ii += 1;
                        ii;
                    }
                    if (*p).bRecoverRowid != 0 && (*pTab).iRowidBind > 0 as libc::c_int
                        && (*p1).bHaveRowid != 0
                    {
                        sqlite3_bind_int64(pInsert, (*pTab).iRowidBind, (*p1).iRowid);
                    }
                    if 100 as libc::c_int == sqlite3_step(pInsert) {
                        let z: *const libc::c_char = sqlite3_column_text(
                            pInsert,
                            0 as libc::c_int,
                        ) as *const libc::c_char;
                        recoverSqlCallback(p, z);
                    }
                    recoverReset(p, pInsert);
                    if (*p).errCode != 0 || !pInsert.is_null() {} else {
                        __assert_fail(
                            b"p->errCode || pInsert\0" as *const u8
                                as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            16109 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 44],
                                &[libc::c_char; 44],
                            >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                                .as_ptr(),
                        );
                    }
                    'c_66980: {
                        if (*p).errCode != 0 || !pInsert.is_null() {} else {
                            __assert_fail(
                                b"p->errCode || pInsert\0" as *const u8
                                    as *const libc::c_char,
                                b"shell.c\0" as *const u8 as *const libc::c_char,
                                16109 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 44],
                                    &[libc::c_char; 44],
                                >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                                    .as_ptr(),
                            );
                        }
                    };
                    if !pInsert.is_null() {
                        sqlite3_clear_bindings(pInsert);
                    }
                }
            }
            ii = 0 as libc::c_int;
            while ii < (*p1).nVal {
                sqlite3_value_free(*apVal.offset(ii as isize));
                let ref mut fresh63 = *apVal.offset(ii as isize);
                *fresh63 = 0 as *mut sqlite3_value;
                ii += 1;
                ii;
            }
            (*p1).nVal = -(1 as libc::c_int);
            (*p1).bHaveRowid = 0 as libc::c_int;
        }
        if iPage != 0 as libc::c_int as libc::c_longlong {
            if iField < 0 as libc::c_int {
                (*p1).iRowid = sqlite3_column_int64(pSel, 3 as libc::c_int);
                if (*p1).nVal == -(1 as libc::c_int) {} else {
                    __assert_fail(
                        b"p1->nVal==-1\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        16125 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 44],
                            &[libc::c_char; 44],
                        >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                            .as_ptr(),
                    );
                }
                'c_66842: {
                    if (*p1).nVal == -(1 as libc::c_int) {} else {
                        __assert_fail(
                            b"p1->nVal==-1\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            16125 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 44],
                                &[libc::c_char; 44],
                            >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                                .as_ptr(),
                        );
                    }
                };
                (*p1).nVal = 0 as libc::c_int;
                (*p1).bHaveRowid = 1 as libc::c_int;
            } else if iField < (*pTab).nCol {
                if (*apVal.offset(iField as isize)).is_null() {} else {
                    __assert_fail(
                        b"apVal[iField]==0\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        16129 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 44],
                            &[libc::c_char; 44],
                        >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                            .as_ptr(),
                    );
                }
                'c_66771: {
                    if (*apVal.offset(iField as isize)).is_null() {} else {
                        __assert_fail(
                            b"apVal[iField]==0\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            16129 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 44],
                                &[libc::c_char; 44],
                            >(b"int recoverWriteDataStep(sqlite3_recover *)\0"))
                                .as_ptr(),
                        );
                    }
                };
                let ref mut fresh64 = *apVal.offset(iField as isize);
                *fresh64 = sqlite3_value_dup(pVal);
                if (*apVal.offset(iField as isize)).is_null() {
                    recoverError(p, 7 as libc::c_int, 0 as *const libc::c_char);
                }
                (*p1).nVal = iField + 1 as libc::c_int;
            }
            (*p1).iPrevCell = iCell;
            (*p1).iPrevPage = iPage;
        }
    } else {
        recoverReset(p, pSel);
        (*p1).pTab = 0 as *mut RecoverTable;
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverLostAndFound1Init(p: *mut sqlite3_recover) {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if ((*p).laf.pUsed).is_null() {} else {
        __assert_fail(
            b"p->laf.pUsed==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16156 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"void recoverLostAndFound1Init(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_66530: {
        if ((*p).laf.pUsed).is_null() {} else {
            __assert_fail(
                b"p->laf.pUsed==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16156 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 49],
                    &[libc::c_char; 49],
                >(b"void recoverLostAndFound1Init(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    (*pLaf).nPg = recoverPageCount(p);
    (*pLaf).pUsed = recoverBitmapAlloc(p, (*pLaf).nPg);
    pStmt = recoverPrepare(
        p,
        (*p).dbOut,
        b"WITH trunk(pgno) AS (  SELECT read_i32(getpage(1), 8) AS x WHERE x>0    UNION  SELECT read_i32(getpage(trunk.pgno), 0) AS x FROM trunk WHERE x>0),trunkdata(pgno, data) AS (  SELECT pgno, getpage(pgno) FROM trunk),freelist(data, n, freepgno) AS (  SELECT data, min(16384, read_i32(data, 1)-1), pgno FROM trunkdata    UNION ALL  SELECT data, n-1, read_i32(data, 2+n) FROM freelist WHERE n>=0),roots(r) AS (  SELECT 1 UNION ALL  SELECT rootpage FROM recovery.schema WHERE rootpage>0),used(page) AS (  SELECT r FROM roots    UNION  SELECT child FROM sqlite_dbptr('getpage()'), used     WHERE pgno=page) SELECT page FROM used UNION ALL SELECT freepgno FROM freelist WHERE NOT ?\0"
            as *const u8 as *const libc::c_char,
    );
    if !pStmt.is_null() {
        sqlite3_bind_int(pStmt, 1 as libc::c_int, (*p).bFreelistCorrupt);
    }
    (*pLaf).pUsedPages = pStmt;
}
unsafe extern "C" fn recoverLostAndFound1Step(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    let mut rc: libc::c_int = (*p).errCode;
    if rc == 0 as libc::c_int {
        rc = sqlite3_step((*pLaf).pUsedPages);
        if rc == 100 as libc::c_int {
            let iPg: i64_0 = sqlite3_column_int64(
                (*pLaf).pUsedPages,
                0 as libc::c_int,
            );
            recoverBitmapSet((*pLaf).pUsed, iPg);
            rc = 0 as libc::c_int;
        } else {
            recoverFinalize(p, (*pLaf).pUsedPages);
            (*pLaf).pUsedPages = 0 as *mut sqlite3_stmt;
        }
    }
    return rc;
}
unsafe extern "C" fn recoverLostAndFound2Init(p: *mut sqlite3_recover) {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if ((*p).laf.pAllAndParent).is_null() {} else {
        __assert_fail(
            b"p->laf.pAllAndParent==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16229 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_66120: {
        if ((*p).laf.pAllAndParent).is_null() {} else {
            __assert_fail(
                b"p->laf.pAllAndParent==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16229 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 49],
                    &[libc::c_char; 49],
                >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ((*p).laf.pMapInsert).is_null() {} else {
        __assert_fail(
            b"p->laf.pMapInsert==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16230 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_66076: {
        if ((*p).laf.pMapInsert).is_null() {} else {
            __assert_fail(
                b"p->laf.pMapInsert==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16230 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 49],
                    &[libc::c_char; 49],
                >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    if ((*p).laf.pMaxField).is_null() {} else {
        __assert_fail(
            b"p->laf.pMaxField==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16231 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_66032: {
        if ((*p).laf.pMaxField).is_null() {} else {
            __assert_fail(
                b"p->laf.pMaxField==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16231 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 49],
                    &[libc::c_char; 49],
                >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    if (*p).laf.nMaxField == 0 as libc::c_int {} else {
        __assert_fail(
            b"p->laf.nMaxField==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16232 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_65990: {
        if (*p).laf.nMaxField == 0 as libc::c_int {} else {
            __assert_fail(
                b"p->laf.nMaxField==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16232 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 49],
                    &[libc::c_char; 49],
                >(b"void recoverLostAndFound2Init(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    (*pLaf)
        .pMapInsert = recoverPrepare(
        p,
        (*p).dbOut,
        b"INSERT OR IGNORE INTO recovery.map(pgno, parent) VALUES(?, ?)\0" as *const u8
            as *const libc::c_char,
    );
    (*pLaf)
        .pAllAndParent = recoverPreparePrintf(
        p,
        (*p).dbOut,
        b"WITH RECURSIVE seq(ii) AS (  SELECT 1 UNION ALL SELECT ii+1 FROM seq WHERE ii<%lld)SELECT pgno, child FROM sqlite_dbptr('getpage()')  UNION ALL SELECT NULL, ii FROM seq\0"
            as *const u8 as *const libc::c_char,
        (*p).laf.nPg,
    );
    (*pLaf)
        .pMaxField = recoverPreparePrintf(
        p,
        (*p).dbOut,
        b"SELECT max(field)+1 FROM sqlite_dbdata('getpage') WHERE pgno = ?\0"
            as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn recoverLostAndFound2Step(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    let pLaf: *mut RecoverStateLAF = &mut (*p).laf;
    if (*p).errCode == 0 as libc::c_int {
        let res: libc::c_int = sqlite3_step((*pLaf).pAllAndParent);
        if res == 100 as libc::c_int {
            let iChild: i64_0 = sqlite3_column_int(
                (*pLaf).pAllAndParent,
                1 as libc::c_int,
            ) as i64_0;
            if recoverBitmapQuery((*pLaf).pUsed, iChild) == 0 as libc::c_int {
                sqlite3_bind_int64((*pLaf).pMapInsert, 1 as libc::c_int, iChild);
                sqlite3_bind_value(
                    (*pLaf).pMapInsert,
                    2 as libc::c_int,
                    sqlite3_column_value((*pLaf).pAllAndParent, 0 as libc::c_int),
                );
                sqlite3_step((*pLaf).pMapInsert);
                recoverReset(p, (*pLaf).pMapInsert);
                sqlite3_bind_int64((*pLaf).pMaxField, 1 as libc::c_int, iChild);
                if 100 as libc::c_int == sqlite3_step((*pLaf).pMaxField) {
                    let nMax: libc::c_int = sqlite3_column_int(
                        (*pLaf).pMaxField,
                        0 as libc::c_int,
                    );
                    if nMax > (*pLaf).nMaxField {
                        (*pLaf).nMaxField = nMax;
                    }
                }
                recoverReset(p, (*pLaf).pMaxField);
            }
        } else {
            recoverFinalize(p, (*pLaf).pAllAndParent);
            (*pLaf).pAllAndParent = 0 as *mut sqlite3_stmt;
            return 101 as libc::c_int;
        }
    }
    return (*p).errCode;
}
unsafe extern "C" fn recoverLostAndFoundCleanup(p: *mut sqlite3_recover) {
    recoverBitmapFree((*p).laf.pUsed);
    (*p).laf.pUsed = 0 as *mut RecoverBitmap;
    sqlite3_finalize((*p).laf.pUsedPages);
    sqlite3_finalize((*p).laf.pAllAndParent);
    sqlite3_finalize((*p).laf.pMapInsert);
    sqlite3_finalize((*p).laf.pMaxField);
    sqlite3_finalize((*p).laf.pFindRoot);
    sqlite3_finalize((*p).laf.pInsert);
    sqlite3_finalize((*p).laf.pAllPage);
    sqlite3_finalize((*p).laf.pPageData);
    (*p).laf.pUsedPages = 0 as *mut sqlite3_stmt;
    (*p).laf.pAllAndParent = 0 as *mut sqlite3_stmt;
    (*p).laf.pMapInsert = 0 as *mut sqlite3_stmt;
    (*p).laf.pMaxField = 0 as *mut sqlite3_stmt;
    (*p).laf.pFindRoot = 0 as *mut sqlite3_stmt;
    (*p).laf.pInsert = 0 as *mut sqlite3_stmt;
    (*p).laf.pAllPage = 0 as *mut sqlite3_stmt;
    (*p).laf.pPageData = 0 as *mut sqlite3_stmt;
    sqlite3_free((*p).laf.apVal as *mut libc::c_void);
    (*p).laf.apVal = 0 as *mut *mut sqlite3_value;
}
unsafe extern "C" fn recoverFinalCleanup(p: *mut sqlite3_recover) {
    let mut pTab: *mut RecoverTable = 0 as *mut RecoverTable;
    let mut pNext: *mut RecoverTable = 0 as *mut RecoverTable;
    recoverWriteDataCleanup(p);
    recoverLostAndFoundCleanup(p);
    pTab = (*p).pTblList;
    while !pTab.is_null() {
        pNext = (*pTab).pNext;
        sqlite3_free(pTab as *mut libc::c_void);
        pTab = pNext;
    }
    (*p).pTblList = 0 as *mut RecoverTable;
    sqlite3_finalize((*p).pGetPage);
    (*p).pGetPage = 0 as *mut sqlite3_stmt;
    sqlite3_file_control((*p).dbIn, (*p).zDb, 42 as libc::c_int, 0 as *mut libc::c_void);
    let res: libc::c_int = sqlite3_close((*p).dbOut);
    if res == 0 as libc::c_int {} else {
        __assert_fail(
            b"res==SQLITE_OK\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16337 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 44],
                &[libc::c_char; 44],
            >(b"void recoverFinalCleanup(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_63209: {
        if res == 0 as libc::c_int {} else {
            __assert_fail(
                b"res==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16337 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 44],
                    &[libc::c_char; 44],
                >(b"void recoverFinalCleanup(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    (*p).dbOut = 0 as *mut sqlite3;
}
unsafe extern "C" fn recoverGetU16(a: *const u8_0) -> u32_0 {
    return ((*a.offset(0 as libc::c_int as isize) as u32_0) << 8 as libc::c_int)
        .wrapping_add(*a.offset(1 as libc::c_int as isize) as u32_0);
}
unsafe extern "C" fn recoverGetU32(a: *const u8_0) -> u32_0 {
    return ((*a.offset(0 as libc::c_int as isize) as u32_0) << 24 as libc::c_int)
        .wrapping_add(
            (*a.offset(1 as libc::c_int as isize) as u32_0) << 16 as libc::c_int,
        )
        .wrapping_add(
            (*a.offset(2 as libc::c_int as isize) as u32_0) << 8 as libc::c_int,
        )
        .wrapping_add(*a.offset(3 as libc::c_int as isize) as u32_0);
}
unsafe extern "C" fn recoverGetVarint(
    a: *const u8_0,
    pVal: *mut i64_0,
) -> libc::c_int {
    let mut u: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 8 as libc::c_int {
        u = (u << 7 as libc::c_int)
            .wrapping_add(
                (*a.offset(i as isize) as libc::c_int & 0x7f as libc::c_int)
                    as libc::c_ulonglong,
            );
        if *a.offset(i as isize) as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int
        {
            *pVal = u as sqlite3_int64;
            return i + 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    u = (u << 8 as libc::c_int)
        .wrapping_add(
            (*a.offset(i as isize) as libc::c_int & 0xff as libc::c_int)
                as libc::c_ulonglong,
        );
    *pVal = u as sqlite3_int64;
    return 9 as libc::c_int;
}
unsafe extern "C" fn recoverIsValidPage(
    aTmp: *mut u8_0,
    a: *const u8_0,
    n: libc::c_int,
) -> libc::c_int {
    let aUsed: *mut u8_0 = aTmp;
    let mut nFrag: libc::c_int = 0 as libc::c_int;
    let mut nActual: libc::c_int = 0 as libc::c_int;
    let mut iFree: libc::c_int = 0 as libc::c_int;
    let mut nCell: libc::c_int = 0 as libc::c_int;
    let mut iCellOff: libc::c_int = 0 as libc::c_int;
    let mut iContent: libc::c_int = 0 as libc::c_int;
    let mut eType: libc::c_int = 0 as libc::c_int;
    let mut ii: libc::c_int = 0 as libc::c_int;
    eType = *a.offset(0 as libc::c_int as isize) as libc::c_int;
    if eType != 0x2 as libc::c_int && eType != 0x5 as libc::c_int
        && eType != 0xa as libc::c_int && eType != 0xd as libc::c_int
    {
        return 0 as libc::c_int;
    }
    iFree = recoverGetU16(&*a.offset(1 as libc::c_int as isize)) as libc::c_int;
    nCell = recoverGetU16(&*a.offset(3 as libc::c_int as isize)) as libc::c_int;
    iContent = recoverGetU16(&*a.offset(5 as libc::c_int as isize)) as libc::c_int;
    if iContent == 0 as libc::c_int {
        iContent = 65536 as libc::c_int;
    }
    nFrag = *a.offset(7 as libc::c_int as isize) as libc::c_int;
    if iContent > n {
        return 0 as libc::c_int;
    }
    memset(aUsed as *mut libc::c_void, 0 as libc::c_int, n as libc::c_ulong);
    memset(aUsed as *mut libc::c_void, 0xff as libc::c_int, iContent as libc::c_ulong);
    if iFree != 0 && iFree <= iContent {
        return 0 as libc::c_int;
    }
    while iFree != 0 {
        let mut iNext: libc::c_int = 0 as libc::c_int;
        let mut nByte: libc::c_int = 0 as libc::c_int;
        if iFree > n - 4 as libc::c_int {
            return 0 as libc::c_int;
        }
        iNext = recoverGetU16(&*a.offset(iFree as isize)) as libc::c_int;
        nByte = recoverGetU16(&*a.offset((iFree + 2 as libc::c_int) as isize))
            as libc::c_int;
        if iFree + nByte > n || nByte < 4 as libc::c_int {
            return 0 as libc::c_int;
        }
        if iNext != 0 && iNext < iFree + nByte {
            return 0 as libc::c_int;
        }
        memset(
            &mut *aUsed.offset(iFree as isize) as *mut u8_0 as *mut libc::c_void,
            0xff as libc::c_int,
            nByte as libc::c_ulong,
        );
        iFree = iNext;
    }
    if eType == 0x2 as libc::c_int || eType == 0x5 as libc::c_int {
        iCellOff = 12 as libc::c_int;
    } else {
        iCellOff = 8 as libc::c_int;
    }
    if iCellOff + 2 as libc::c_int * nCell > iContent {
        return 0 as libc::c_int;
    }
    ii = 0 as libc::c_int;
    while ii < nCell {
        let mut iByte: libc::c_int = 0;
        let mut nPayload: i64_0 = 0 as libc::c_int as i64_0;
        let mut nByte_0: libc::c_int = 0 as libc::c_int;
        let iOff: libc::c_int = recoverGetU16(
            &*a.offset((iCellOff + 2 as libc::c_int * ii) as isize),
        ) as libc::c_int;
        if iOff < iContent || iOff > n {
            return 0 as libc::c_int;
        }
        if eType == 0x5 as libc::c_int || eType == 0x2 as libc::c_int {
            nByte_0 += 4 as libc::c_int;
        }
        nByte_0
            += recoverGetVarint(&*a.offset((iOff + nByte_0) as isize), &mut nPayload);
        if eType == 0xd as libc::c_int {
            let mut dummy: i64_0 = 0 as libc::c_int as i64_0;
            nByte_0
                += recoverGetVarint(&*a.offset((iOff + nByte_0) as isize), &mut dummy);
        }
        if eType != 0x5 as libc::c_int {
            let X: libc::c_int = if eType == 0xd as libc::c_int {
                n - 35 as libc::c_int
            } else {
                (n - 12 as libc::c_int) * 64 as libc::c_int / 255 as libc::c_int
                    - 23 as libc::c_int
            };
            let M: libc::c_int = (n - 12 as libc::c_int) * 32 as libc::c_int
                / 255 as libc::c_int - 23 as libc::c_int;
            let K: libc::c_int = (M as libc::c_longlong
                + (nPayload - M as libc::c_longlong)
                    % (n - 4 as libc::c_int) as libc::c_longlong) as libc::c_int;
            if nPayload < X as libc::c_longlong {
                nByte_0 = (nByte_0 as libc::c_longlong + nPayload) as libc::c_int;
            } else if K <= X {
                nByte_0 += K + 4 as libc::c_int;
            } else {
                nByte_0 += M + 4 as libc::c_int;
            }
        }
        if iOff + nByte_0 > n {
            return 0 as libc::c_int;
        }
        iByte = iOff;
        while iByte < iOff + nByte_0 {
            if *aUsed.offset(iByte as isize) as libc::c_int != 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            *aUsed.offset(iByte as isize) = 0xff as libc::c_int as u8_0;
            iByte += 1;
            iByte;
        }
        ii += 1;
        ii;
    }
    nActual = 0 as libc::c_int;
    ii = 0 as libc::c_int;
    while ii < n {
        if *aUsed.offset(ii as isize) as libc::c_int == 0 as libc::c_int {
            nActual += 1;
            nActual;
        }
        ii += 1;
        ii;
    }
    return (nActual == nFrag) as libc::c_int;
}
static mut recover_methods: sqlite3_io_methods = unsafe {
    {
        let init = sqlite3_io_methods {
            iVersion: 2 as libc::c_int,
            xClose: Some(
                recoverVfsClose as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xRead: Some(
                recoverVfsRead
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xWrite: Some(
                recoverVfsWrite
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *const libc::c_void,
                        libc::c_int,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xTruncate: Some(
                recoverVfsTruncate
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSync: Some(
                recoverVfsSync
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileSize: Some(
                recoverVfsFileSize
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xLock: Some(
                recoverVfsLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xUnlock: Some(
                recoverVfsUnlock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xCheckReservedLock: Some(
                recoverVfsCheckReservedLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileControl: Some(
                recoverVfsFileControl
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xSectorSize: Some(
                recoverVfsSectorSize
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xDeviceCharacteristics: Some(
                recoverVfsDeviceCharacteristics
                    as unsafe extern "C" fn(*mut sqlite3_file) -> libc::c_int,
            ),
            xShmMap: Some(
                recoverVfsShmMap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xShmLock: Some(
                recoverVfsShmLock
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                        libc::c_int,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xShmBarrier: Some(
                recoverVfsShmBarrier as unsafe extern "C" fn(*mut sqlite3_file) -> (),
            ),
            xShmUnmap: Some(
                recoverVfsShmUnmap
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        libc::c_int,
                    ) -> libc::c_int,
            ),
            xFetch: Some(
                recoverVfsFetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        libc::c_int,
                        *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xUnfetch: Some(
                recoverVfsUnfetch
                    as unsafe extern "C" fn(
                        *mut sqlite3_file,
                        sqlite3_int64,
                        *mut libc::c_void,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
unsafe extern "C" fn recoverVfsClose(pFd: *mut sqlite3_file) -> libc::c_int {
    if (*pFd).pMethods
        != &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {} else {
        __assert_fail(
            b"pFd->pMethods!=&recover_methods\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16515 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 36],
                &[libc::c_char; 36],
            >(b"int recoverVfsClose(sqlite3_file *)\0"))
                .as_ptr(),
        );
    }
    'c_77846: {
        if (*pFd).pMethods
            != &mut recover_methods as *mut sqlite3_io_methods
                as *const sqlite3_io_methods
        {} else {
            __assert_fail(
                b"pFd->pMethods!=&recover_methods\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16515 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 36],
                    &[libc::c_char; 36],
                >(b"int recoverVfsClose(sqlite3_file *)\0"))
                    .as_ptr(),
            );
        }
    };
    return ((*(*pFd).pMethods).xClose).expect("non-null function pointer")(pFd);
}
unsafe extern "C" fn recoverPutU16(a: *mut u8_0, v: u32_0) {
    *a
        .offset(
            0 as libc::c_int as isize,
        ) = (v >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            1 as libc::c_int as isize,
        ) = (v >> 0 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
unsafe extern "C" fn recoverPutU32(a: *mut u8_0, v: u32_0) {
    *a
        .offset(
            0 as libc::c_int as isize,
        ) = (v >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            1 as libc::c_int as isize,
        ) = (v >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            2 as libc::c_int as isize,
        ) = (v >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *a
        .offset(
            3 as libc::c_int as isize,
        ) = (v >> 0 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
unsafe extern "C" fn recoverVfsDetectPagesize(
    p: *mut sqlite3_recover,
    pFd: *mut sqlite3_file,
    mut nReserve: u32_0,
    nSz: i64_0,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let nMin: libc::c_int = 512 as libc::c_int;
    let nMax: libc::c_int = 65536 as libc::c_int;
    let nMaxBlk: libc::c_int = 4 as libc::c_int;
    let mut pgsz: u32_0 = 0 as libc::c_int as u32_0;
    let mut iBlk: libc::c_int = 0 as libc::c_int;
    let mut aPg: *mut u8_0 = 0 as *mut u8_0;
    let mut aTmp: *mut u8_0 = 0 as *mut u8_0;
    let mut nBlk: libc::c_int = 0 as libc::c_int;
    aPg = sqlite3_malloc(2 as libc::c_int * nMax) as *mut u8_0;
    if aPg.is_null() {
        return 7 as libc::c_int;
    }
    aTmp = &mut *aPg.offset(nMax as isize) as *mut u8_0;
    nBlk = ((nSz + nMax as libc::c_longlong - 1 as libc::c_int as libc::c_longlong)
        / nMax as libc::c_longlong) as libc::c_int;
    if nBlk > nMaxBlk {
        nBlk = nMaxBlk;
    }
    loop {
        iBlk = 0 as libc::c_int;
        while rc == 0 as libc::c_int && iBlk < nBlk {
            let nByte: libc::c_int = (if nSz
                >= ((iBlk + 1 as libc::c_int) * nMax) as libc::c_longlong
            {
                nMax as libc::c_longlong
            } else {
                nSz % nMax as libc::c_longlong
            }) as libc::c_int;
            memset(aPg as *mut libc::c_void, 0 as libc::c_int, nMax as libc::c_ulong);
            rc = ((*(*pFd).pMethods).xRead)
                .expect(
                    "non-null function pointer",
                )(pFd, aPg as *mut libc::c_void, nByte, (iBlk * nMax) as sqlite3_int64);
            if rc == 0 as libc::c_int {
                let mut pgsz2: libc::c_int = 0;
                pgsz2 = (if pgsz != 0 {
                    pgsz.wrapping_mul(2 as libc::c_int as libc::c_uint)
                } else {
                    nMin as libc::c_uint
                }) as libc::c_int;
                while pgsz2 <= nMax {
                    let mut iOff: libc::c_int = 0;
                    iOff = 0 as libc::c_int;
                    while iOff < nMax {
                        if recoverIsValidPage(
                            aTmp,
                            &mut *aPg.offset(iOff as isize),
                            (pgsz2 as libc::c_uint).wrapping_sub(nReserve) as libc::c_int,
                        ) != 0
                        {
                            pgsz = pgsz2 as u32_0;
                            break;
                        } else {
                            iOff += pgsz2;
                        }
                    }
                    pgsz2 = pgsz2 * 2 as libc::c_int;
                }
            }
            iBlk += 1;
            iBlk;
        }
        if pgsz > (*p).detected_pgsz as u32_0 {
            (*p).detected_pgsz = pgsz as libc::c_int;
            (*p).nReserve = nReserve as libc::c_int;
        }
        if nReserve == 0 as libc::c_int as libc::c_uint {
            break;
        }
        nReserve = 0 as libc::c_int as u32_0;
    }
    (*p).detected_pgsz = pgsz as libc::c_int;
    sqlite3_free(aPg as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn recoverVfsRead(
    pFd: *mut sqlite3_file,
    aBuf: *mut libc::c_void,
    nByte: libc::c_int,
    iOff: i64_0,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xRead)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
        if nByte == 16 as libc::c_int {
            sqlite3_randomness(16 as libc::c_int, aBuf);
        } else if rc == 0 as libc::c_int && iOff == 0 as libc::c_int as libc::c_longlong
            && nByte >= 108 as libc::c_int
        {
            let aPreserve: [libc::c_int; 6] = [
                32 as libc::c_int,
                36 as libc::c_int,
                52 as libc::c_int,
                60 as libc::c_int,
                64 as libc::c_int,
                68 as libc::c_int,
            ];
            let mut aHdr: [u8_0; 108] = [
                0x53 as libc::c_int as u8_0,
                0x51 as libc::c_int as u8_0,
                0x4c as libc::c_int as u8_0,
                0x69 as libc::c_int as u8_0,
                0x74 as libc::c_int as u8_0,
                0x65 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0x66 as libc::c_int as u8_0,
                0x6f as libc::c_int as u8_0,
                0x72 as libc::c_int as u8_0,
                0x6d as libc::c_int as u8_0,
                0x61 as libc::c_int as u8_0,
                0x74 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0x33 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0x1 as libc::c_int as u8_0,
                0x1 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x40 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0x20 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x4 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x10 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0x2e as libc::c_int as u8_0,
                0x5b as libc::c_int as u8_0,
                0x30 as libc::c_int as u8_0,
                0xd as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0xff as libc::c_int as u8_0,
                0 as libc::c_int as u8_0,
            ];
            let a: *mut u8_0 = aBuf as *mut u8_0;
            let mut pgsz: u32_0 = recoverGetU16(
                &mut *a.offset(16 as libc::c_int as isize),
            );
            let mut nReserve: u32_0 = *a.offset(20 as libc::c_int as isize) as u32_0;
            let mut enc: u32_0 = recoverGetU32(
                &mut *a.offset(56 as libc::c_int as isize),
            );
            let mut dbsz: u32_0 = 0 as libc::c_int as u32_0;
            let mut dbFileSize: i64_0 = 0 as libc::c_int as i64_0;
            let mut ii: libc::c_int = 0;
            let p: *mut sqlite3_recover = recover_g.p;
            if pgsz == 0x1 as libc::c_int as libc::c_uint {
                pgsz = 65536 as libc::c_int as u32_0;
            }
            rc = ((*(*pFd).pMethods).xFileSize)
                .expect("non-null function pointer")(pFd, &mut dbFileSize);
            if rc == 0 as libc::c_int && (*p).detected_pgsz == 0 as libc::c_int {
                rc = recoverVfsDetectPagesize(p, pFd, nReserve, dbFileSize);
            }
            if (*p).detected_pgsz != 0 {
                pgsz = (*p).detected_pgsz as u32_0;
                nReserve = (*p).nReserve as u32_0;
            }
            if pgsz != 0 {
                dbsz = (dbFileSize / pgsz as libc::c_longlong) as u32_0;
            }
            if enc != 1 as libc::c_int as libc::c_uint
                && enc != 3 as libc::c_int as libc::c_uint
                && enc != 2 as libc::c_int as libc::c_uint
            {
                enc = 1 as libc::c_int as u32_0;
            }
            sqlite3_free((*p).pPage1Cache as *mut libc::c_void);
            (*p).pPage1Cache = 0 as *mut u8_0;
            (*p).pPage1Disk = 0 as *mut u8_0;
            (*p).pgsz = nByte;
            (*p)
                .pPage1Cache = recoverMalloc(p, (nByte * 2 as libc::c_int) as i64_0)
                as *mut u8_0;
            if !((*p).pPage1Cache).is_null() {
                (*p)
                    .pPage1Disk = &mut *((*p).pPage1Cache).offset(nByte as isize)
                    as *mut u8_0;
                memcpy(
                    (*p).pPage1Disk as *mut libc::c_void,
                    aBuf,
                    nByte as libc::c_ulong,
                );
                aHdr[18 as libc::c_int as usize] = *a.offset(18 as libc::c_int as isize);
                aHdr[19 as libc::c_int as usize] = *a.offset(19 as libc::c_int as isize);
                recoverPutU32(
                    &mut *aHdr.as_mut_ptr().offset(28 as libc::c_int as isize),
                    dbsz,
                );
                recoverPutU32(
                    &mut *aHdr.as_mut_ptr().offset(56 as libc::c_int as isize),
                    enc,
                );
                recoverPutU16(
                    &mut *aHdr.as_mut_ptr().offset(105 as libc::c_int as isize),
                    pgsz.wrapping_sub(nReserve),
                );
                if pgsz == 65536 as libc::c_int as libc::c_uint {
                    pgsz = 1 as libc::c_int as u32_0;
                }
                recoverPutU16(
                    &mut *aHdr.as_mut_ptr().offset(16 as libc::c_int as isize),
                    pgsz,
                );
                aHdr[20 as libc::c_int as usize] = nReserve as u8_0;
                ii = 0 as libc::c_int;
                while ii
                    < (::core::mem::size_of::<[libc::c_int; 6]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong,
                        ) as libc::c_int
                {
                    memcpy(
                        &mut *aHdr
                            .as_mut_ptr()
                            .offset(*aPreserve.as_ptr().offset(ii as isize) as isize)
                            as *mut u8_0 as *mut libc::c_void,
                        &mut *a.offset(*aPreserve.as_ptr().offset(ii as isize) as isize)
                            as *mut u8_0 as *const libc::c_void,
                        4 as libc::c_int as libc::c_ulong,
                    );
                    ii += 1;
                    ii;
                }
                memcpy(
                    aBuf,
                    aHdr.as_mut_ptr() as *const libc::c_void,
                    ::core::mem::size_of::<[u8_0; 108]>() as libc::c_ulong,
                );
                memset(
                    &mut *(aBuf as *mut u8_0)
                        .offset(
                            ::core::mem::size_of::<[u8_0; 108]>() as libc::c_ulong
                                as isize,
                        ) as *mut u8_0 as *mut libc::c_void,
                    0 as libc::c_int,
                    (nByte as libc::c_ulong)
                        .wrapping_sub(
                            ::core::mem::size_of::<[u8_0; 108]>() as libc::c_ulong,
                        ),
                );
                memcpy(
                    (*p).pPage1Cache as *mut libc::c_void,
                    aBuf,
                    nByte as libc::c_ulong,
                );
            } else {
                rc = (*p).errCode;
            }
        }
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xRead)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsWrite(
    pFd: *mut sqlite3_file,
    aBuf: *const libc::c_void,
    nByte: libc::c_int,
    iOff: i64_0,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xWrite)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xWrite)
            .expect("non-null function pointer")(pFd, aBuf, nByte, iOff);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsTruncate(
    pFd: *mut sqlite3_file,
    size: sqlite3_int64,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xTruncate)
            .expect("non-null function pointer")(pFd, size);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xTruncate)
            .expect("non-null function pointer")(pFd, size);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsSync(
    pFd: *mut sqlite3_file,
    flags: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xSync).expect("non-null function pointer")(pFd, flags);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xSync).expect("non-null function pointer")(pFd, flags);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsFileSize(
    pFd: *mut sqlite3_file,
    pSize: *mut sqlite3_int64,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xFileSize)
            .expect("non-null function pointer")(pFd, pSize);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xFileSize)
            .expect("non-null function pointer")(pFd, pSize);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsLock(
    pFd: *mut sqlite3_file,
    eLock: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xLock).expect("non-null function pointer")(pFd, eLock);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xLock).expect("non-null function pointer")(pFd, eLock);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsUnlock(
    pFd: *mut sqlite3_file,
    eLock: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xUnlock)
            .expect("non-null function pointer")(pFd, eLock);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xUnlock)
            .expect("non-null function pointer")(pFd, eLock);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsCheckReservedLock(
    pFd: *mut sqlite3_file,
    pResOut: *mut libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xCheckReservedLock)
            .expect("non-null function pointer")(pFd, pResOut);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xCheckReservedLock)
            .expect("non-null function pointer")(pFd, pResOut);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsFileControl(
    pFd: *mut sqlite3_file,
    op: libc::c_int,
    pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = if !((*pFd).pMethods).is_null() {
            ((*(*pFd).pMethods).xFileControl)
                .expect("non-null function pointer")(pFd, op, pArg)
        } else {
            12 as libc::c_int
        };
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = if !((*pFd).pMethods).is_null() {
            ((*(*pFd).pMethods).xFileControl)
                .expect("non-null function pointer")(pFd, op, pArg)
        } else {
            12 as libc::c_int
        };
    }
    return rc;
}
unsafe extern "C" fn recoverVfsSectorSize(pFd: *mut sqlite3_file) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xSectorSize).expect("non-null function pointer")(pFd);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xSectorSize).expect("non-null function pointer")(pFd);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsDeviceCharacteristics(
    pFd: *mut sqlite3_file,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xDeviceCharacteristics)
            .expect("non-null function pointer")(pFd);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xDeviceCharacteristics)
            .expect("non-null function pointer")(pFd);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsShmMap(
    pFd: *mut sqlite3_file,
    iPg: libc::c_int,
    pgsz: libc::c_int,
    bExtend: libc::c_int,
    pp: *mut *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xShmMap)
            .expect("non-null function pointer")(pFd, iPg, pgsz, bExtend, pp);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xShmMap)
            .expect("non-null function pointer")(pFd, iPg, pgsz, bExtend, pp);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsShmLock(
    pFd: *mut sqlite3_file,
    offset: libc::c_int,
    n: libc::c_int,
    flags: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xShmLock)
            .expect("non-null function pointer")(pFd, offset, n, flags);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xShmLock)
            .expect("non-null function pointer")(pFd, offset, n, flags);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsShmBarrier(pFd: *mut sqlite3_file) {
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        ((*(*pFd).pMethods).xShmBarrier).expect("non-null function pointer")(pFd);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        ((*(*pFd).pMethods).xShmBarrier).expect("non-null function pointer")(pFd);
    };
}
unsafe extern "C" fn recoverVfsShmUnmap(
    pFd: *mut sqlite3_file,
    deleteFlag: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pFd).pMethods
        == &mut recover_methods as *mut sqlite3_io_methods as *const sqlite3_io_methods
    {
        (*pFd).pMethods = recover_g.pMethods;
        rc = ((*(*pFd).pMethods).xShmUnmap)
            .expect("non-null function pointer")(pFd, deleteFlag);
        (*pFd).pMethods = &mut recover_methods;
    } else {
        rc = ((*(*pFd).pMethods).xShmUnmap)
            .expect("non-null function pointer")(pFd, deleteFlag);
    }
    return rc;
}
unsafe extern "C" fn recoverVfsFetch(
    _pFd: *mut sqlite3_file,
    _iOff: sqlite3_int64,
    _iAmt: libc::c_int,
    pp: *mut *mut libc::c_void,
) -> libc::c_int {
    *pp = 0 as *mut libc::c_void;
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverVfsUnfetch(
    _pFd: *mut sqlite3_file,
    _iOff: sqlite3_int64,
    _p: *mut libc::c_void,
) -> libc::c_int {
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverInstallWrapper(p: *mut sqlite3_recover) {
    let mut pFd: *mut sqlite3_file = 0 as *mut sqlite3_file;
    if (recover_g.pMethods).is_null() {} else {
        __assert_fail(
            b"recover_g.pMethods==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16845 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 46],
                &[libc::c_char; 46],
            >(b"void recoverInstallWrapper(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_78012: {
        if (recover_g.pMethods).is_null() {} else {
            __assert_fail(
                b"recover_g.pMethods==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16845 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 46],
                    &[libc::c_char; 46],
                >(b"void recoverInstallWrapper(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    sqlite3_file_control(
        (*p).dbIn,
        (*p).zDb,
        7 as libc::c_int,
        &mut pFd as *mut *mut sqlite3_file as *mut libc::c_void,
    );
    if pFd.is_null()
        || (*pFd).pMethods
            != &mut recover_methods as *mut sqlite3_io_methods
                as *const sqlite3_io_methods
    {} else {
        __assert_fail(
            b"pFd==0 || pFd->pMethods!=&recover_methods\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16848 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 46],
                &[libc::c_char; 46],
            >(b"void recoverInstallWrapper(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_77940: {
        if pFd.is_null()
            || (*pFd).pMethods
                != &mut recover_methods as *mut sqlite3_io_methods
                    as *const sqlite3_io_methods
        {} else {
            __assert_fail(
                b"pFd==0 || pFd->pMethods!=&recover_methods\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16848 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 46],
                    &[libc::c_char; 46],
                >(b"void recoverInstallWrapper(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    if !pFd.is_null() && !((*pFd).pMethods).is_null() {
        let iVersion: libc::c_int = 1 as libc::c_int
            + ((*(*pFd).pMethods).iVersion > 1 as libc::c_int
                && ((*(*pFd).pMethods).xShmMap).is_some()) as libc::c_int;
        recover_g.pMethods = (*pFd).pMethods;
        recover_g.p = p;
        recover_methods.iVersion = iVersion;
        (*pFd).pMethods = &mut recover_methods;
    }
}
unsafe extern "C" fn recoverUninstallWrapper(p: *mut sqlite3_recover) {
    let mut pFd: *mut sqlite3_file = 0 as *mut sqlite3_file;
    sqlite3_file_control(
        (*p).dbIn,
        (*p).zDb,
        7 as libc::c_int,
        &mut pFd as *mut *mut sqlite3_file as *mut libc::c_void,
    );
    if !pFd.is_null() && !((*pFd).pMethods).is_null() {
        (*pFd).pMethods = recover_g.pMethods;
        recover_g.pMethods = 0 as *const sqlite3_io_methods;
        recover_g.p = 0 as *mut sqlite3_recover;
    }
}
unsafe extern "C" fn recoverStep(p: *mut sqlite3_recover) {
    if !p.is_null() && (*p).errCode == 0 as libc::c_int {} else {
        __assert_fail(
            b"p && p->errCode==SQLITE_OK\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            16880 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 36],
                &[libc::c_char; 36],
            >(b"void recoverStep(sqlite3_recover *)\0"))
                .as_ptr(),
        );
    }
    'c_78085: {
        if !p.is_null() && (*p).errCode == 0 as libc::c_int {} else {
            __assert_fail(
                b"p && p->errCode==SQLITE_OK\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                16880 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 36],
                    &[libc::c_char; 36],
                >(b"void recoverStep(sqlite3_recover *)\0"))
                    .as_ptr(),
            );
        }
    };
    match (*p).eState {
        0 => {
            recoverSqlCallback(p, b"BEGIN\0" as *const u8 as *const libc::c_char);
            recoverSqlCallback(
                p,
                b"PRAGMA writable_schema = on\0" as *const u8 as *const libc::c_char,
            );
            recoverEnterMutex();
            recoverInstallWrapper(p);
            recoverOpenOutput(p);
            sqlite3_file_control(
                (*p).dbIn,
                (*p).zDb,
                42 as libc::c_int,
                0 as *mut libc::c_void,
            );
            recoverExec(
                p,
                (*p).dbIn,
                b"PRAGMA writable_schema = on\0" as *const u8 as *const libc::c_char,
            );
            recoverExec(p, (*p).dbIn, b"BEGIN\0" as *const u8 as *const libc::c_char);
            if (*p).errCode == 0 as libc::c_int {
                (*p).bCloseTransaction = 1 as libc::c_int;
            }
            recoverExec(
                p,
                (*p).dbIn,
                b"SELECT 1 FROM sqlite_schema\0" as *const u8 as *const libc::c_char,
            );
            recoverTransferSettings(p);
            recoverOpenRecovery(p);
            recoverCacheSchema(p);
            recoverUninstallWrapper(p);
            recoverLeaveMutex();
            recoverExec(p, (*p).dbOut, b"BEGIN\0" as *const u8 as *const libc::c_char);
            recoverWriteSchema1(p);
            (*p).eState = 1 as libc::c_int;
        }
        1 => {
            if ((*p).w1.pTbls).is_null() {
                recoverWriteDataInit(p);
            }
            if 101 as libc::c_int == recoverWriteDataStep(p) {
                recoverWriteDataCleanup(p);
                if !((*p).zLostAndFound).is_null() {
                    (*p).eState = 2 as libc::c_int;
                } else {
                    (*p).eState = 5 as libc::c_int;
                }
            }
        }
        2 => {
            if ((*p).laf.pUsed).is_null() {
                recoverLostAndFound1Init(p);
            }
            if 101 as libc::c_int == recoverLostAndFound1Step(p) {
                (*p).eState = 3 as libc::c_int;
            }
        }
        3 => {
            if ((*p).laf.pAllAndParent).is_null() {
                recoverLostAndFound2Init(p);
            }
            if 101 as libc::c_int == recoverLostAndFound2Step(p) {
                (*p).eState = 4 as libc::c_int;
            }
        }
        4 => {
            if ((*p).laf.pInsert).is_null() {
                recoverLostAndFound3Init(p);
            }
            if 101 as libc::c_int == recoverLostAndFound3Step(p) {
                (*p).eState = 5 as libc::c_int;
            }
        }
        5 => {
            let mut rc: libc::c_int = 0 as libc::c_int;
            recoverWriteSchema2(p);
            (*p).eState = 6 as libc::c_int;
            recoverExec(p, (*p).dbOut, b"COMMIT\0" as *const u8 as *const libc::c_char);
            rc = sqlite3_exec(
                (*p).dbIn,
                b"END\0" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if (*p).errCode == 0 as libc::c_int {
                (*p).errCode = rc;
            }
            recoverSqlCallback(
                p,
                b"PRAGMA writable_schema = off\0" as *const u8 as *const libc::c_char,
            );
            recoverSqlCallback(p, b"COMMIT\0" as *const u8 as *const libc::c_char);
            (*p).eState = 6 as libc::c_int;
            recoverFinalCleanup(p);
        }
        6 | _ => {}
    };
}
#[no_mangle]
pub unsafe extern "C" fn recoverInit(
    db: *mut sqlite3,
    mut zDb: *const libc::c_char,
    zUri: *const libc::c_char,
    xSql: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int,
    >,
    pSqlCtx: *mut libc::c_void,
) -> *mut sqlite3_recover {
    let mut pRet: *mut sqlite3_recover = 0 as *mut sqlite3_recover;
    let mut nDb: libc::c_int = 0 as libc::c_int;
    let mut nUri: libc::c_int = 0 as libc::c_int;
    let mut nByte: libc::c_int = 0 as libc::c_int;
    if zDb.is_null() {
        zDb = b"main\0" as *const u8 as *const libc::c_char;
    }
    nDb = recoverStrlen(zDb);
    nUri = recoverStrlen(zUri);
    nByte = (::core::mem::size_of::<sqlite3_recover>() as libc::c_ulong)
        .wrapping_add(nDb as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        .wrapping_add(nUri as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    pRet = sqlite3_malloc(nByte) as *mut sqlite3_recover;
    if !pRet.is_null() {
        memset(pRet as *mut libc::c_void, 0 as libc::c_int, nByte as libc::c_ulong);
        (*pRet).dbIn = db;
        (*pRet)
            .zDb = &mut *pRet.offset(1 as libc::c_int as isize) as *mut sqlite3_recover
            as *mut libc::c_char;
        (*pRet)
            .zUri = &mut *((*pRet).zDb).offset((nDb + 1 as libc::c_int) as isize)
            as *mut libc::c_char;
        memcpy(
            (*pRet).zDb as *mut libc::c_void,
            zDb as *const libc::c_void,
            nDb as libc::c_ulong,
        );
        if nUri > 0 as libc::c_int && !zUri.is_null() {
            memcpy(
                (*pRet).zUri as *mut libc::c_void,
                zUri as *const libc::c_void,
                nUri as libc::c_ulong,
            );
        }
        (*pRet).xSql = xSql;
        (*pRet).pSqlCtx = pSqlCtx;
        (*pRet).bRecoverRowid = 1 as libc::c_int;
    }
    return pRet;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_init(
    db: *mut sqlite3,
    zDb: *const libc::c_char,
    zUri: *const libc::c_char,
) -> *mut sqlite3_recover {
    return recoverInit(db, zDb, zUri, None, 0 as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_init_sql(
    db: *mut sqlite3,
    zDb: *const libc::c_char,
    xSql: Option::<
        unsafe extern "C" fn(*mut libc::c_void, *const libc::c_char) -> libc::c_int,
    >,
    pSqlCtx: *mut libc::c_void,
) -> *mut sqlite3_recover {
    return recoverInit(db, zDb, 0 as *const libc::c_char, xSql, pSqlCtx);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_errmsg(
    p: *mut sqlite3_recover,
) -> *const libc::c_char {
    return if !p.is_null() && (*p).errCode != 7 as libc::c_int {
        (*p).zErrMsg as *const libc::c_char
    } else {
        b"out of memory\0" as *const u8 as *const libc::c_char
    };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_errcode(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    return if !p.is_null() { (*p).errCode } else { 7 as libc::c_int };
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_config(
    p: *mut sqlite3_recover,
    op: libc::c_int,
    pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if p.is_null() {
        rc = 7 as libc::c_int;
    } else if (*p).eState != 0 as libc::c_int {
        rc = 21 as libc::c_int;
    } else {
        match op {
            789 => {
                sqlite3_free((*p).zStateDb as *mut libc::c_void);
                (*p)
                    .zStateDb = recoverMPrintf(
                    p,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    pArg as *mut libc::c_char,
                );
            }
            1 => {
                let zArg: *const libc::c_char = pArg as *const libc::c_char;
                sqlite3_free((*p).zLostAndFound as *mut libc::c_void);
                if !zArg.is_null() {
                    (*p)
                        .zLostAndFound = recoverMPrintf(
                        p,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        zArg,
                    );
                } else {
                    (*p).zLostAndFound = 0 as *mut libc::c_char;
                }
            }
            2 => {
                (*p).bFreelistCorrupt = *(pArg as *mut libc::c_int);
            }
            3 => {
                (*p).bRecoverRowid = *(pArg as *mut libc::c_int);
            }
            4 => {
                (*p).bSlowIndexes = *(pArg as *mut libc::c_int);
            }
            _ => {
                rc = 12 as libc::c_int;
            }
        }
    }
    return rc;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_step(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    if p.is_null() {
        return 7 as libc::c_int;
    }
    if (*p).errCode == 0 as libc::c_int {
        recoverStep(p);
    }
    if (*p).eState == 6 as libc::c_int && (*p).errCode == 0 as libc::c_int {
        return 101 as libc::c_int;
    }
    return (*p).errCode;
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_run(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    while 0 as libc::c_int == sqlite3_recover_step(p) {}
    return sqlite3_recover_errcode(p);
}
#[no_mangle]
pub unsafe extern "C" fn sqlite3_recover_finish(
    p: *mut sqlite3_recover,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if p.is_null() {
        rc = 7 as libc::c_int;
    } else {
        recoverFinalCleanup(p);
        if (*p).bCloseTransaction != 0
            && sqlite3_get_autocommit((*p).dbIn) == 0 as libc::c_int
        {
            rc = sqlite3_exec(
                (*p).dbIn,
                b"END\0" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if (*p).errCode == 0 as libc::c_int {
                (*p).errCode = rc;
            }
        }
        rc = (*p).errCode;
        sqlite3_free((*p).zErrMsg as *mut libc::c_void);
        sqlite3_free((*p).zStateDb as *mut libc::c_void);
        sqlite3_free((*p).zLostAndFound as *mut libc::c_void);
        sqlite3_free((*p).pPage1Cache as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    }
    return rc;
}
static mut modeDescr: [*const libc::c_char; 19] = [
    b"line\0" as *const u8 as *const libc::c_char,
    b"column\0" as *const u8 as *const libc::c_char,
    b"list\0" as *const u8 as *const libc::c_char,
    b"semi\0" as *const u8 as *const libc::c_char,
    b"html\0" as *const u8 as *const libc::c_char,
    b"insert\0" as *const u8 as *const libc::c_char,
    b"quote\0" as *const u8 as *const libc::c_char,
    b"tcl\0" as *const u8 as *const libc::c_char,
    b"csv\0" as *const u8 as *const libc::c_char,
    b"explain\0" as *const u8 as *const libc::c_char,
    b"ascii\0" as *const u8 as *const libc::c_char,
    b"prettyprint\0" as *const u8 as *const libc::c_char,
    b"eqp\0" as *const u8 as *const libc::c_char,
    b"json\0" as *const u8 as *const libc::c_char,
    b"markdown\0" as *const u8 as *const libc::c_char,
    b"table\0" as *const u8 as *const libc::c_char,
    b"box\0" as *const u8 as *const libc::c_char,
    b"count\0" as *const u8 as *const libc::c_char,
    b"off\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn shellLog(
    pArg: *mut libc::c_void,
    iErrCode: libc::c_int,
    zMsg: *const libc::c_char,
) {
    let p: *mut ShellState = pArg as *mut ShellState;
    if ((*p).pLog).is_null() {
        return;
    }
    fprintf(
        (*p).pLog,
        b"(%d) %s\n\0" as *const u8 as *const libc::c_char,
        iErrCode,
        zMsg,
    );
    fflush((*p).pLog);
}
unsafe extern "C" fn shellPutsFunc(
    pCtx: *mut sqlite3_context,
    _nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    let p: *mut ShellState = sqlite3_user_data(pCtx) as *mut ShellState;
    fprintf(
        (*p).out,
        b"%s\n\0" as *const u8 as *const libc::c_char,
        sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)),
    );
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
unsafe extern "C" fn failIfSafeMode(
    p: *mut ShellState,
    zErrMsg: *const libc::c_char,
    args: ...
) {
    if (*p).bSafeMode != 0 {
        let mut ap: ::core::ffi::VaListImpl;
        let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        zMsg = sqlite3_vmprintf(zErrMsg, ap.as_va_list());
        fprintf(stderr, b"line %d: \0" as *const u8 as *const libc::c_char, (*p).lineno);
        fprintf(stderr, b"%s\n\0" as *const u8 as *const libc::c_char, zMsg);
        exit(1 as libc::c_int);
    }
}
unsafe extern "C" fn editFunc(
    context: *mut sqlite3_context,
    argc: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let mut zEditor: *const libc::c_char = 0 as *const libc::c_char;
    let mut zTempFile: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bBin: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut hasCRNL: libc::c_int = 0 as libc::c_int;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut sz: sqlite3_int64 = 0;
    let mut x: sqlite3_int64 = 0;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if argc == 2 as libc::c_int {
        zEditor = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
            as *const libc::c_char;
    } else {
        zEditor = getenv(b"VISUAL\0" as *const u8 as *const libc::c_char);
    }
    if zEditor.is_null() {
        sqlite3_result_error(
            context,
            b"no editor for edit()\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        sqlite3_result_error(
            context,
            b"NULL input to edit()\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    }
    db = sqlite3_context_db_handle(context);
    zTempFile = 0 as *mut libc::c_char;
    sqlite3_file_control(
        db,
        0 as *const libc::c_char,
        16 as libc::c_int,
        &mut zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
    );
    if zTempFile.is_null() {
        let mut r: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        sqlite3_randomness(
            ::core::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTempFile = sqlite3_mprintf(
            b"temp%llx\0" as *const u8 as *const libc::c_char,
            r,
        );
        if zTempFile.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        }
    }
    bBin = (sqlite3_value_type(*argv.offset(0 as libc::c_int as isize))
        == 4 as libc::c_int) as libc::c_int;
    f = fopen(
        zTempFile,
        if bBin != 0 {
            b"wb\0" as *const u8 as *const libc::c_char
        } else {
            b"w\0" as *const u8 as *const libc::c_char
        },
    );
    if f.is_null() {
        sqlite3_result_error(
            context,
            b"edit() cannot open temp file\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
    } else {
        sz = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize))
            as sqlite3_int64;
        if bBin != 0 {
            x = fwrite(
                sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)),
                1 as libc::c_int as libc::c_ulong,
                sz as size_t,
                f,
            ) as sqlite3_int64;
        } else {
            let z: *const libc::c_char = sqlite3_value_text(
                *argv.offset(0 as libc::c_int as isize),
            ) as *const libc::c_char;
            if !z.is_null()
                && !(strstr(z, b"\r\n\0" as *const u8 as *const libc::c_char)).is_null()
            {
                hasCRNL = 1 as libc::c_int;
            }
            x = fwrite(
                sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
                    as *const libc::c_void,
                1 as libc::c_int as libc::c_ulong,
                sz as size_t,
                f,
            ) as sqlite3_int64;
        }
        fclose(f);
        f = 0 as *mut FILE;
        if x != sz {
            sqlite3_result_error(
                context,
                b"edit() could not write the whole file\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            zCmd = sqlite3_mprintf(
                b"%s \"%s\"\0" as *const u8 as *const libc::c_char,
                zEditor,
                zTempFile,
            );
            if zCmd.is_null() {
                sqlite3_result_error_nomem(context);
            } else {
                rc = system(zCmd);
                sqlite3_free(zCmd as *mut libc::c_void);
                if rc != 0 {
                    sqlite3_result_error(
                        context,
                        b"EDITOR returned non-zero\0" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                    );
                } else {
                    f = fopen(zTempFile, b"rb\0" as *const u8 as *const libc::c_char);
                    if f.is_null() {
                        sqlite3_result_error(
                            context,
                            b"edit() cannot reopen temp file after edit\0" as *const u8
                                as *const libc::c_char,
                            -(1 as libc::c_int),
                        );
                    } else {
                        fseek(f, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
                        sz = ftell(f) as sqlite3_int64;
                        rewind(f);
                        p = sqlite3_malloc64(
                            (sz + 1 as libc::c_int as libc::c_longlong) as sqlite3_uint64,
                        ) as *mut libc::c_uchar;
                        if p.is_null() {
                            sqlite3_result_error_nomem(context);
                        } else {
                            x = fread(
                                p as *mut libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                sz as size_t,
                                f,
                            ) as sqlite3_int64;
                            fclose(f);
                            f = 0 as *mut FILE;
                            if x != sz {
                                sqlite3_result_error(
                                    context,
                                    b"could not read back the whole file\0" as *const u8
                                        as *const libc::c_char,
                                    -(1 as libc::c_int),
                                );
                            } else {
                                if bBin != 0 {
                                    sqlite3_result_blob64(
                                        context,
                                        p as *const libc::c_void,
                                        sz as sqlite3_uint64,
                                        Some(
                                            sqlite3_free
                                                as unsafe extern "C" fn(*mut libc::c_void) -> (),
                                        ),
                                    );
                                } else {
                                    let mut i: sqlite3_int64 = 0;
                                    let mut j: sqlite3_int64 = 0;
                                    if !(hasCRNL != 0) {
                                        *p.offset(sz as isize) = 0 as libc::c_int as libc::c_uchar;
                                        j = 0 as libc::c_int as sqlite3_int64;
                                        i = j;
                                        while i < sz {
                                            if *p.offset(i as isize) as libc::c_int == '\r' as i32
                                                && *p
                                                    .offset((i + 1 as libc::c_int as libc::c_longlong) as isize)
                                                    as libc::c_int == '\n' as i32
                                            {
                                                i += 1;
                                                i;
                                            }
                                            let fresh65 = j;
                                            j = j + 1;
                                            *p.offset(fresh65 as isize) = *p.offset(i as isize);
                                            i += 1;
                                            i;
                                        }
                                        sz = j;
                                        *p.offset(sz as isize) = 0 as libc::c_int as libc::c_uchar;
                                    }
                                    sqlite3_result_text64(
                                        context,
                                        p as *const libc::c_char,
                                        sz as sqlite3_uint64,
                                        Some(
                                            sqlite3_free
                                                as unsafe extern "C" fn(*mut libc::c_void) -> (),
                                        ),
                                        1 as libc::c_int as libc::c_uchar,
                                    );
                                }
                                p = 0 as *mut libc::c_uchar;
                            }
                        }
                    }
                }
            }
        }
    }
    if !f.is_null() {
        fclose(f);
    }
    unlink(zTempFile);
    sqlite3_free(zTempFile as *mut libc::c_void);
    sqlite3_free(p as *mut libc::c_void);
}
unsafe extern "C" fn outputModePush(p: *mut ShellState) {
    (*p).modePrior = (*p).mode;
    (*p).priorShFlgs = (*p).shellFlgs;
    memcpy(
        ((*p).colSepPrior).as_mut_ptr() as *mut libc::c_void,
        ((*p).colSeparator).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        ((*p).rowSepPrior).as_mut_ptr() as *mut libc::c_void,
        ((*p).rowSeparator).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn outputModePop(p: *mut ShellState) {
    (*p).mode = (*p).modePrior;
    (*p).shellFlgs = (*p).priorShFlgs;
    memcpy(
        ((*p).colSeparator).as_mut_ptr() as *mut libc::c_void,
        ((*p).colSepPrior).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        ((*p).rowSeparator).as_mut_ptr() as *mut libc::c_void,
        ((*p).rowSepPrior).as_mut_ptr() as *const libc::c_void,
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn output_hex_blob(
    out: *mut FILE,
    pBlob: *const libc::c_void,
    nBlob: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let aBlob: *mut libc::c_uchar = pBlob as *mut libc::c_uchar;
    let zStr: *mut libc::c_char = sqlite3_malloc(
        nBlob * 2 as libc::c_int + 1 as libc::c_int,
    ) as *mut libc::c_char;
    shell_check_oom(zStr as *const libc::c_void);
    i = 0 as libc::c_int;
    while i < nBlob {
        static mut aHex: [libc::c_char; 16] = [
            '0' as i32 as libc::c_char,
            '1' as i32 as libc::c_char,
            '2' as i32 as libc::c_char,
            '3' as i32 as libc::c_char,
            '4' as i32 as libc::c_char,
            '5' as i32 as libc::c_char,
            '6' as i32 as libc::c_char,
            '7' as i32 as libc::c_char,
            '8' as i32 as libc::c_char,
            '9' as i32 as libc::c_char,
            'a' as i32 as libc::c_char,
            'b' as i32 as libc::c_char,
            'c' as i32 as libc::c_char,
            'd' as i32 as libc::c_char,
            'e' as i32 as libc::c_char,
            'f' as i32 as libc::c_char,
        ];
        *zStr
            .offset(
                (i * 2 as libc::c_int) as isize,
            ) = aHex[(*aBlob.offset(i as isize) as libc::c_int >> 4 as libc::c_int)
            as usize];
        *zStr
            .offset(
                (i * 2 as libc::c_int + 1 as libc::c_int) as isize,
            ) = aHex[(*aBlob.offset(i as isize) as libc::c_int & 0xf as libc::c_int)
            as usize];
        i += 1;
        i;
    }
    *zStr.offset((i * 2 as libc::c_int) as isize) = '\0' as i32 as libc::c_char;
    fprintf(out, b"X'%s'\0" as *const u8 as *const libc::c_char, zStr);
    sqlite3_free(zStr as *mut libc::c_void);
}
unsafe extern "C" fn unused_string(
    z: *const libc::c_char,
    zA: *const libc::c_char,
    zB: *const libc::c_char,
    zBuf: *mut libc::c_char,
) -> *const libc::c_char {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if (strstr(z, zA)).is_null() {
        return zA;
    }
    if (strstr(z, zB)).is_null() {
        return zB;
    }
    loop {
        let fresh66 = i;
        i = i.wrapping_add(1);
        sqlite3_snprintf(
            20 as libc::c_int,
            zBuf,
            b"(%s%u)\0" as *const u8 as *const libc::c_char,
            zA,
            fresh66,
        );
        if (strstr(z, zBuf)).is_null() {
            break;
        }
    }
    return zBuf;
}
unsafe extern "C" fn output_quoted_string(
    out: *mut FILE,
    mut z: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    if z.is_null() {
        return;
    }
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32) {
            break;
        }
        i += 1;
        i;
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"'%s'\0" as *const u8 as *const libc::c_char, z);
    } else {
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1;
                i;
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1;
                i;
            }
            if i != 0 {
                fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize);
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
                z;
            }
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
    };
}
unsafe extern "C" fn output_quoted_escaped_string(
    out: *mut FILE,
    mut z: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32
            && c as libc::c_int != '\n' as i32 && c as libc::c_int != '\r' as i32)
        {
            break;
        }
        i += 1;
        i;
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"'%s'\0" as *const u8 as *const libc::c_char, z);
    } else {
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        i = 0 as libc::c_int;
        while *z.offset(i as isize) != 0 {
            if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
                nNL += 1;
                nNL;
            }
            if *z.offset(i as isize) as libc::c_int == '\r' as i32 {
                nCR += 1;
                nCR;
            }
            i += 1;
            i;
        }
        if nNL != 0 {
            fprintf(out, b"replace(\0" as *const u8 as *const libc::c_char);
            zNL = unused_string(
                z,
                b"\\n\0" as *const u8 as *const libc::c_char,
                b"\\012\0" as *const u8 as *const libc::c_char,
                zBuf1.as_mut_ptr(),
            );
        }
        if nCR != 0 {
            fprintf(out, b"replace(\0" as *const u8 as *const libc::c_char);
            zCR = unused_string(
                z,
                b"\\r\0" as *const u8 as *const libc::c_char,
                b"\\015\0" as *const u8 as *const libc::c_char,
                zBuf2.as_mut_ptr(),
            );
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\n' as i32 && c as libc::c_int != '\r' as i32
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1;
                i;
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1;
                i;
            }
            if i != 0 {
                fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize);
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
                z;
                if c as libc::c_int == '\n' as i32 {
                    fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zNL);
                } else {
                    fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zCR);
                }
            }
        }
        fprintf(out, b"'\0" as *const u8 as *const libc::c_char);
        if nCR != 0 {
            fprintf(out, b",'%s',char(13))\0" as *const u8 as *const libc::c_char, zCR);
        }
        if nNL != 0 {
            fprintf(out, b",'%s',char(10))\0" as *const u8 as *const libc::c_char, zNL);
        }
    };
}
unsafe extern "C" fn output_c_string(out: *mut FILE, mut z: *const libc::c_char) {
    let mut c: libc::c_uint = 0;
    fputc('"' as i32, out);
    loop {
        let fresh67 = z;
        z = z.offset(1);
        c = *fresh67 as libc::c_uint;
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        if c == '\\' as i32 as libc::c_uint {
            fputc(c as libc::c_int, out);
            fputc(c as libc::c_int, out);
        } else if c == '"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('"' as i32, out);
        } else if c == '\t' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('t' as i32, out);
        } else if c == '\n' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('n' as i32, out);
        } else if c == '\r' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('r' as i32, out);
        } else if *(*__ctype_b_loc())
            .offset((c & 0xff as libc::c_int as libc::c_uint) as libc::c_int as isize)
            as libc::c_int & _ISprint as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            fprintf(
                out,
                b"\\%03o\0" as *const u8 as *const libc::c_char,
                c & 0xff as libc::c_int as libc::c_uint,
            );
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('"' as i32, out);
}
unsafe extern "C" fn output_json_string(
    out: *mut FILE,
    mut z: *const libc::c_char,
    mut n: i64_0,
) {
    let mut c: libc::c_uint = 0;
    if z.is_null() {
        z = b"\0" as *const u8 as *const libc::c_char;
    }
    if n < 0 as libc::c_int as libc::c_longlong {
        n = strlen(z) as i64_0;
    }
    fputc('"' as i32, out);
    loop {
        let fresh68 = n;
        n = n - 1;
        if !(fresh68 != 0) {
            break;
        }
        let fresh69 = z;
        z = z.offset(1);
        c = *fresh69 as libc::c_uint;
        if c == '\\' as i32 as libc::c_uint || c == '"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc(c as libc::c_int, out);
        } else if c <= 0x1f as libc::c_int as libc::c_uint {
            fputc('\\' as i32, out);
            if c == '\u{8}' as i32 as libc::c_uint {
                fputc('b' as i32, out);
            } else if c == '\u{c}' as i32 as libc::c_uint {
                fputc('f' as i32, out);
            } else if c == '\n' as i32 as libc::c_uint {
                fputc('n' as i32, out);
            } else if c == '\r' as i32 as libc::c_uint {
                fputc('r' as i32, out);
            } else if c == '\t' as i32 as libc::c_uint {
                fputc('t' as i32, out);
            } else {
                fprintf(out, b"u%04x\0" as *const u8 as *const libc::c_char, c);
            }
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('"' as i32, out);
}
unsafe extern "C" fn output_html_string(out: *mut FILE, mut z: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    if z.is_null() {
        z = b"\0" as *const u8 as *const libc::c_char;
    }
    while *z != 0 {
        i = 0 as libc::c_int;
        while *z.offset(i as isize) as libc::c_int != 0
            && *z.offset(i as isize) as libc::c_int != '<' as i32
            && *z.offset(i as isize) as libc::c_int != '&' as i32
            && *z.offset(i as isize) as libc::c_int != '>' as i32
            && *z.offset(i as isize) as libc::c_int != '"' as i32
            && *z.offset(i as isize) as libc::c_int != '\'' as i32
        {
            i += 1;
            i;
        }
        if i > 0 as libc::c_int {
            fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, i, z);
        }
        if *z.offset(i as isize) as libc::c_int == '<' as i32 {
            fprintf(out, b"&lt;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '&' as i32 {
            fprintf(out, b"&amp;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '>' as i32 {
            fprintf(out, b"&gt;\0" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '"' as i32 {
            fprintf(out, b"&quot;\0" as *const u8 as *const libc::c_char);
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\'' as i32) {
                break;
            }
            fprintf(out, b"&#39;\0" as *const u8 as *const libc::c_char);
        }
        z = z.offset((i + 1 as libc::c_int) as isize);
    }
}
static mut needCsvQuote: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
unsafe extern "C" fn output_csv(
    p: *mut ShellState,
    z: *const libc::c_char,
    bSep: libc::c_int,
) {
    let out: *mut FILE = (*p).out;
    if z.is_null() {
        fprintf(
            out,
            b"%s\0" as *const u8 as *const libc::c_char,
            ((*p).nullValue).as_mut_ptr(),
        );
    } else {
        let mut i: libc::c_uint = 0;
        i = 0 as libc::c_int as libc::c_uint;
        while *z.offset(i as isize) != 0 {
            if needCsvQuote[*(z as *mut libc::c_uchar).offset(i as isize) as usize] != 0
            {
                i = 0 as libc::c_int as libc::c_uint;
                break;
            } else {
                i = i.wrapping_add(1);
                i;
            }
        }
        if i == 0 as libc::c_int as libc::c_uint
            || !(strstr(z, ((*p).colSeparator).as_mut_ptr())).is_null()
        {
            let zQuoted: *mut libc::c_char = sqlite3_mprintf(
                b"\"%w\"\0" as *const u8 as *const libc::c_char,
                z,
            );
            shell_check_oom(zQuoted as *const libc::c_void);
            fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, zQuoted);
            sqlite3_free(zQuoted as *mut libc::c_void);
        } else {
            fprintf(out, b"%s\0" as *const u8 as *const libc::c_char, z);
        }
    }
    if bSep != 0 {
        fprintf(
            (*p).out,
            b"%s\0" as *const u8 as *const libc::c_char,
            ((*p).colSeparator).as_mut_ptr(),
        );
    }
}
unsafe extern "C" fn interrupt_handler(_NotUsed: libc::c_int) {
    ::core::ptr::write_volatile(
        &mut seenInterrupt as *mut libc::c_int,
        ::core::ptr::read_volatile::<libc::c_int>(&seenInterrupt as *const libc::c_int)
            + 1,
    );
    if ::core::ptr::read_volatile::<libc::c_int>(&seenInterrupt as *const libc::c_int)
        > 1 as libc::c_int
    {
        exit(1 as libc::c_int);
    }
    if !globalDb.is_null() {
        sqlite3_interrupt(globalDb);
    }
}
unsafe extern "C" fn safeModeAuth(
    pClientData: *mut libc::c_void,
    op: libc::c_int,
    _zA1: *const libc::c_char,
    zA2: *const libc::c_char,
    _zA3: *const libc::c_char,
    _zA4: *const libc::c_char,
) -> libc::c_int {
    let p: *mut ShellState = pClientData as *mut ShellState;
    static mut azProhibitedFunctions: [*const libc::c_char; 7] = [
        b"edit\0" as *const u8 as *const libc::c_char,
        b"fts3_tokenizer\0" as *const u8 as *const libc::c_char,
        b"load_extension\0" as *const u8 as *const libc::c_char,
        b"readfile\0" as *const u8 as *const libc::c_char,
        b"writefile\0" as *const u8 as *const libc::c_char,
        b"zipfile\0" as *const u8 as *const libc::c_char,
        b"zipfile_cds\0" as *const u8 as *const libc::c_char,
    ];
    match op {
        24 => {
            failIfSafeMode(
                p,
                b"cannot run ATTACH in safe mode\0" as *const u8 as *const libc::c_char,
            );
        }
        31 => {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::core::mem::size_of::<[*const libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int
            {
                if sqlite3_stricmp(zA2, azProhibitedFunctions[i as usize])
                    == 0 as libc::c_int
                {
                    failIfSafeMode(
                        p,
                        b"cannot use the %s() function in safe mode\0" as *const u8
                            as *const libc::c_char,
                        azProhibitedFunctions[i as usize],
                    );
                }
                i += 1;
                i;
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn shellAuth(
    pClientData: *mut libc::c_void,
    op: libc::c_int,
    zA1: *const libc::c_char,
    zA2: *const libc::c_char,
    zA3: *const libc::c_char,
    zA4: *const libc::c_char,
) -> libc::c_int {
    let p: *mut ShellState = pClientData as *mut ShellState;
    static mut azAction: [*const libc::c_char; 34] = [
        0 as *const libc::c_char,
        b"CREATE_INDEX\0" as *const u8 as *const libc::c_char,
        b"CREATE_TABLE\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_INDEX\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TABLE\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_VIEW\0" as *const u8 as *const libc::c_char,
        b"CREATE_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"CREATE_VIEW\0" as *const u8 as *const libc::c_char,
        b"DELETE\0" as *const u8 as *const libc::c_char,
        b"DROP_INDEX\0" as *const u8 as *const libc::c_char,
        b"DROP_TABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_INDEX\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_VIEW\0" as *const u8 as *const libc::c_char,
        b"DROP_TRIGGER\0" as *const u8 as *const libc::c_char,
        b"DROP_VIEW\0" as *const u8 as *const libc::c_char,
        b"INSERT\0" as *const u8 as *const libc::c_char,
        b"PRAGMA\0" as *const u8 as *const libc::c_char,
        b"READ\0" as *const u8 as *const libc::c_char,
        b"SELECT\0" as *const u8 as *const libc::c_char,
        b"TRANSACTION\0" as *const u8 as *const libc::c_char,
        b"UPDATE\0" as *const u8 as *const libc::c_char,
        b"ATTACH\0" as *const u8 as *const libc::c_char,
        b"DETACH\0" as *const u8 as *const libc::c_char,
        b"ALTER_TABLE\0" as *const u8 as *const libc::c_char,
        b"REINDEX\0" as *const u8 as *const libc::c_char,
        b"ANALYZE\0" as *const u8 as *const libc::c_char,
        b"CREATE_VTABLE\0" as *const u8 as *const libc::c_char,
        b"DROP_VTABLE\0" as *const u8 as *const libc::c_char,
        b"FUNCTION\0" as *const u8 as *const libc::c_char,
        b"SAVEPOINT\0" as *const u8 as *const libc::c_char,
        b"RECURSIVE\0" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let mut az: [*const libc::c_char; 4] = [0 as *const libc::c_char; 4];
    az[0 as libc::c_int as usize] = zA1;
    az[1 as libc::c_int as usize] = zA2;
    az[2 as libc::c_int as usize] = zA3;
    az[3 as libc::c_int as usize] = zA4;
    fprintf(
        (*p).out,
        b"authorizer: %s\0" as *const u8 as *const libc::c_char,
        azAction[op as usize],
    );
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        fprintf((*p).out, b" \0" as *const u8 as *const libc::c_char);
        if !(az[i as usize]).is_null() {
            output_c_string((*p).out, az[i as usize]);
        } else {
            fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
        }
        i += 1;
        i;
    }
    fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
    if (*p).bSafeMode != 0 {
        safeModeAuth(pClientData, op, zA1, zA2, zA3, zA4);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn printSchemaLine(
    out: *mut FILE,
    mut z: *const libc::c_char,
    zTail: *const libc::c_char,
) {
    let mut zToFree: *mut libc::c_char = 0 as *mut libc::c_char;
    if z.is_null() {
        return;
    }
    if zTail.is_null() {
        return;
    }
    if *zTail.offset(0 as libc::c_int as isize) as libc::c_int == ';' as i32
        && (!(strstr(z, b"/*\0" as *const u8 as *const libc::c_char)).is_null()
            || !(strstr(z, b"--\0" as *const u8 as *const libc::c_char)).is_null())
    {
        let zOrig: *const libc::c_char = z;
        static mut azTerm: [*const libc::c_char; 3] = [
            b"\0" as *const u8 as *const libc::c_char,
            b"*/\0" as *const u8 as *const libc::c_char,
            b"\n\0" as *const u8 as *const libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 3]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            let zNew: *mut libc::c_char = sqlite3_mprintf(
                b"%s%s;\0" as *const u8 as *const libc::c_char,
                zOrig,
                azTerm[i as usize],
            );
            shell_check_oom(zNew as *const libc::c_void);
            if sqlite3_complete(zNew) != 0 {
                let n: size_t = strlen(zNew);
                *zNew
                    .offset(
                        n.wrapping_sub(1 as libc::c_int as libc::c_ulong) as isize,
                    ) = 0 as libc::c_int as libc::c_char;
                zToFree = zNew;
                z = zNew;
                break;
            } else {
                sqlite3_free(zNew as *mut libc::c_void);
                i += 1;
                i;
            }
        }
    }
    if sqlite3_strglob(b"CREATE TABLE ['\"]*\0" as *const u8 as *const libc::c_char, z)
        == 0 as libc::c_int
    {
        fprintf(
            out,
            b"CREATE TABLE IF NOT EXISTS %s%s\0" as *const u8 as *const libc::c_char,
            z.offset(13 as libc::c_int as isize),
            zTail,
        );
    } else {
        fprintf(out, b"%s%s\0" as *const u8 as *const libc::c_char, z, zTail);
    }
    sqlite3_free(zToFree as *mut libc::c_void);
}
unsafe extern "C" fn printSchemaLineN(
    out: *mut FILE,
    z: *mut libc::c_char,
    n: libc::c_int,
    zTail: *const libc::c_char,
) {
    let c: libc::c_char = *z.offset(n as isize);
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
    printSchemaLine(out, z, zTail);
    *z.offset(n as isize) = c;
}
unsafe extern "C" fn wsToEol(z: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while *z.offset(i as isize) != 0 {
        if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
            return 1 as libc::c_int;
        }
        if *(*__ctype_b_loc())
            .offset(*z.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            i += 1;
            i;
        } else {
            if *z.offset(i as isize) as libc::c_int == '-' as i32
                && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    == '-' as i32
            {
                return 1 as libc::c_int;
            }
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
unsafe extern "C" fn eqp_append(
    p: *mut ShellState,
    iEqpId: libc::c_int,
    p2: libc::c_int,
    zText: *const libc::c_char,
) {
    let mut pNew: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut nText: i64_0 = 0;
    if zText.is_null() {
        return;
    }
    nText = strlen(zText) as i64_0;
    if (*p).autoEQPtest != 0 {
        fprintf(
            (*p).out,
            b"%d,%d,%s\n\0" as *const u8 as *const libc::c_char,
            iEqpId,
            p2,
            zText,
        );
    }
    pNew = sqlite3_malloc64(
        (::core::mem::size_of::<EQPGraphRow>() as libc::c_ulong as libc::c_ulonglong)
            .wrapping_add(nText as libc::c_ulonglong),
    ) as *mut EQPGraphRow;
    shell_check_oom(pNew as *const libc::c_void);
    (*pNew).iEqpId = iEqpId;
    (*pNew).iParentId = p2;
    memcpy(
        ((*pNew).zText).as_mut_ptr() as *mut libc::c_void,
        zText as *const libc::c_void,
        (nText + 1 as libc::c_int as libc::c_longlong) as libc::c_ulong,
    );
    (*pNew).pNext = 0 as *mut EQPGraphRow;
    if !((*p).sGraph.pLast).is_null() {
        (*(*p).sGraph.pLast).pNext = pNew;
    } else {
        (*p).sGraph.pRow = pNew;
    }
    (*p).sGraph.pLast = pNew;
}
unsafe extern "C" fn eqp_reset(p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    pRow = (*p).sGraph.pRow;
    while !pRow.is_null() {
        pNext = (*pRow).pNext;
        sqlite3_free(pRow as *mut libc::c_void);
        pRow = pNext;
    }
    memset(
        &mut (*p).sGraph as *mut EQPGraph as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<EQPGraph>() as libc::c_ulong,
    );
}
unsafe extern "C" fn eqp_next_row(
    p: *mut ShellState,
    iEqpId: libc::c_int,
    pOld: *mut EQPGraphRow,
) -> *mut EQPGraphRow {
    let mut pRow: *mut EQPGraphRow = if !pOld.is_null() {
        (*pOld).pNext
    } else {
        (*p).sGraph.pRow
    };
    while !pRow.is_null() && (*pRow).iParentId != iEqpId {
        pRow = (*pRow).pNext;
    }
    return pRow;
}
unsafe extern "C" fn eqp_render_level(p: *mut ShellState, iEqpId: libc::c_int) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let n: i64_0 = strlen(((*p).sGraph.zPrefix).as_mut_ptr()) as i64_0;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    pRow = eqp_next_row(p, iEqpId, 0 as *mut EQPGraphRow);
    while !pRow.is_null() {
        pNext = eqp_next_row(p, iEqpId, pRow);
        z = ((*pRow).zText).as_mut_ptr();
        fprintf(
            (*p).out,
            b"%s%s%s\n\0" as *const u8 as *const libc::c_char,
            ((*p).sGraph.zPrefix).as_mut_ptr(),
            if !pNext.is_null() {
                b"|--\0" as *const u8 as *const libc::c_char
            } else {
                b"`--\0" as *const u8 as *const libc::c_char
            },
            z,
        );
        if n
            < ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as i64_0
                - 7 as libc::c_int as libc::c_longlong
        {
            memcpy(
                &mut *((*p).sGraph.zPrefix).as_mut_ptr().offset(n as isize)
                    as *mut libc::c_char as *mut libc::c_void,
                (if !pNext.is_null() {
                    b"|  \0" as *const u8 as *const libc::c_char
                } else {
                    b"   \0" as *const u8 as *const libc::c_char
                }) as *const libc::c_void,
                4 as libc::c_int as libc::c_ulong,
            );
            eqp_render_level(p, (*pRow).iEqpId);
            (*p).sGraph.zPrefix[n as usize] = 0 as libc::c_int as libc::c_char;
        }
        pRow = pNext;
    }
}
unsafe extern "C" fn eqp_render(p: *mut ShellState, nCycle: i64_0) {
    let pRow: *mut EQPGraphRow = (*p).sGraph.pRow;
    if !pRow.is_null() {
        if *((*pRow).zText).as_mut_ptr().offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
        {
            if ((*pRow).pNext).is_null() {
                eqp_reset(p);
                return;
            }
            fprintf(
                (*p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                ((*pRow).zText).as_mut_ptr().offset(3 as libc::c_int as isize),
            );
            (*p).sGraph.pRow = (*pRow).pNext;
            sqlite3_free(pRow as *mut libc::c_void);
        } else if nCycle > 0 as libc::c_int as libc::c_longlong {
            fprintf(
                (*p).out,
                b"QUERY PLAN (cycles=%lld [100%%])\n\0" as *const u8
                    as *const libc::c_char,
                nCycle,
            );
        } else {
            fprintf((*p).out, b"QUERY PLAN\n\0" as *const u8 as *const libc::c_char);
        }
        (*p)
            .sGraph
            .zPrefix[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        eqp_render_level(p, 0 as libc::c_int);
        eqp_reset(p);
    }
}
unsafe extern "C" fn progress_handler(
    pClientData: *mut libc::c_void,
) -> libc::c_int {
    let p: *mut ShellState = pClientData as *mut ShellState;
    (*p).nProgress = ((*p).nProgress).wrapping_add(1);
    (*p).nProgress;
    if (*p).nProgress >= (*p).mxProgress
        && (*p).mxProgress > 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            (*p).out,
            b"Progress limit reached (%u)\n\0" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
        if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
            (*p).nProgress = 0 as libc::c_int as libc::c_uint;
        }
        if (*p).flgProgress & 0x4 as libc::c_int as libc::c_uint != 0 {
            (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
        }
        return 1 as libc::c_int;
    }
    if (*p).flgProgress & 0x1 as libc::c_int as libc::c_uint
        == 0 as libc::c_int as libc::c_uint
    {
        fprintf(
            (*p).out,
            b"Progress %u\n\0" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn print_dashes(out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 51] = *::core::mem::transmute::<
        &[u8; 51],
        &[libc::c_char; 51],
    >(b"--------------------------------------------------\0");
    let nDash: libc::c_int = (::core::mem::size_of::<[libc::c_char; 51]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    while N > nDash {
        fputs(zDash.as_ptr(), out);
        N -= nDash;
    }
    fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, N, zDash.as_ptr());
}
unsafe extern "C" fn print_row_separator(
    p: *mut ShellState,
    nArg: libc::c_int,
    zSep: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fputs(zSep, (*p).out);
        print_dashes(
            (*p).out,
            *((*p).actualWidth).offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fputs(zSep, (*p).out);
            print_dashes(
                (*p).out,
                *((*p).actualWidth).offset(i as isize) + 2 as libc::c_int,
            );
            i += 1;
            i;
        }
        fputs(zSep, (*p).out);
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, (*p).out);
}
unsafe extern "C" fn shell_callback(
    pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    azArg: *mut *mut libc::c_char,
    azCol: *mut *mut libc::c_char,
    aiType: *mut libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let p: *mut ShellState = pArg as *mut ShellState;
    if azArg.is_null() {
        return 0 as libc::c_int;
    }
    match (*p).cMode {
        0 => {
            let mut w: libc::c_int = 5 as libc::c_int;
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let len: libc::c_int = strlen30(
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if len > w {
                        w = len;
                    }
                    i += 1;
                    i;
                }
                let fresh70 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh70 > 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        ((*p).rowSeparator).as_mut_ptr(),
                    );
                }
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        b"%*s = %s%s\0" as *const u8 as *const libc::c_char,
                        w,
                        *azCol.offset(i as isize),
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                        ((*p).rowSeparator).as_mut_ptr(),
                    );
                    i += 1;
                    i;
                }
            }
        }
        19 | 9 => {
            static mut aExplainWidth: [libc::c_int; 8] = [
                4 as libc::c_int,
                13 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                13 as libc::c_int,
                2 as libc::c_int,
                13 as libc::c_int,
            ];
            static mut aExplainMap: [libc::c_int; 8] = [
                0 as libc::c_int,
                1 as libc::c_int,
                2 as libc::c_int,
                3 as libc::c_int,
                4 as libc::c_int,
                5 as libc::c_int,
                6 as libc::c_int,
                7 as libc::c_int,
            ];
            static mut aScanExpWidth: [libc::c_int; 10] = [
                4 as libc::c_int,
                6 as libc::c_int,
                6 as libc::c_int,
                13 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                4 as libc::c_int,
                13 as libc::c_int,
                2 as libc::c_int,
                13 as libc::c_int,
            ];
            static mut aScanExpMap: [libc::c_int; 10] = [
                0 as libc::c_int,
                9 as libc::c_int,
                8 as libc::c_int,
                1 as libc::c_int,
                2 as libc::c_int,
                3 as libc::c_int,
                4 as libc::c_int,
                5 as libc::c_int,
                6 as libc::c_int,
                7 as libc::c_int,
            ];
            let mut aWidth: *const libc::c_int = aExplainWidth.as_ptr();
            let mut aMap: *const libc::c_int = aExplainMap.as_ptr();
            let mut nWidth: libc::c_int = (::core::mem::size_of::<[libc::c_int; 8]>()
                as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                as libc::c_int;
            let mut iIndent: libc::c_int = 1 as libc::c_int;
            if (*p).cMode == 19 as libc::c_int {
                aWidth = aScanExpWidth.as_ptr();
                aMap = aScanExpMap.as_ptr();
                nWidth = (::core::mem::size_of::<[libc::c_int; 10]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as libc::c_int;
                iIndent = 3 as libc::c_int;
            }
            if nArg > nWidth {
                nArg = nWidth;
            }
            let fresh71 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh71 == 0 as libc::c_int {
                i = 0 as libc::c_int;
                while i < nArg {
                    utf8_width_print(
                        (*p).out,
                        *aWidth.offset(i as isize),
                        *azCol.offset(*aMap.offset(i as isize) as isize),
                    );
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                    i;
                }
                i = 0 as libc::c_int;
                while i < nArg {
                    print_dashes((*p).out, *aWidth.offset(i as isize));
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        },
                        (*p).out,
                    );
                    i += 1;
                    i;
                }
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut zSep: *const libc::c_char = b"  \0" as *const u8
                        as *const libc::c_char;
                    let mut w_0: libc::c_int = *aWidth.offset(i as isize);
                    let zVal: *const libc::c_char = *azArg
                        .offset(*aMap.offset(i as isize) as isize);
                    if i == nArg - 1 as libc::c_int {
                        w_0 = 0 as libc::c_int;
                    }
                    if !zVal.is_null() && strlenChar(zVal) > w_0 {
                        w_0 = strlenChar(zVal);
                        zSep = b" \0" as *const u8 as *const libc::c_char;
                    }
                    if i == iIndent && !((*p).aiIndent).is_null()
                        && !((*p).pStmt).is_null()
                    {
                        if (*p).iIndent < (*p).nIndent {
                            fprintf(
                                (*p).out,
                                b"%*.s\0" as *const u8 as *const libc::c_char,
                                *((*p).aiIndent).offset((*p).iIndent as isize),
                                b"\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        (*p).iIndent += 1;
                        (*p).iIndent;
                    }
                    utf8_width_print(
                        (*p).out,
                        w_0,
                        if !zVal.is_null() {
                            zVal
                        } else {
                            ((*p).nullValue).as_mut_ptr() as *const libc::c_char
                        },
                    );
                    fputs(
                        if i == nArg - 1 as libc::c_int {
                            b"\n\0" as *const u8 as *const libc::c_char
                        } else {
                            zSep
                        },
                        (*p).out,
                    );
                    i += 1;
                    i;
                }
            }
        }
        3 => {
            printSchemaLine(
                (*p).out,
                *azArg.offset(0 as libc::c_int as isize),
                b";\n\0" as *const u8 as *const libc::c_char,
            );
        }
        11 => {
            let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut j: libc::c_int = 0;
            let mut nParen: libc::c_int = 0 as libc::c_int;
            let mut cEnd: libc::c_char = 0 as libc::c_int as libc::c_char;
            let mut c: libc::c_char = 0;
            let mut nLine: libc::c_int = 0 as libc::c_int;
            if nArg == 1 as libc::c_int {} else {
                __assert_fail(
                    b"nArg==1\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    18373 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 57],
                        &[libc::c_char; 57],
                    >(b"int shell_callback(void *, int, char **, char **, int *)\0"))
                        .as_ptr(),
                );
            }
            'c_85790: {
                if nArg == 1 as libc::c_int {} else {
                    __assert_fail(
                        b"nArg==1\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        18373 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 57],
                            &[libc::c_char; 57],
                        >(b"int shell_callback(void *, int, char **, char **, int *)\0"))
                            .as_ptr(),
                    );
                }
            };
            if !(*azArg.offset(0 as libc::c_int as isize)).is_null() {
                if sqlite3_strlike(
                    b"CREATE VIEW%\0" as *const u8 as *const libc::c_char,
                    *azArg.offset(0 as libc::c_int as isize),
                    0 as libc::c_int as libc::c_uint,
                ) == 0 as libc::c_int
                    || sqlite3_strlike(
                        b"CREATE TRIG%\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                        0 as libc::c_int as libc::c_uint,
                    ) == 0 as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"%s;\n\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                    );
                } else {
                    z = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                    );
                    shell_check_oom(z as *const libc::c_void);
                    j = 0 as libc::c_int;
                    i = 0 as libc::c_int;
                    while *(*__ctype_b_loc())
                        .offset(
                            *z.offset(i as isize) as libc::c_uchar as libc::c_int
                                as isize,
                        ) as libc::c_int
                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                    {
                        i += 1;
                        i;
                    }
                    let mut current_block_64: u64;
                    loop {
                        c = *z.offset(i as isize);
                        if !(c as libc::c_int != 0 as libc::c_int) {
                            break;
                        }
                        if *(*__ctype_b_loc())
                            .offset(c as libc::c_uchar as libc::c_int as isize)
                            as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                        {
                            if *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                == '\r' as i32
                            {
                                *z
                                    .offset(
                                        (j - 1 as libc::c_int) as isize,
                                    ) = '\n' as i32 as libc::c_char;
                            }
                            if *(*__ctype_b_loc())
                                .offset(
                                    *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                        as libc::c_int as isize,
                                ) as libc::c_int
                                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                != 0
                                || *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                    == '(' as i32
                            {
                                current_block_64 = 7494008139977416618;
                            } else {
                                current_block_64 = 7158658067966855297;
                            }
                        } else {
                            if (c as libc::c_int == '(' as i32
                                || c as libc::c_int == ')' as i32) && j > 0 as libc::c_int
                                && *(*__ctype_b_loc())
                                    .offset(
                                        *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int as isize,
                                    ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                            {
                                j -= 1;
                                j;
                            }
                            current_block_64 = 7158658067966855297;
                        }
                        match current_block_64 {
                            7158658067966855297 => {
                                let fresh72 = j;
                                j = j + 1;
                                *z.offset(fresh72 as isize) = c;
                            }
                            _ => {}
                        }
                        i += 1;
                        i;
                    }
                    while j > 0 as libc::c_int
                        && *(*__ctype_b_loc())
                            .offset(
                                *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                    as libc::c_int as isize,
                            ) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        j -= 1;
                        j;
                    }
                    *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                    if strlen30(z) >= 79 as libc::c_int {
                        j = 0 as libc::c_int;
                        i = j;
                        loop {
                            c = *z.offset(i as isize);
                            if !(c as libc::c_int != 0 as libc::c_int) {
                                break;
                            }
                            if c as libc::c_int == cEnd as libc::c_int {
                                cEnd = 0 as libc::c_int as libc::c_char;
                            } else if c as libc::c_int == '"' as i32
                                || c as libc::c_int == '\'' as i32
                                || c as libc::c_int == '`' as i32
                            {
                                cEnd = c;
                            } else if c as libc::c_int == '[' as i32 {
                                cEnd = ']' as i32 as libc::c_char;
                            } else if c as libc::c_int == '-' as i32
                                && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                                    == '-' as i32
                            {
                                cEnd = '\n' as i32 as libc::c_char;
                            } else if c as libc::c_int == '(' as i32 {
                                nParen += 1;
                                nParen;
                            } else if c as libc::c_int == ')' as i32 {
                                nParen -= 1;
                                nParen;
                                if nLine > 0 as libc::c_int && nParen == 0 as libc::c_int
                                    && j > 0 as libc::c_int
                                {
                                    printSchemaLineN(
                                        (*p).out,
                                        z,
                                        j,
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                    j = 0 as libc::c_int;
                                }
                            }
                            let fresh73 = j;
                            j = j + 1;
                            *z.offset(fresh73 as isize) = c;
                            if nParen == 1 as libc::c_int
                                && cEnd as libc::c_int == 0 as libc::c_int
                                && (c as libc::c_int == '(' as i32
                                    || c as libc::c_int == '\n' as i32
                                    || c as libc::c_int == ',' as i32
                                        && wsToEol(
                                            z.offset(i as isize).offset(1 as libc::c_int as isize),
                                        ) == 0)
                            {
                                if c as libc::c_int == '\n' as i32 {
                                    j -= 1;
                                    j;
                                }
                                printSchemaLineN(
                                    (*p).out,
                                    z,
                                    j,
                                    b"\n  \0" as *const u8 as *const libc::c_char,
                                );
                                j = 0 as libc::c_int;
                                nLine += 1;
                                nLine;
                                while *(*__ctype_b_loc())
                                    .offset(
                                        *z.offset((i + 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int as isize,
                                    ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                                {
                                    i += 1;
                                    i;
                                }
                            }
                            i += 1;
                            i;
                        }
                        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                    }
                    printSchemaLine(
                        (*p).out,
                        z,
                        b";\n\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_free(z as *mut libc::c_void);
                }
            }
        }
        2 => {
            let fresh74 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh74 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        b"%s%s\0" as *const u8 as *const libc::c_char,
                        *azCol.offset(i as isize),
                        if i == nArg - 1 as libc::c_int {
                            ((*p).rowSeparator).as_mut_ptr()
                        } else {
                            ((*p).colSeparator).as_mut_ptr()
                        },
                    );
                    i += 1;
                    i;
                }
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    let mut z_0: *mut libc::c_char = *azArg.offset(i as isize);
                    if z_0.is_null() {
                        z_0 = ((*p).nullValue).as_mut_ptr();
                    }
                    fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, z_0);
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).rowSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                    i;
                }
            }
        }
        4 => {
            let fresh75 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh75 == 0 as libc::c_int && (*p).showHeader != 0 {
                fprintf((*p).out, b"<TR>\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf((*p).out, b"<TH>\0" as *const u8 as *const libc::c_char);
                    output_html_string((*p).out, *azCol.offset(i as isize));
                    fprintf((*p).out, b"</TH>\n\0" as *const u8 as *const libc::c_char);
                    i += 1;
                    i;
                }
                fprintf((*p).out, b"</TR>\n\0" as *const u8 as *const libc::c_char);
            }
            if !azArg.is_null() {
                fprintf((*p).out, b"<TR>\0" as *const u8 as *const libc::c_char);
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf((*p).out, b"<TD>\0" as *const u8 as *const libc::c_char);
                    output_html_string(
                        (*p).out,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    fprintf((*p).out, b"</TD>\n\0" as *const u8 as *const libc::c_char);
                    i += 1;
                    i;
                }
                fprintf((*p).out, b"</TR>\n\0" as *const u8 as *const libc::c_char);
            }
        }
        7 => {
            let fresh76 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh76 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_c_string(
                        (*p).out,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                    i;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_c_string(
                        (*p).out,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    if i < nArg - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    i += 1;
                    i;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        8 => {
            let fresh77 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh77 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_csv(
                        p,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                        (i < nArg - 1 as libc::c_int) as libc::c_int,
                    );
                    i += 1;
                    i;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if nArg > 0 as libc::c_int {
                i = 0 as libc::c_int;
                while i < nArg {
                    output_csv(
                        p,
                        *azArg.offset(i as isize),
                        (i < nArg - 1 as libc::c_int) as libc::c_int,
                    );
                    i += 1;
                    i;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        5 => {
            if !azArg.is_null() {
                fprintf(
                    (*p).out,
                    b"INSERT INTO %s\0" as *const u8 as *const libc::c_char,
                    (*p).zDestTable,
                );
                if (*p).showHeader != 0 {
                    fprintf((*p).out, b"(\0" as *const u8 as *const libc::c_char);
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b",\0" as *const u8 as *const libc::c_char,
                            );
                        }
                        if quoteChar(*azCol.offset(i as isize)) != 0 {
                            let z_1: *mut libc::c_char = sqlite3_mprintf(
                                b"\"%w\"\0" as *const u8 as *const libc::c_char,
                                *azCol.offset(i as isize),
                            );
                            shell_check_oom(z_1 as *const libc::c_void);
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_1,
                            );
                            sqlite3_free(z_1 as *mut libc::c_void);
                        } else {
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                *azCol.offset(i as isize),
                            );
                        }
                        i += 1;
                        i;
                    }
                    fprintf((*p).out, b")\0" as *const u8 as *const libc::c_char);
                }
                (*p).cnt += 1;
                (*p).cnt;
                i = 0 as libc::c_int;
                while i < nArg {
                    fprintf(
                        (*p).out,
                        if i > 0 as libc::c_int {
                            b",\0" as *const u8 as *const libc::c_char
                        } else {
                            b" VALUES(\0" as *const u8 as *const libc::c_char
                        },
                    );
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            output_quoted_string((*p).out, *azArg.offset(i as isize));
                        } else {
                            output_quoted_escaped_string(
                                (*p).out,
                                *azArg.offset(i as isize),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 1 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_2: [libc::c_char; 50] = [0; 50];
                        let mut r: libc::c_double = sqlite3_column_double((*p).pStmt, i);
                        let mut ur: sqlite3_uint64 = 0;
                        memcpy(
                            &mut ur as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r as *mut libc::c_double as *const libc::c_void,
                            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
                        );
                        if ur
                            == 0x7ff0000000000000 as libc::c_longlong
                                as libc::c_ulonglong
                        {
                            fprintf(
                                (*p).out,
                                b"9.0e+999\0" as *const u8 as *const libc::c_char,
                            );
                        } else if ur == 0xfff0000000000000 as libc::c_ulonglong {
                            fprintf(
                                (*p).out,
                                b"-9.0e+999\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            let ir: sqlite3_int64 = r as sqlite3_int64;
                            if r == ir as libc::c_double {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%lld.0\0" as *const u8 as *const libc::c_char,
                                    ir,
                                );
                            } else {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%!.20g\0" as *const u8 as *const libc::c_char,
                                    r,
                                );
                            }
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_2.as_mut_ptr(),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let pBlob: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let nBlob: libc::c_int = sqlite3_column_bytes((*p).pStmt, i);
                        output_hex_blob((*p).out, pBlob, nBlob);
                    } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int)
                        != 0
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    } else {
                        output_quoted_escaped_string(
                            (*p).out,
                            *azArg.offset(i as isize),
                        );
                    }
                    i += 1;
                    i;
                }
                fprintf((*p).out, b");\n\0" as *const u8 as *const libc::c_char);
            }
        }
        13 => {
            if !azArg.is_null() {
                if (*p).cnt == 0 as libc::c_int {
                    fputs(b"[{\0" as *const u8 as *const libc::c_char, (*p).out);
                } else {
                    fputs(b",\n{\0" as *const u8 as *const libc::c_char, (*p).out);
                }
                (*p).cnt += 1;
                (*p).cnt;
                i = 0 as libc::c_int;
                while i < nArg {
                    output_json_string(
                        (*p).out,
                        *azCol.offset(i as isize),
                        -(1 as libc::c_int) as i64_0,
                    );
                    _IO_putc(':' as i32, (*p).out);
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fputs(b"null\0" as *const u8 as *const libc::c_char, (*p).out);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_3: [libc::c_char; 50] = [0; 50];
                        let mut r_0: libc::c_double = sqlite3_column_double(
                            (*p).pStmt,
                            i,
                        );
                        let mut ur_0: sqlite3_uint64 = 0;
                        memcpy(
                            &mut ur_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                            &mut r_0 as *mut libc::c_double as *const libc::c_void,
                            ::core::mem::size_of::<libc::c_double>() as libc::c_ulong,
                        );
                        if ur_0
                            == 0x7ff0000000000000 as libc::c_longlong
                                as libc::c_ulonglong
                        {
                            fprintf(
                                (*p).out,
                                b"9.0e+999\0" as *const u8 as *const libc::c_char,
                            );
                        } else if ur_0 == 0xfff0000000000000 as libc::c_ulonglong {
                            fprintf(
                                (*p).out,
                                b"-9.0e+999\0" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            sqlite3_snprintf(
                                50 as libc::c_int,
                                z_3.as_mut_ptr(),
                                b"%!.20g\0" as *const u8 as *const libc::c_char,
                                r_0,
                            );
                            fprintf(
                                (*p).out,
                                b"%s\0" as *const u8 as *const libc::c_char,
                                z_3.as_mut_ptr(),
                            );
                        }
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let pBlob_0: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let nBlob_0: libc::c_int = sqlite3_column_bytes(
                            (*p).pStmt,
                            i,
                        );
                        output_json_string(
                            (*p).out,
                            pBlob_0 as *const libc::c_char,
                            nBlob_0 as i64_0,
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        output_json_string(
                            (*p).out,
                            *azArg.offset(i as isize),
                            -(1 as libc::c_int) as i64_0,
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    }
                    if i < nArg - 1 as libc::c_int {
                        _IO_putc(',' as i32, (*p).out);
                    }
                    i += 1;
                    i;
                }
                _IO_putc('}' as i32, (*p).out);
            }
        }
        6 => {
            if !azArg.is_null() {
                if (*p).cnt == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fputs(((*p).colSeparator).as_mut_ptr(), (*p).out);
                        }
                        output_quoted_string((*p).out, *azCol.offset(i as isize));
                        i += 1;
                        i;
                    }
                    fputs(((*p).rowSeparator).as_mut_ptr(), (*p).out);
                }
                (*p).cnt += 1;
                (*p).cnt;
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fputs(((*p).colSeparator).as_mut_ptr(), (*p).out);
                    }
                    if (*azArg.offset(i as isize)).is_null()
                        || !aiType.is_null()
                            && *aiType.offset(i as isize) == 5 as libc::c_int
                    {
                        fprintf((*p).out, b"NULL\0" as *const u8 as *const libc::c_char);
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 3 as libc::c_int
                    {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 1 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 2 as libc::c_int
                    {
                        let mut z_4: [libc::c_char; 50] = [0; 50];
                        let r_1: libc::c_double = sqlite3_column_double(
                            (*p).pStmt,
                            i,
                        );
                        sqlite3_snprintf(
                            50 as libc::c_int,
                            z_4.as_mut_ptr(),
                            b"%!.20g\0" as *const u8 as *const libc::c_char,
                            r_1,
                        );
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            z_4.as_mut_ptr(),
                        );
                    } else if !aiType.is_null()
                        && *aiType.offset(i as isize) == 4 as libc::c_int
                        && !((*p).pStmt).is_null()
                    {
                        let pBlob_1: *const libc::c_void = sqlite3_column_blob(
                            (*p).pStmt,
                            i,
                        );
                        let nBlob_1: libc::c_int = sqlite3_column_bytes(
                            (*p).pStmt,
                            i,
                        );
                        output_hex_blob((*p).out, pBlob_1, nBlob_1);
                    } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int)
                        != 0
                    {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            *azArg.offset(i as isize),
                        );
                    } else {
                        output_quoted_string((*p).out, *azArg.offset(i as isize));
                    }
                    i += 1;
                    i;
                }
                fputs(((*p).rowSeparator).as_mut_ptr(), (*p).out);
            }
        }
        10 => {
            let fresh78 = (*p).cnt;
            (*p).cnt = (*p).cnt + 1;
            if fresh78 == 0 as libc::c_int && (*p).showHeader != 0 {
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if !(*azCol.offset(i as isize)).is_null() {
                            *azCol.offset(i as isize) as *const libc::c_char
                        } else {
                            b"\0" as *const u8 as *const libc::c_char
                        },
                    );
                    i += 1;
                    i;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
            if !azArg.is_null() {
                i = 0 as libc::c_int;
                while i < nArg {
                    if i > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\0" as *const u8 as *const libc::c_char,
                            ((*p).colSeparator).as_mut_ptr(),
                        );
                    }
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if !(*azArg.offset(i as isize)).is_null() {
                            *azArg.offset(i as isize)
                        } else {
                            ((*p).nullValue).as_mut_ptr()
                        },
                    );
                    i += 1;
                    i;
                }
                fprintf(
                    (*p).out,
                    b"%s\0" as *const u8 as *const libc::c_char,
                    ((*p).rowSeparator).as_mut_ptr(),
                );
            }
        }
        12 => {
            eqp_append(
                p,
                atoi(*azArg.offset(0 as libc::c_int as isize)),
                atoi(*azArg.offset(1 as libc::c_int as isize)),
                *azArg.offset(3 as libc::c_int as isize),
            );
        }
        17 | 18 | _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn callback(
    pArg: *mut libc::c_void,
    nArg: libc::c_int,
    azArg: *mut *mut libc::c_char,
    azCol: *mut *mut libc::c_char,
) -> libc::c_int {
    return shell_callback(pArg, nArg, azArg, azCol, 0 as *mut libc::c_int);
}
unsafe extern "C" fn captureOutputCallback(
    pArg: *mut libc::c_void,
    nArg: libc::c_int,
    azArg: *mut *mut libc::c_char,
    _az: *mut *mut libc::c_char,
) -> libc::c_int {
    let p: *mut ShellText = pArg as *mut ShellText;
    let mut i: libc::c_int = 0;
    if azArg.is_null() {
        return 0 as libc::c_int;
    }
    if (*p).n != 0 {
        appendText(
            p,
            b"|\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    i = 0 as libc::c_int;
    while i < nArg {
        if i != 0 {
            appendText(
                p,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        if !(*azArg.offset(i as isize)).is_null() {
            appendText(p, *azArg.offset(i as isize), 0 as libc::c_int as libc::c_char);
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn createSelftestTable(p: *mut ShellState) {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    sqlite3_exec(
        (*p).db,
        b"SAVEPOINT selftest_init;\nCREATE TABLE IF NOT EXISTS selftest(\n  tno INTEGER PRIMARY KEY,\n  op TEXT,\n  cmd TEXT,\n  ans TEXT\n);CREATE TEMP TABLE [_shell$self](op,cmd,ans);\nINSERT INTO [_shell$self](rowid,op,cmd)\n  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n         'memo','Tests generated by --init');\nINSERT INTO [_shell$self]\n  SELECT 'run',\n    'SELECT hex(sha3_query(''SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2'',224))',\n    hex(sha3_query('SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2',224));\nINSERT INTO [_shell$self]\n  SELECT 'run',    'SELECT hex(sha3_query(''SELECT * FROM \"' ||        printf('%w',name) || '\" NOT INDEXED'',224))',\n    hex(sha3_query(printf('SELECT * FROM \"%w\" NOT INDEXED',name),224))\n  FROM (\n    SELECT name FROM sqlite_schema\n     WHERE type='table'\n       AND name<>'selftest'\n       AND coalesce(rootpage,0)>0\n  )\n ORDER BY name;\nINSERT INTO [_shell$self]\n  VALUES('run','PRAGMA integrity_check','ok');\nINSERT INTO selftest(tno,op,cmd,ans)  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\nDROP TABLE [_shell$self];\0"
            as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        &mut zErrMsg,
    );
    if !zErrMsg.is_null() {
        fprintf(
            stderr,
            b"SELFTEST initialization failure: %s\n\0" as *const u8
                as *const libc::c_char,
            zErrMsg,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
    }
    sqlite3_exec(
        (*p).db,
        b"RELEASE selftest_init\0" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
unsafe extern "C" fn set_table_name(
    p: *mut ShellState,
    zName: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut cQuote: libc::c_char = 0;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    if !((*p).zDestTable).is_null() {
        free((*p).zDestTable as *mut libc::c_void);
        (*p).zDestTable = 0 as *mut libc::c_char;
    }
    if zName.is_null() {
        return;
    }
    cQuote = quoteChar(zName);
    n = strlen30(zName);
    if cQuote != 0 {
        n += n + 2 as libc::c_int;
    }
    (*p)
        .zDestTable = malloc((n + 1 as libc::c_int) as libc::c_ulong)
        as *mut libc::c_char;
    z = (*p).zDestTable;
    shell_check_oom(z as *const libc::c_void);
    n = 0 as libc::c_int;
    if cQuote != 0 {
        let fresh79 = n;
        n = n + 1;
        *z.offset(fresh79 as isize) = cQuote;
    }
    i = 0 as libc::c_int;
    while *zName.offset(i as isize) != 0 {
        let fresh80 = n;
        n = n + 1;
        *z.offset(fresh80 as isize) = *zName.offset(i as isize);
        if *zName.offset(i as isize) as libc::c_int == cQuote as libc::c_int {
            let fresh81 = n;
            n = n + 1;
            *z.offset(fresh81 as isize) = cQuote;
        }
        i += 1;
        i;
    }
    if cQuote != 0 {
        let fresh82 = n;
        n = n + 1;
        *z.offset(fresh82 as isize) = cQuote;
    }
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
}
unsafe extern "C" fn shell_error_context(
    mut zSql: *const libc::c_char,
    db: *mut sqlite3,
) -> *mut libc::c_char {
    let mut iOffset: libc::c_int = 0;
    let mut len: size_t = 0;
    let mut zCode: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    if db.is_null() || zSql.is_null()
        || {
            iOffset = sqlite3_error_offset(db);
            iOffset < 0 as libc::c_int
        } || iOffset >= strlen(zSql) as libc::c_int
    {
        return sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
    }
    while iOffset > 50 as libc::c_int {
        iOffset -= 1;
        iOffset;
        zSql = zSql.offset(1);
        zSql;
        while *zSql.offset(0 as libc::c_int as isize) as libc::c_int
            & 0xc0 as libc::c_int == 0x80 as libc::c_int
        {
            zSql = zSql.offset(1);
            zSql;
            iOffset -= 1;
            iOffset;
        }
    }
    len = strlen(zSql);
    if len > 78 as libc::c_int as libc::c_ulong {
        len = 78 as libc::c_int as size_t;
        while len > 0 as libc::c_int as libc::c_ulong
            && *zSql.offset(len as isize) as libc::c_int & 0xc0 as libc::c_int
                == 0x80 as libc::c_int
        {
            len = len.wrapping_sub(1);
            len;
        }
    }
    zCode = sqlite3_mprintf(b"%.*s\0" as *const u8 as *const libc::c_char, len, zSql);
    shell_check_oom(zCode as *const libc::c_void);
    i = 0 as libc::c_int;
    while *zCode.offset(i as isize) != 0 {
        if *(*__ctype_b_loc())
            .offset(*zSql.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            *zCode.offset(i as isize) = ' ' as i32 as libc::c_char;
        }
        i += 1;
        i;
    }
    if iOffset < 25 as libc::c_int {
        zMsg = sqlite3_mprintf(
            b"\n  %z\n  %*s^--- error here\0" as *const u8 as *const libc::c_char,
            zCode,
            iOffset,
            b"\0" as *const u8 as *const libc::c_char,
        );
    } else {
        zMsg = sqlite3_mprintf(
            b"\n  %z\n  %*serror here ---^\0" as *const u8 as *const libc::c_char,
            zCode,
            iOffset - 14 as libc::c_int,
            b"\0" as *const u8 as *const libc::c_char,
        );
    }
    return zMsg;
}
unsafe extern "C" fn run_table_dump_query(
    p: *mut ShellState,
    zSelect: *const libc::c_char,
) -> libc::c_int {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    let mut nResult: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSelect,
        -(1 as libc::c_int),
        &mut pSelect,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int || pSelect.is_null() {
        let zContext: *mut libc::c_char = shell_error_context(zSelect, (*p).db);
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n%s\0" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
            zContext,
        );
        sqlite3_free(zContext as *mut libc::c_void);
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            (*p).nErr += 1;
            (*p).nErr;
        }
        return rc;
    }
    rc = sqlite3_step(pSelect);
    nResult = sqlite3_column_count(pSelect);
    while rc == 100 as libc::c_int {
        z = sqlite3_column_text(pSelect, 0 as libc::c_int) as *const libc::c_char;
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, z);
        i = 1 as libc::c_int;
        while i < nResult {
            fprintf(
                (*p).out,
                b",%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pSelect, i),
            );
            i += 1;
            i;
        }
        if z.is_null() {
            z = b"\0" as *const u8 as *const libc::c_char;
        }
        while *z.offset(0 as libc::c_int as isize) as libc::c_int != 0
            && (*z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
                || *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32)
        {
            z = z.offset(1);
            z;
        }
        if *z.offset(0 as libc::c_int as isize) != 0 {
            fprintf((*p).out, b"\n;\n\0" as *const u8 as *const libc::c_char);
        } else {
            fprintf((*p).out, b";\n\0" as *const u8 as *const libc::c_char);
        }
        rc = sqlite3_step(pSelect);
    }
    rc = sqlite3_finalize(pSelect);
    if rc != 0 as libc::c_int {
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n\0" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
        );
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            (*p).nErr += 1;
            (*p).nErr;
        }
    }
    return rc;
}
unsafe extern "C" fn save_err_msg(
    db: *mut sqlite3,
    zPhase: *const libc::c_char,
    rc: libc::c_int,
    zSql: *const libc::c_char,
) -> *mut libc::c_char {
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zContext: *mut libc::c_char = 0 as *mut libc::c_char;
    let pStr: *mut sqlite3_str = sqlite3_str_new(0 as *mut sqlite3);
    sqlite3_str_appendf(
        pStr,
        b"%s, %s\0" as *const u8 as *const libc::c_char,
        zPhase,
        sqlite3_errmsg(db),
    );
    if rc > 1 as libc::c_int {
        sqlite3_str_appendf(pStr, b" (%d)\0" as *const u8 as *const libc::c_char, rc);
    }
    zContext = shell_error_context(zSql, db);
    if !zContext.is_null() {
        sqlite3_str_appendall(pStr, zContext);
        sqlite3_free(zContext as *mut libc::c_void);
    }
    zErr = sqlite3_str_finish(pStr);
    shell_check_oom(zErr as *const libc::c_void);
    return zErr;
}
unsafe extern "C" fn displayLinuxIoStats(out: *mut FILE) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut z: [libc::c_char; 200] = [0; 200];
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        z.as_mut_ptr(),
        b"/proc/%d/io\0" as *const u8 as *const libc::c_char,
        getpid(),
    );
    in_0 = fopen(z.as_mut_ptr(), b"rb\0" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        return;
    }
    while !(fgets(
        z.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        in_0,
    ))
        .is_null()
    {
        static mut aTrans: [C2RustUnnamed_18; 7] = [
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"rchar: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes received by read():\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"wchar: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes sent to write():\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"syscr: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Read() system calls:\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"syscw: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Write() system calls:\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"read_bytes: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes read from storage:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"write_bytes: \0" as *const u8 as *const libc::c_char,
                    zDesc: b"Bytes written to storage:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_18 {
                    zPattern: b"cancelled_write_bytes: \0" as *const u8
                        as *const libc::c_char,
                    zDesc: b"Cancelled write bytes:\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
        ];
        let mut i: libc::c_int = 0;
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[C2RustUnnamed_18; 7]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong,
                ) as libc::c_int
        {
            let n: libc::c_int = strlen30(aTrans[i as usize].zPattern);
            if cli_strncmp(aTrans[i as usize].zPattern, z.as_mut_ptr(), n as size_t)
                == 0 as libc::c_int
            {
                fprintf(
                    out,
                    b"%-36s %s\0" as *const u8 as *const libc::c_char,
                    aTrans[i as usize].zDesc,
                    &mut *z.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
                );
                break;
            } else {
                i += 1;
                i;
            }
        }
    }
    fclose(in_0);
}
unsafe extern "C" fn displayStatLine(
    p: *mut ShellState,
    zLabel: *mut libc::c_char,
    zFormat: *mut libc::c_char,
    iStatusCtrl: libc::c_int,
    bReset: libc::c_int,
) {
    let mut iCur: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut iHiwtr: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut i: libc::c_int = 0;
    let mut nPercent: libc::c_int = 0;
    let mut zLine: [libc::c_char; 200] = [0; 200];
    sqlite3_status64(iStatusCtrl, &mut iCur, &mut iHiwtr, bReset);
    i = 0 as libc::c_int;
    nPercent = 0 as libc::c_int;
    while *zFormat.offset(i as isize) != 0 {
        if *zFormat.offset(i as isize) as libc::c_int == '%' as i32 {
            nPercent += 1;
            nPercent;
        }
        i += 1;
        i;
    }
    if nPercent > 1 as libc::c_int {
        sqlite3_snprintf(
            ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iCur,
            iHiwtr,
        );
    } else {
        sqlite3_snprintf(
            ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iHiwtr,
        );
    }
    fprintf(
        (*p).out,
        b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
        zLabel,
        zLine.as_mut_ptr(),
    );
}
unsafe extern "C" fn display_stats(
    db: *mut sqlite3,
    pArg: *mut ShellState,
    bReset: libc::c_int,
) -> libc::c_int {
    let mut iCur: libc::c_int = 0;
    let mut iHiwtr: libc::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    if pArg.is_null() || ((*pArg).out).is_null() {
        return 0 as libc::c_int;
    }
    out = (*pArg).out;
    if !((*pArg).pStmt).is_null() && (*pArg).statsOn == 2 as libc::c_int as libc::c_uint
    {
        let mut nCol: libc::c_int = 0;
        let mut i: libc::c_int = 0;
        let mut x: libc::c_int = 0;
        let pStmt: *mut sqlite3_stmt = (*pArg).pStmt;
        let mut z: [libc::c_char; 100] = [0; 100];
        nCol = sqlite3_column_count(pStmt);
        fprintf(
            out,
            b"%-36s %d\n\0" as *const u8 as *const libc::c_char,
            b"Number of output columns:\0" as *const u8 as *const libc::c_char,
            nCol,
        );
        i = 0 as libc::c_int;
        while i < nCol {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                z.as_mut_ptr(),
                b"Column %d %nname:\0" as *const u8 as *const libc::c_char,
                i,
                &mut x as *mut libc::c_int,
            );
            fprintf(
                out,
                b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
                z.as_mut_ptr(),
                sqlite3_column_name(pStmt, i),
            );
            sqlite3_snprintf(
                30 as libc::c_int,
                z.as_mut_ptr().offset(x as isize),
                b"declared type:\0" as *const u8 as *const libc::c_char,
            );
            fprintf(
                out,
                b"%-36s %s\n\0" as *const u8 as *const libc::c_char,
                z.as_mut_ptr(),
                sqlite3_column_decltype(pStmt, i),
            );
            i += 1;
            i;
        }
    }
    if (*pArg).statsOn == 3 as libc::c_int as libc::c_uint {
        if !((*pArg).pStmt).is_null() {
            iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
            fprintf(
                (*pArg).out,
                b"VM-steps: %d\n\0" as *const u8 as *const libc::c_char,
                iCur,
            );
        }
        return 0 as libc::c_int;
    }
    displayStatLine(
        pArg,
        b"Memory Used:\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        b"%lld (max %lld) bytes\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        0 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Number of Outstanding Allocations:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld (max %lld)\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        9 as libc::c_int,
        bReset,
    );
    if (*pArg).shellFlgs & 0x1 as libc::c_int as libc::c_uint != 0 {
        displayStatLine(
            pArg,
            b"Number of Pcache Pages Used:\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            b"%lld (max %lld) pages\0" as *const u8 as *const libc::c_char
                as *mut libc::c_char,
            1 as libc::c_int,
            bReset,
        );
    }
    displayStatLine(
        pArg,
        b"Number of Pcache Overflow Bytes:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld (max %lld) bytes\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        2 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Largest Allocation:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld bytes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        5 as libc::c_int,
        bReset,
    );
    displayStatLine(
        pArg,
        b"Largest Pcache Allocation:\0" as *const u8 as *const libc::c_char
            as *mut libc::c_char,
        b"%lld bytes\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        7 as libc::c_int,
        bReset,
    );
    if !db.is_null() {
        if (*pArg).shellFlgs & 0x2 as libc::c_int as libc::c_uint != 0 {
            iCur = -(1 as libc::c_int);
            iHiwtr = iCur;
            sqlite3_db_status(db, 0 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside Slots Used:                %d (max %d)\n\0" as *const u8
                    as *const libc::c_char,
                iCur,
                iHiwtr,
            );
            sqlite3_db_status(db, 4 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Successful lookaside attempts:       %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
            sqlite3_db_status(db, 5 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside failures due to size:      %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
            sqlite3_db_status(db, 6 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
            fprintf(
                (*pArg).out,
                b"Lookaside failures due to OOM:       %d\n\0" as *const u8
                    as *const libc::c_char,
                iHiwtr,
            );
        }
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 1 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Pager Heap Usage:                    %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            7 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache hits:                     %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            8 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache misses:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            9 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache writes:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(
            db,
            12 as libc::c_int,
            &mut iCur,
            &mut iHiwtr,
            1 as libc::c_int,
        );
        fprintf(
            (*pArg).out,
            b"Page cache spills:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 2 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Schema Heap Usage:                   %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = -(1 as libc::c_int);
        iHiwtr = iCur;
        sqlite3_db_status(db, 3 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
        fprintf(
            (*pArg).out,
            b"Statement Heap/Lookaside Usage:      %d bytes\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
    }
    if !((*pArg).pStmt).is_null() {
        let mut iHit: libc::c_int = 0;
        let mut iMiss: libc::c_int = 0;
        iCur = sqlite3_stmt_status((*pArg).pStmt, 1 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Fullscan Steps:                      %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 2 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Sort Operations:                     %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 3 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Autoindex Inserts:                   %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iHit = sqlite3_stmt_status((*pArg).pStmt, 8 as libc::c_int, bReset);
        iMiss = sqlite3_stmt_status((*pArg).pStmt, 7 as libc::c_int, bReset);
        if iHit != 0 || iMiss != 0 {
            fprintf(
                (*pArg).out,
                b"Bloom filter bypass taken:           %d/%d\n\0" as *const u8
                    as *const libc::c_char,
                iHit,
                iHit + iMiss,
            );
        }
        iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Virtual Machine Steps:               %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 5 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Reprepare operations:                %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 6 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Number of times run:                 %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
        iCur = sqlite3_stmt_status((*pArg).pStmt, 99 as libc::c_int, bReset);
        fprintf(
            (*pArg).out,
            b"Memory used by prepared stmt:        %d\n\0" as *const u8
                as *const libc::c_char,
            iCur,
        );
    }
    displayLinuxIoStats((*pArg).out);
    return 0 as libc::c_int;
}
unsafe extern "C" fn str_in_array(
    zStr: *const libc::c_char,
    azArray: *mut *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(*azArray.offset(i as isize)).is_null() {
        if 0 as libc::c_int == cli_strcmp(zStr, *azArray.offset(i as isize)) {
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn explain_data_prepare(
    p: *mut ShellState,
    pSql: *mut sqlite3_stmt,
) {
    let mut abYield: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut iOp: libc::c_int = 0;
    let mut azNext: [*const libc::c_char; 7] = [
        b"Next\0" as *const u8 as *const libc::c_char,
        b"Prev\0" as *const u8 as *const libc::c_char,
        b"VPrev\0" as *const u8 as *const libc::c_char,
        b"VNext\0" as *const u8 as *const libc::c_char,
        b"SorterNext\0" as *const u8 as *const libc::c_char,
        b"Return\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azYield: [*const libc::c_char; 6] = [
        b"Yield\0" as *const u8 as *const libc::c_char,
        b"SeekLT\0" as *const u8 as *const libc::c_char,
        b"SeekGT\0" as *const u8 as *const libc::c_char,
        b"RowSetRead\0" as *const u8 as *const libc::c_char,
        b"Rewind\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azGoto: [*const libc::c_char; 2] = [
        b"Goto\0" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    if sqlite3_column_count(pSql) >= 4 as libc::c_int {} else {
        __assert_fail(
            b"sqlite3_column_count(pSql)>=4\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19269 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                .as_ptr(),
        );
    }
    'c_89227: {
        if sqlite3_column_count(pSql) >= 4 as libc::c_int {} else {
            __assert_fail(
                b"sqlite3_column_count(pSql)>=4\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19269 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 56],
                    &[libc::c_char; 56],
                >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                    .as_ptr(),
            );
        }
    };
    if 0 as libc::c_int
        == sqlite3_stricmp(
            sqlite3_column_name(pSql, 0 as libc::c_int),
            b"addr\0" as *const u8 as *const libc::c_char,
        )
    {} else {
        __assert_fail(
            b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 0), \"addr\" )\0"
                as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19270 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                .as_ptr(),
        );
    }
    'c_89173: {
        if 0 as libc::c_int
            == sqlite3_stricmp(
                sqlite3_column_name(pSql, 0 as libc::c_int),
                b"addr\0" as *const u8 as *const libc::c_char,
            )
        {} else {
            __assert_fail(
                b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 0), \"addr\" )\0"
                    as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19270 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 56],
                    &[libc::c_char; 56],
                >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                    .as_ptr(),
            );
        }
    };
    if 0 as libc::c_int
        == sqlite3_stricmp(
            sqlite3_column_name(pSql, 1 as libc::c_int),
            b"opcode\0" as *const u8 as *const libc::c_char,
        )
    {} else {
        __assert_fail(
            b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 1), \"opcode\" )\0"
                as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19271 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                .as_ptr(),
        );
    }
    'c_89119: {
        if 0 as libc::c_int
            == sqlite3_stricmp(
                sqlite3_column_name(pSql, 1 as libc::c_int),
                b"opcode\0" as *const u8 as *const libc::c_char,
            )
        {} else {
            __assert_fail(
                b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 1), \"opcode\" )\0"
                    as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19271 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 56],
                    &[libc::c_char; 56],
                >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                    .as_ptr(),
            );
        }
    };
    if 0 as libc::c_int
        == sqlite3_stricmp(
            sqlite3_column_name(pSql, 2 as libc::c_int),
            b"p1\0" as *const u8 as *const libc::c_char,
        )
    {} else {
        __assert_fail(
            b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 2), \"p1\" )\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19272 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                .as_ptr(),
        );
    }
    'c_89065: {
        if 0 as libc::c_int
            == sqlite3_stricmp(
                sqlite3_column_name(pSql, 2 as libc::c_int),
                b"p1\0" as *const u8 as *const libc::c_char,
            )
        {} else {
            __assert_fail(
                b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 2), \"p1\" )\0"
                    as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19272 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 56],
                    &[libc::c_char; 56],
                >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                    .as_ptr(),
            );
        }
    };
    if 0 as libc::c_int
        == sqlite3_stricmp(
            sqlite3_column_name(pSql, 3 as libc::c_int),
            b"p2\0" as *const u8 as *const libc::c_char,
        )
    {} else {
        __assert_fail(
            b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 3), \"p2\" )\0" as *const u8
                as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19273 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 56],
                &[libc::c_char; 56],
            >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                .as_ptr(),
        );
    }
    'c_89011: {
        if 0 as libc::c_int
            == sqlite3_stricmp(
                sqlite3_column_name(pSql, 3 as libc::c_int),
                b"p2\0" as *const u8 as *const libc::c_char,
            )
        {} else {
            __assert_fail(
                b"0==sqlite3_stricmp( sqlite3_column_name(pSql, 3), \"p2\" )\0"
                    as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19273 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 56],
                    &[libc::c_char; 56],
                >(b"void explain_data_prepare(ShellState *, sqlite3_stmt *)\0"))
                    .as_ptr(),
            );
        }
    };
    iOp = 0 as libc::c_int;
    while 100 as libc::c_int == sqlite3_step(pSql) {
        let mut i: libc::c_int = 0;
        let iAddr: libc::c_int = sqlite3_column_int(pSql, 0 as libc::c_int);
        let zOp: *const libc::c_char = sqlite3_column_text(pSql, 1 as libc::c_int)
            as *const libc::c_char;
        let p1: libc::c_int = sqlite3_column_int(pSql, 2 as libc::c_int);
        let p2: libc::c_int = sqlite3_column_int(pSql, 3 as libc::c_int);
        let p2op: libc::c_int = p2 + (iOp - iAddr);
        if iOp >= nAlloc {
            nAlloc += 100 as libc::c_int;
            (*p)
                .aiIndent = sqlite3_realloc64(
                (*p).aiIndent as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as sqlite3_uint64,
            ) as *mut libc::c_int;
            shell_check_oom((*p).aiIndent as *const libc::c_void);
            abYield = sqlite3_realloc64(
                abYield as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    as sqlite3_uint64,
            ) as *mut libc::c_int;
            shell_check_oom(abYield as *const libc::c_void);
        }
        *abYield.offset(iOp as isize) = str_in_array(zOp, azYield.as_mut_ptr());
        *((*p).aiIndent).offset(iOp as isize) = 0 as libc::c_int;
        (*p).nIndent = iOp + 1 as libc::c_int;
        if str_in_array(zOp, azNext.as_mut_ptr()) != 0 && p2op > 0 as libc::c_int {
            i = p2op;
            while i < iOp {
                *((*p).aiIndent).offset(i as isize) += 2 as libc::c_int;
                i += 1;
                i;
            }
        }
        if str_in_array(zOp, azGoto.as_mut_ptr()) != 0 && p2op < iOp
            && (*abYield.offset(p2op as isize) != 0 || p1 != 0)
        {
            i = p2op;
            while i < iOp {
                *((*p).aiIndent).offset(i as isize) += 2 as libc::c_int;
                i += 1;
                i;
            }
        }
        iOp += 1;
        iOp;
    }
    (*p).iIndent = 0 as libc::c_int;
    sqlite3_free(abYield as *mut libc::c_void);
    sqlite3_reset(pSql);
}
unsafe extern "C" fn explain_data_delete(p: *mut ShellState) {
    sqlite3_free((*p).aiIndent as *mut libc::c_void);
    (*p).aiIndent = 0 as *mut libc::c_int;
    (*p).nIndent = 0 as libc::c_int;
    (*p).iIndent = 0 as libc::c_int;
}
unsafe extern "C" fn display_scanstats(_db: *mut sqlite3, _pArg: *mut ShellState) {}
static mut savedSelectTrace: libc::c_uint = 0;
static mut savedWhereTrace: libc::c_uint = 0;
unsafe extern "C" fn disable_debug_trace_modes() {
    let mut zero: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    sqlite3_test_control(
        31 as libc::c_int,
        0 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        2 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
}
unsafe extern "C" fn restore_debug_trace_modes() {
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
}
unsafe extern "C" fn bind_table_init(p: *mut ShellState) {
    let mut wrSchema: libc::c_int = 0 as libc::c_int;
    let mut defensiveMode: libc::c_int = 0 as libc::c_int;
    sqlite3_db_config(
        (*p).db,
        1010 as libc::c_int,
        -(1 as libc::c_int),
        &mut defensiveMode as *mut libc::c_int,
    );
    sqlite3_db_config((*p).db, 1010 as libc::c_int, 0 as libc::c_int, 0 as libc::c_int);
    sqlite3_db_config(
        (*p).db,
        1011 as libc::c_int,
        -(1 as libc::c_int),
        &mut wrSchema as *mut libc::c_int,
    );
    sqlite3_db_config((*p).db, 1011 as libc::c_int, 1 as libc::c_int, 0 as libc::c_int);
    sqlite3_exec(
        (*p).db,
        b"CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n  key TEXT PRIMARY KEY,\n  value\n) WITHOUT ROWID;\0"
            as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    sqlite3_db_config((*p).db, 1011 as libc::c_int, wrSchema, 0 as libc::c_int);
    sqlite3_db_config((*p).db, 1010 as libc::c_int, defensiveMode, 0 as libc::c_int);
}
unsafe extern "C" fn bind_prepared_stmt(
    pArg: *mut ShellState,
    pStmt: *mut sqlite3_stmt,
) {
    let mut nVar: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut pQ: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    nVar = sqlite3_bind_parameter_count(pStmt);
    if nVar == 0 as libc::c_int {
        return;
    }
    if sqlite3_table_column_metadata(
        (*pArg).db,
        b"TEMP\0" as *const u8 as *const libc::c_char,
        b"sqlite_parameters\0" as *const u8 as *const libc::c_char,
        b"key\0" as *const u8 as *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    ) != 0 as libc::c_int
    {
        rc = 12 as libc::c_int;
        pQ = 0 as *mut sqlite3_stmt;
    } else {
        rc = sqlite3_prepare_v2(
            (*pArg).db,
            b"SELECT value FROM temp.sqlite_parameters WHERE key=?1\0" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pQ,
            0 as *mut *const libc::c_char,
        );
    }
    i = 1 as libc::c_int;
    while i <= nVar {
        let mut zNum: [libc::c_char; 30] = [0; 30];
        let mut zVar: *const libc::c_char = sqlite3_bind_parameter_name(pStmt, i);
        if zVar.is_null() {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                zNum.as_mut_ptr(),
                b"?%d\0" as *const u8 as *const libc::c_char,
                i,
            );
            zVar = zNum.as_mut_ptr();
        }
        sqlite3_bind_text(pQ, 1 as libc::c_int, zVar, -(1 as libc::c_int), None);
        if rc == 0 as libc::c_int && !pQ.is_null()
            && sqlite3_step(pQ) == 100 as libc::c_int
        {
            sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0 as libc::c_int));
        } else if sqlite3_strlike(
            b"_NAN\0" as *const u8 as *const libc::c_char,
            zVar,
            0 as libc::c_int as libc::c_uint,
        ) == 0 as libc::c_int
        {
            sqlite3_bind_double(pStmt, i, ::core::f32::NAN as libc::c_double);
        } else if sqlite3_strlike(
            b"_INF\0" as *const u8 as *const libc::c_char,
            zVar,
            0 as libc::c_int as libc::c_uint,
        ) == 0 as libc::c_int
        {
            sqlite3_bind_double(pStmt, i, ::core::f32::INFINITY as libc::c_double);
        } else {
            sqlite3_bind_null(pStmt, i);
        }
        sqlite3_reset(pQ);
        i += 1;
        i;
    }
    sqlite3_finalize(pQ);
}
unsafe extern "C" fn print_box_line(out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 61] = *::core::mem::transmute::<
        &[u8; 61],
        &[libc::c_char; 61],
    >(
        b"\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\xE2\x94\x80\0",
    );
    let nDash: libc::c_int = (::core::mem::size_of::<[libc::c_char; 61]>()
        as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong) as libc::c_int;
    N *= 3 as libc::c_int;
    while N > nDash {
        fprintf(out, zDash.as_ptr());
        N -= nDash;
    }
    fprintf(out, b"%.*s\0" as *const u8 as *const libc::c_char, N, zDash.as_ptr());
}
unsafe extern "C" fn print_box_row_separator(
    p: *mut ShellState,
    nArg: libc::c_int,
    zSep1: *const libc::c_char,
    zSep2: *const libc::c_char,
    zSep3: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep1);
        print_box_line(
            (*p).out,
            *((*p).actualWidth).offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep2);
            print_box_line(
                (*p).out,
                *((*p).actualWidth).offset(i as isize) + 2 as libc::c_int,
            );
            i += 1;
            i;
        }
        fprintf((*p).out, b"%s\0" as *const u8 as *const libc::c_char, zSep3);
    }
    fputs(b"\n\0" as *const u8 as *const libc::c_char, (*p).out);
}
unsafe extern "C" fn translateForDisplayAndDup(
    z: *const libc::c_uchar,
    pzTail: *mut *const libc::c_uchar,
    mut mxWidth: libc::c_int,
    bWordWrap: u8_0,
) -> *mut libc::c_char {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut zOut: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if z.is_null() {
        *pzTail = 0 as *const libc::c_uchar;
        return 0 as *mut libc::c_char;
    }
    if mxWidth < 0 as libc::c_int {
        mxWidth = -mxWidth;
    }
    if mxWidth == 0 as libc::c_int {
        mxWidth = 1000000 as libc::c_int;
    }
    n = 0 as libc::c_int;
    j = n;
    i = j;
    while n < mxWidth {
        if *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
            n += 1;
            n;
            loop {
                i += 1;
                i;
                j += 1;
                j;
                if !(*z.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int)
                {
                    break;
                }
            }
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\t' as i32) {
                break;
            }
            loop {
                n += 1;
                n;
                j += 1;
                j;
                if !(n & 7 as libc::c_int != 0 as libc::c_int && n < mxWidth) {
                    break;
                }
            }
            i += 1;
            i;
        }
    }
    if n >= mxWidth && bWordWrap as libc::c_int != 0 {
        k = i;
        while k > i / 2 as libc::c_int {
            if *(*__ctype_b_loc())
                .offset(
                    *z.offset((k - 1 as libc::c_int) as isize) as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                break;
            }
            k -= 1;
            k;
        }
        if k <= i / 2 as libc::c_int {
            k = i;
            while k > i / 2 as libc::c_int {
                if *(*__ctype_b_loc())
                    .offset(
                        *z.offset((k - 1 as libc::c_int) as isize) as libc::c_int
                            as isize,
                    ) as libc::c_int
                    & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                    != *(*__ctype_b_loc())
                        .offset(*z.offset(k as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                    && *z.offset(k as isize) as libc::c_int & 0xc0 as libc::c_int
                        != 0x80 as libc::c_int
                {
                    break;
                }
                k -= 1;
                k;
            }
        }
        if k <= i / 2 as libc::c_int {
            k = i;
        } else {
            i = k;
            while *z.offset(i as isize) as libc::c_int == ' ' as i32 {
                i += 1;
                i;
            }
        }
    } else {
        k = i;
    }
    if n >= mxWidth && *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
        *pzTail = &*z.offset(i as isize) as *const libc::c_uchar;
    } else if *z.offset(i as isize) as libc::c_int == '\r' as i32
        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '\n' as i32
    {
        *pzTail = if *z.offset((i + 2 as libc::c_int) as isize) as libc::c_int != 0 {
            &*z.offset((i + 2 as libc::c_int) as isize) as *const libc::c_uchar
        } else {
            0 as *const libc::c_uchar
        };
    } else if *z.offset(i as isize) as libc::c_int == 0 as libc::c_int
        || *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == 0 as libc::c_int
    {
        *pzTail = 0 as *const libc::c_uchar;
    } else {
        *pzTail = &*z.offset((i + 1 as libc::c_int) as isize) as *const libc::c_uchar;
    }
    zOut = malloc((j + 1 as libc::c_int) as libc::c_ulong) as *mut libc::c_uchar;
    shell_check_oom(zOut as *const libc::c_void);
    n = 0 as libc::c_int;
    j = n;
    i = j;
    while i < k {
        if *z.offset(i as isize) as libc::c_int >= ' ' as i32 {
            n += 1;
            n;
            loop {
                let fresh83 = i;
                i = i + 1;
                let fresh84 = j;
                j = j + 1;
                *zOut.offset(fresh84 as isize) = *z.offset(fresh83 as isize);
                if !(*z.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int)
                {
                    break;
                }
            }
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\t' as i32) {
                break;
            }
            loop {
                n += 1;
                n;
                let fresh85 = j;
                j = j + 1;
                *zOut.offset(fresh85 as isize) = ' ' as i32 as libc::c_uchar;
                if !(n & 7 as libc::c_int != 0 as libc::c_int && n < mxWidth) {
                    break;
                }
            }
            i += 1;
            i;
        }
    }
    *zOut.offset(j as isize) = 0 as libc::c_int as libc::c_uchar;
    return zOut as *mut libc::c_char;
}
unsafe extern "C" fn quoted_column(
    pStmt: *mut sqlite3_stmt,
    i: libc::c_int,
) -> *mut libc::c_char {
    match sqlite3_column_type(pStmt, i) {
        5 => return sqlite3_mprintf(b"NULL\0" as *const u8 as *const libc::c_char),
        1 | 2 => {
            return sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, i),
            );
        }
        3 => {
            return sqlite3_mprintf(
                b"%Q\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, i),
            );
        }
        4 => {
            let mut j: libc::c_int = 0;
            let pStr: *mut sqlite3_str = sqlite3_str_new(0 as *mut sqlite3);
            let a: *const libc::c_uchar = sqlite3_column_blob(pStmt, i)
                as *const libc::c_uchar;
            let n: libc::c_int = sqlite3_column_bytes(pStmt, i);
            sqlite3_str_append(
                pStr,
                b"x'\0" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
            );
            j = 0 as libc::c_int;
            while j < n {
                sqlite3_str_appendf(
                    pStr,
                    b"%02x\0" as *const u8 as *const libc::c_char,
                    *a.offset(j as isize) as libc::c_int,
                );
                j += 1;
                j;
            }
            sqlite3_str_append(
                pStr,
                b"'\0" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
            );
            return sqlite3_str_finish(pStr);
        }
        _ => {}
    }
    return 0 as *mut libc::c_char;
}
unsafe extern "C" fn exec_prepared_stmt_columnar(
    p: *mut ShellState,
    pStmt: *mut sqlite3_stmt,
) {
    let current_block: u64;
    let mut nRow: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut nColumn: libc::c_int = 0 as libc::c_int;
    let mut azData: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut nAlloc: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut abRowDiv: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut uz: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut azQuoted: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: sqlite3_int64 = 0;
    let mut nData: sqlite3_int64 = 0;
    let mut j: libc::c_int = 0;
    let mut nTotal: libc::c_int = 0;
    let mut w: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut colSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut rowSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut azNextLine: *mut *const libc::c_uchar = 0 as *mut *const libc::c_uchar;
    let mut bNextLine: libc::c_int = 0 as libc::c_int;
    let mut bMultiLineRowExists: libc::c_int = 0 as libc::c_int;
    let bw: libc::c_int = (*p).cmOpts.bWordWrap as libc::c_int;
    let zEmpty: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let zShowNull: *const libc::c_char = ((*p).nullValue).as_mut_ptr();
    rc = sqlite3_step(pStmt);
    if rc != 100 as libc::c_int {
        return;
    }
    nColumn = sqlite3_column_count(pStmt);
    nAlloc = (nColumn * 4 as libc::c_int) as sqlite3_int64;
    if nAlloc <= 0 as libc::c_int as libc::c_longlong {
        nAlloc = 1 as libc::c_int as sqlite3_int64;
    }
    azData = sqlite3_malloc64(
        (nAlloc as libc::c_ulonglong)
            .wrapping_mul(
                ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                    as libc::c_ulonglong,
            ),
    ) as *mut *mut libc::c_char;
    shell_check_oom(azData as *const libc::c_void);
    azNextLine = sqlite3_malloc64(
        (nColumn as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut *const libc::c_uchar;
    shell_check_oom(azNextLine as *const libc::c_void);
    memset(
        azNextLine as *mut libc::c_void,
        0 as libc::c_int,
        (nColumn as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong),
    );
    if (*p).cmOpts.bQuote != 0 {
        azQuoted = sqlite3_malloc64(
            (nColumn as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as sqlite3_uint64,
        ) as *mut *mut libc::c_char;
        shell_check_oom(azQuoted as *const libc::c_void);
        memset(
            azQuoted as *mut libc::c_void,
            0 as libc::c_int,
            (nColumn as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ),
        );
    }
    abRowDiv = sqlite3_malloc64((nAlloc / nColumn as libc::c_longlong) as sqlite3_uint64)
        as *mut libc::c_char;
    shell_check_oom(abRowDiv as *const libc::c_void);
    if nColumn > (*p).nWidth {
        (*p)
            .colWidth = realloc(
            (*p).colWidth as *mut libc::c_void,
            (((nColumn + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
        ) as *mut libc::c_int;
        shell_check_oom((*p).colWidth as *const libc::c_void);
        i = (*p).nWidth as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            *((*p).colWidth).offset(i as isize) = 0 as libc::c_int;
            i += 1;
            i;
        }
        (*p).nWidth = nColumn;
        (*p)
            .actualWidth = &mut *((*p).colWidth).offset(nColumn as isize)
            as *mut libc::c_int;
    }
    memset(
        (*p).actualWidth as *mut libc::c_void,
        0 as libc::c_int,
        (nColumn as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong),
    );
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nColumn as libc::c_longlong {
        w = *((*p).colWidth).offset(i as isize);
        if w < 0 as libc::c_int {
            w = -w;
        }
        *((*p).actualWidth).offset(i as isize) = w;
        i += 1;
        i;
    }
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nColumn as libc::c_longlong {
        let mut zNotUsed: *const libc::c_uchar = 0 as *const libc::c_uchar;
        let mut wx: libc::c_int = *((*p).colWidth).offset(i as isize);
        if wx == 0 as libc::c_int {
            wx = (*p).cmOpts.iWrap;
        }
        if wx < 0 as libc::c_int {
            wx = -wx;
        }
        uz = sqlite3_column_name(pStmt, i as libc::c_int) as *const libc::c_uchar;
        if uz.is_null() {
            uz = b"\0" as *const u8 as *const libc::c_char as *mut u8_0;
        }
        let ref mut fresh86 = *azData.offset(i as isize);
        *fresh86 = translateForDisplayAndDup(uz, &mut zNotUsed, wx, bw as u8_0);
        i += 1;
        i;
    }
    loop {
        let useNextLine: libc::c_int = bNextLine;
        bNextLine = 0 as libc::c_int;
        if (nRow + 2 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong
            >= nAlloc
        {
            nAlloc *= 2 as libc::c_int as libc::c_longlong;
            azData = sqlite3_realloc64(
                azData as *mut libc::c_void,
                (nAlloc as libc::c_ulonglong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                            as libc::c_ulonglong,
                    ),
            ) as *mut *mut libc::c_char;
            shell_check_oom(azData as *const libc::c_void);
            abRowDiv = sqlite3_realloc64(
                abRowDiv as *mut libc::c_void,
                (nAlloc / nColumn as libc::c_longlong) as sqlite3_uint64,
            ) as *mut libc::c_char;
            shell_check_oom(abRowDiv as *const libc::c_void);
        }
        *abRowDiv.offset(nRow as isize) = 1 as libc::c_int as libc::c_char;
        nRow += 1;
        nRow;
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            let mut wx_0: libc::c_int = *((*p).colWidth).offset(i as isize);
            if wx_0 == 0 as libc::c_int {
                wx_0 = (*p).cmOpts.iWrap;
            }
            if wx_0 < 0 as libc::c_int {
                wx_0 = -wx_0;
            }
            if useNextLine != 0 {
                uz = *azNextLine.offset(i as isize);
                if uz.is_null() {
                    uz = zEmpty as *mut u8_0;
                }
            } else if (*p).cmOpts.bQuote != 0 {
                sqlite3_free(*azQuoted.offset(i as isize) as *mut libc::c_void);
                let ref mut fresh87 = *azQuoted.offset(i as isize);
                *fresh87 = quoted_column(pStmt, i as libc::c_int);
                uz = *azQuoted.offset(i as isize) as *const libc::c_uchar;
            } else {
                uz = sqlite3_column_text(pStmt, i as libc::c_int);
                if uz.is_null() {
                    uz = zShowNull as *mut u8_0;
                }
            }
            let ref mut fresh88 = *azData
                .offset((nRow * nColumn as libc::c_longlong + i) as isize);
            *fresh88 = translateForDisplayAndDup(
                uz,
                &mut *azNextLine.offset(i as isize),
                wx_0,
                bw as u8_0,
            );
            if !(*azNextLine.offset(i as isize)).is_null() {
                bNextLine = 1 as libc::c_int;
                *abRowDiv
                    .offset(
                        (nRow - 1 as libc::c_int as libc::c_longlong) as isize,
                    ) = 0 as libc::c_int as libc::c_char;
                bMultiLineRowExists = 1 as libc::c_int;
            }
            i += 1;
            i;
        }
        if !(bNextLine != 0 || sqlite3_step(pStmt) == 100 as libc::c_int) {
            break;
        }
    }
    nTotal = (nColumn as libc::c_longlong
        * (nRow + 1 as libc::c_int as libc::c_longlong)) as libc::c_int;
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nTotal as libc::c_longlong {
        z = *azData.offset(i as isize);
        if z.is_null() {
            z = zEmpty as *mut libc::c_char;
        }
        n = strlenChar(z);
        j = (i % nColumn as libc::c_longlong) as libc::c_int;
        if n > *((*p).actualWidth).offset(j as isize) {
            *((*p).actualWidth).offset(j as isize) = n;
        }
        i += 1;
        i;
    }
    if !(seenInterrupt != 0) {
        if !(nColumn == 0 as libc::c_int) {
            match (*p).cMode {
                1 => {
                    colSep = b"  \0" as *const u8 as *const libc::c_char;
                    rowSep = b"\n\0" as *const u8 as *const libc::c_char;
                    if (*p).showHeader != 0 {
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            w = *((*p).actualWidth).offset(i as isize);
                            if *((*p).colWidth).offset(i as isize) < 0 as libc::c_int {
                                w = -w;
                            }
                            utf8_width_print((*p).out, w, *azData.offset(i as isize));
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \0" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1;
                            i;
                        }
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            print_dashes(
                                (*p).out,
                                *((*p).actualWidth).offset(i as isize),
                            );
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b"\n\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \0" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1;
                            i;
                        }
                    }
                }
                15 => {
                    colSep = b" | \0" as *const u8 as *const libc::c_char;
                    rowSep = b" |\n\0" as *const u8 as *const libc::c_char;
                    print_row_separator(
                        p,
                        nColumn,
                        b"+\0" as *const u8 as *const libc::c_char,
                    );
                    fputs(b"| \0" as *const u8 as *const libc::c_char, (*p).out);
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        fputs(
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" |\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" | \0" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1;
                        i;
                    }
                    print_row_separator(
                        p,
                        nColumn,
                        b"+\0" as *const u8 as *const libc::c_char,
                    );
                }
                14 => {
                    colSep = b" | \0" as *const u8 as *const libc::c_char;
                    rowSep = b" |\n\0" as *const u8 as *const libc::c_char;
                    fputs(b"| \0" as *const u8 as *const libc::c_char, (*p).out);
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                        );
                        fputs(
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" |\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" | \0" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1;
                        i;
                    }
                    print_row_separator(
                        p,
                        nColumn,
                        b"|\0" as *const u8 as *const libc::c_char,
                    );
                }
                16 => {
                    colSep = b" \xE2\x94\x82 \0" as *const u8 as *const libc::c_char;
                    rowSep = b" \xE2\x94\x82\n\0" as *const u8 as *const libc::c_char;
                    print_box_row_separator(
                        p,
                        nColumn,
                        b"\xE2\x94\x8C\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xAC\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\x90\0" as *const u8 as *const libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"\xE2\x94\x82 \0" as *const u8 as *const libc::c_char,
                    );
                    i = 0 as libc::c_int as sqlite3_int64;
                    while i < nColumn as libc::c_longlong {
                        w = *((*p).actualWidth).offset(i as isize);
                        n = strlenChar(*azData.offset(i as isize));
                        fprintf(
                            (*p).out,
                            b"%*s%s%*s%s\0" as *const u8 as *const libc::c_char,
                            (w - n) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            *azData.offset(i as isize),
                            (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                            b"\0" as *const u8 as *const libc::c_char,
                            if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                b" \xE2\x94\x82\n\0" as *const u8 as *const libc::c_char
                            } else {
                                b" \xE2\x94\x82 \0" as *const u8 as *const libc::c_char
                            },
                        );
                        i += 1;
                        i;
                    }
                    print_box_row_separator(
                        p,
                        nColumn,
                        b"\xE2\x94\x9C\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xBC\0" as *const u8 as *const libc::c_char,
                        b"\xE2\x94\xA4\0" as *const u8 as *const libc::c_char,
                    );
                }
                _ => {}
            }
            i = nColumn as sqlite3_int64;
            j = 0 as libc::c_int;
            loop {
                if !(i < nTotal as libc::c_longlong) {
                    current_block = 16754622181974910496;
                    break;
                }
                if j == 0 as libc::c_int && (*p).cMode != 1 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        if (*p).cMode == 16 as libc::c_int {
                            b"\xE2\x94\x82 \0" as *const u8 as *const libc::c_char
                        } else {
                            b"| \0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                z = *azData.offset(i as isize);
                if z.is_null() {
                    z = ((*p).nullValue).as_mut_ptr();
                }
                w = *((*p).actualWidth).offset(j as isize);
                if *((*p).colWidth).offset(j as isize) < 0 as libc::c_int {
                    w = -w;
                }
                utf8_width_print((*p).out, w, z);
                if j == nColumn - 1 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        rowSep,
                    );
                    if bMultiLineRowExists != 0
                        && *abRowDiv
                            .offset(
                                (i / nColumn as libc::c_longlong
                                    - 1 as libc::c_int as libc::c_longlong) as isize,
                            ) as libc::c_int != 0
                        && (i + 1 as libc::c_int as libc::c_longlong)
                            < nTotal as libc::c_longlong
                    {
                        if (*p).cMode == 15 as libc::c_int {
                            print_row_separator(
                                p,
                                nColumn,
                                b"+\0" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 16 as libc::c_int {
                            print_box_row_separator(
                                p,
                                nColumn,
                                b"\xE2\x94\x9C\0" as *const u8 as *const libc::c_char,
                                b"\xE2\x94\xBC\0" as *const u8 as *const libc::c_char,
                                b"\xE2\x94\xA4\0" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"\n\0" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                    j = -(1 as libc::c_int);
                    if seenInterrupt != 0 {
                        current_block = 3518413108295667458;
                        break;
                    }
                } else {
                    fprintf(
                        (*p).out,
                        b"%s\0" as *const u8 as *const libc::c_char,
                        colSep,
                    );
                }
                i += 1;
                i;
                j += 1;
                j;
            }
            match current_block {
                3518413108295667458 => {}
                _ => {
                    if (*p).cMode == 15 as libc::c_int {
                        print_row_separator(
                            p,
                            nColumn,
                            b"+\0" as *const u8 as *const libc::c_char,
                        );
                    } else if (*p).cMode == 16 as libc::c_int {
                        print_box_row_separator(
                            p,
                            nColumn,
                            b"\xE2\x94\x94\0" as *const u8 as *const libc::c_char,
                            b"\xE2\x94\xB4\0" as *const u8 as *const libc::c_char,
                            b"\xE2\x94\x98\0" as *const u8 as *const libc::c_char,
                        );
                    }
                }
            }
        }
    }
    if seenInterrupt != 0 {
        fprintf((*p).out, b"Interrupt\n\0" as *const u8 as *const libc::c_char);
    }
    nData = (nRow + 1 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong;
    i = 0 as libc::c_int as sqlite3_int64;
    while i < nData {
        z = *azData.offset(i as isize);
        if z != zEmpty && z != zShowNull {
            free(*azData.offset(i as isize) as *mut libc::c_void);
        }
        i += 1;
        i;
    }
    sqlite3_free(azData as *mut libc::c_void);
    sqlite3_free(azNextLine as *mut libc::c_void);
    sqlite3_free(abRowDiv as *mut libc::c_void);
    if !azQuoted.is_null() {
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            sqlite3_free(*azQuoted.offset(i as isize) as *mut libc::c_void);
            i += 1;
            i;
        }
        sqlite3_free(azQuoted as *mut libc::c_void);
    }
}
unsafe extern "C" fn exec_prepared_stmt(
    pArg: *mut ShellState,
    pStmt: *mut sqlite3_stmt,
) {
    let mut rc: libc::c_int = 0;
    let mut nRow: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
    if (*pArg).cMode == 1 as libc::c_int || (*pArg).cMode == 15 as libc::c_int
        || (*pArg).cMode == 16 as libc::c_int || (*pArg).cMode == 14 as libc::c_int
    {
        exec_prepared_stmt_columnar(pArg, pStmt);
        return;
    }
    rc = sqlite3_step(pStmt);
    if 100 as libc::c_int == rc {
        let nCol: libc::c_int = sqlite3_column_count(pStmt);
        let pData: *mut libc::c_void = sqlite3_malloc64(
            ((3 as libc::c_int * nCol) as libc::c_ulong)
                .wrapping_mul(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                )
                .wrapping_add(1 as libc::c_int as libc::c_ulong) as sqlite3_uint64,
        );
        if pData.is_null() {
            shell_out_of_memory();
        } else {
            let azCols: *mut *mut libc::c_char = pData as *mut *mut libc::c_char;
            let azVals: *mut *mut libc::c_char = &mut *azCols.offset(nCol as isize)
                as *mut *mut libc::c_char;
            let aiTypes: *mut libc::c_int = &mut *azVals.offset(nCol as isize)
                as *mut *mut libc::c_char as *mut libc::c_int;
            let mut i: libc::c_int = 0;
            let mut x: libc::c_int = 0;
            if ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                <= ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
            {} else {
                __assert_fail(
                    b"sizeof(int) <= sizeof(char *)\0" as *const u8
                        as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    19916 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 54],
                        &[libc::c_char; 54],
                    >(b"void exec_prepared_stmt(ShellState *, sqlite3_stmt *)\0"))
                        .as_ptr(),
                );
            }
            'c_89610: {
                if ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                    <= ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                {} else {
                    __assert_fail(
                        b"sizeof(int) <= sizeof(char *)\0" as *const u8
                            as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        19916 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 54],
                            &[libc::c_char; 54],
                        >(b"void exec_prepared_stmt(ShellState *, sqlite3_stmt *)\0"))
                            .as_ptr(),
                    );
                }
            };
            i = 0 as libc::c_int;
            while i < nCol {
                let ref mut fresh89 = *azCols.offset(i as isize);
                *fresh89 = sqlite3_column_name(pStmt, i) as *mut libc::c_char;
                i += 1;
                i;
            }
            loop {
                nRow = nRow.wrapping_add(1);
                nRow;
                i = 0 as libc::c_int;
                while i < nCol {
                    x = sqlite3_column_type(pStmt, i);
                    *aiTypes.offset(i as isize) = x;
                    if x == 4 as libc::c_int && !pArg.is_null()
                        && ((*pArg).cMode == 5 as libc::c_int
                            || (*pArg).cMode == 6 as libc::c_int)
                    {
                        let ref mut fresh90 = *azVals.offset(i as isize);
                        *fresh90 = b"\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                    } else {
                        let ref mut fresh91 = *azVals.offset(i as isize);
                        *fresh91 = sqlite3_column_text(pStmt, i) as *mut libc::c_char;
                    }
                    if (*azVals.offset(i as isize)).is_null()
                        && *aiTypes.offset(i as isize) != 5 as libc::c_int
                    {
                        rc = 7 as libc::c_int;
                        break;
                    } else {
                        i += 1;
                        i;
                    }
                }
                if 100 as libc::c_int == rc {
                    if shell_callback(
                        pArg as *mut libc::c_void,
                        nCol,
                        azVals,
                        azCols,
                        aiTypes,
                    ) != 0
                    {
                        rc = 4 as libc::c_int;
                    } else {
                        rc = sqlite3_step(pStmt);
                    }
                }
                if !(100 as libc::c_int == rc) {
                    break;
                }
            }
            sqlite3_free(pData);
            if (*pArg).cMode == 13 as libc::c_int {
                fputs(b"]\n\0" as *const u8 as *const libc::c_char, (*pArg).out);
            } else if (*pArg).cMode == 17 as libc::c_int {
                let mut zBuf: [libc::c_char; 200] = [0; 200];
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong
                        as libc::c_int,
                    zBuf.as_mut_ptr(),
                    b"%llu row%s\n\0" as *const u8 as *const libc::c_char,
                    nRow,
                    if nRow != 1 as libc::c_int as libc::c_ulonglong {
                        b"s\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                printf(b"%s\0" as *const u8 as *const libc::c_char, zBuf.as_mut_ptr());
            }
        }
    }
}
unsafe extern "C" fn expertHandleSQL(
    pState: *mut ShellState,
    zSql: *const libc::c_char,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    if !((*pState).expert.pExpert).is_null() {} else {
        __assert_fail(
            b"pState->expert.pExpert\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19979 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 57],
                &[libc::c_char; 57],
            >(b"int expertHandleSQL(ShellState *, const char *, char **)\0"))
                .as_ptr(),
        );
    }
    'c_93005: {
        if !((*pState).expert.pExpert).is_null() {} else {
            __assert_fail(
                b"pState->expert.pExpert\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19979 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 57],
                    &[libc::c_char; 57],
                >(b"int expertHandleSQL(ShellState *, const char *, char **)\0"))
                    .as_ptr(),
            );
        }
    };
    if pzErr.is_null() || (*pzErr).is_null() {} else {
        __assert_fail(
            b"pzErr==0 || *pzErr==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            19980 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 57],
                &[libc::c_char; 57],
            >(b"int expertHandleSQL(ShellState *, const char *, char **)\0"))
                .as_ptr(),
        );
    }
    'c_92951: {
        if pzErr.is_null() || (*pzErr).is_null() {} else {
            __assert_fail(
                b"pzErr==0 || *pzErr==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                19980 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 57],
                    &[libc::c_char; 57],
                >(b"int expertHandleSQL(ShellState *, const char *, char **)\0"))
                    .as_ptr(),
            );
        }
    };
    return sqlite3_expert_sql((*pState).expert.pExpert, zSql, pzErr);
}
unsafe extern "C" fn expertFinish(
    pState: *mut ShellState,
    bCancel: libc::c_int,
    pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let p: *mut sqlite3expert = (*pState).expert.pExpert;
    if !p.is_null() {} else {
        __assert_fail(
            b"p\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            20001 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 45],
                &[libc::c_char; 45],
            >(b"int expertFinish(ShellState *, int, char **)\0"))
                .as_ptr(),
        );
    }
    'c_93314: {
        if !p.is_null() {} else {
            __assert_fail(
                b"p\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                20001 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 45],
                    &[libc::c_char; 45],
                >(b"int expertFinish(ShellState *, int, char **)\0"))
                    .as_ptr(),
            );
        }
    };
    if bCancel != 0 || pzErr.is_null() || (*pzErr).is_null() {} else {
        __assert_fail(
            b"bCancel || pzErr==0 || *pzErr==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            20002 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 45],
                &[libc::c_char; 45],
            >(b"int expertFinish(ShellState *, int, char **)\0"))
                .as_ptr(),
        );
    }
    'c_93254: {
        if bCancel != 0 || pzErr.is_null() || (*pzErr).is_null() {} else {
            __assert_fail(
                b"bCancel || pzErr==0 || *pzErr==0\0" as *const u8
                    as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                20002 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 45],
                    &[libc::c_char; 45],
                >(b"int expertFinish(ShellState *, int, char **)\0"))
                    .as_ptr(),
            );
        }
    };
    if bCancel == 0 as libc::c_int {
        let out: *mut FILE = (*pState).out;
        let bVerbose: libc::c_int = (*pState).expert.bVerbose;
        rc = sqlite3_expert_analyze(p, pzErr);
        if rc == 0 as libc::c_int {
            let nQuery: libc::c_int = sqlite3_expert_count(p);
            let mut i: libc::c_int = 0;
            if bVerbose != 0 {
                let zCand: *const libc::c_char = sqlite3_expert_report(
                    p,
                    0 as libc::c_int,
                    4 as libc::c_int,
                );
                fprintf(
                    out,
                    b"-- Candidates -----------------------------\n\0" as *const u8
                        as *const libc::c_char,
                );
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zCand);
            }
            i = 0 as libc::c_int;
            while i < nQuery {
                let zSql: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    1 as libc::c_int,
                );
                let mut zIdx: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    2 as libc::c_int,
                );
                let zEQP: *const libc::c_char = sqlite3_expert_report(
                    p,
                    i,
                    3 as libc::c_int,
                );
                if zIdx.is_null() {
                    zIdx = b"(no new indexes)\n\0" as *const u8 as *const libc::c_char;
                }
                if bVerbose != 0 {
                    fprintf(
                        out,
                        b"-- Query %d --------------------------------\n\0" as *const u8
                            as *const libc::c_char,
                        i + 1 as libc::c_int,
                    );
                    fprintf(out, b"%s\n\n\0" as *const u8 as *const libc::c_char, zSql);
                }
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zIdx);
                fprintf(out, b"%s\n\0" as *const u8 as *const libc::c_char, zEQP);
                i += 1;
                i;
            }
        }
    }
    sqlite3_expert_destroy(p);
    (*pState).expert.pExpert = 0 as *mut sqlite3expert;
    return rc;
}
unsafe extern "C" fn expertDotCommand(
    pState: *mut ShellState,
    azArg: *mut *mut libc::c_char,
    nArg: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut iSample: libc::c_int = 0 as libc::c_int;
    if ((*pState).expert.pExpert).is_null() {} else {
        __assert_fail(
            b"pState->expert.pExpert==0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            20049 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 49],
                &[libc::c_char; 49],
            >(b"int expertDotCommand(ShellState *, char **, int)\0"))
                .as_ptr(),
        );
    }
    'c_93642: {
        if ((*pState).expert.pExpert).is_null() {} else {
            __assert_fail(
                b"pState->expert.pExpert==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                20049 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 49],
                    &[libc::c_char; 49],
                >(b"int expertDotCommand(ShellState *, char **, int)\0"))
                    .as_ptr(),
            );
        }
    };
    memset(
        &mut (*pState).expert as *mut ExpertInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ExpertInfo>() as libc::c_ulong,
    );
    i = 1 as libc::c_int;
    while rc == 0 as libc::c_int && i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1);
            z;
        }
        n = strlen30(z);
        if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == cli_strncmp(
                    z,
                    b"-verbose\0" as *const u8 as *const libc::c_char,
                    n as size_t,
                )
        {
            (*pState).expert.bVerbose = 1 as libc::c_int;
        } else if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == cli_strncmp(
                    z,
                    b"-sample\0" as *const u8 as *const libc::c_char,
                    n as size_t,
                )
        {
            if i == nArg - 1 as libc::c_int {
                fprintf(
                    stderr,
                    b"option requires an argument: %s\n\0" as *const u8
                        as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int;
            } else {
                i += 1;
                iSample = integerValue(*azArg.offset(i as isize)) as libc::c_int;
                if iSample < 0 as libc::c_int || iSample > 100 as libc::c_int {
                    fprintf(
                        stderr,
                        b"value out of range: %s\n\0" as *const u8
                            as *const libc::c_char,
                        *azArg.offset(i as isize),
                    );
                    rc = 1 as libc::c_int;
                }
            }
        } else {
            fprintf(
                stderr,
                b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                z,
            );
            rc = 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    if rc == 0 as libc::c_int {
        (*pState).expert.pExpert = sqlite3_expert_new((*pState).db, &mut zErr);
        if ((*pState).expert.pExpert).is_null() {
            fprintf(
                stderr,
                b"sqlite3_expert_new: %s\n\0" as *const u8 as *const libc::c_char,
                if !zErr.is_null() {
                    zErr as *const libc::c_char
                } else {
                    b"out of memory\0" as *const u8 as *const libc::c_char
                },
            );
            rc = 1 as libc::c_int;
        } else {
            sqlite3_expert_config((*pState).expert.pExpert, 1 as libc::c_int, iSample);
        }
    }
    sqlite3_free(zErr as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn shell_exec(
    pArg: *mut ShellState,
    mut zSql: *const libc::c_char,
    pzErrMsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut rc2: libc::c_int = 0;
    let mut zLeftover: *const libc::c_char = 0 as *const libc::c_char;
    let db: *mut sqlite3 = (*pArg).db;
    if !pzErrMsg.is_null() {
        *pzErrMsg = 0 as *mut libc::c_char;
    }
    if !((*pArg).expert.pExpert).is_null() {
        rc = expertHandleSQL(pArg, zSql, pzErrMsg);
        return expertFinish(pArg, (rc != 0 as libc::c_int) as libc::c_int, pzErrMsg);
    }
    while *zSql.offset(0 as libc::c_int as isize) as libc::c_int != 0
        && 0 as libc::c_int == rc
    {
        static mut zStmtSql: *const libc::c_char = 0 as *const libc::c_char;
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            &mut zLeftover,
        );
        if 0 as libc::c_int != rc {
            if !pzErrMsg.is_null() {
                *pzErrMsg = save_err_msg(
                    db,
                    b"in prepare\0" as *const u8 as *const libc::c_char,
                    rc,
                    zSql,
                );
            }
        } else if pStmt.is_null() {
            zSql = zLeftover;
            while *(*__ctype_b_loc())
                .offset(
                    *zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zSql = zSql.offset(1);
                zSql;
            }
        } else {
            zStmtSql = sqlite3_sql(pStmt);
            if zStmtSql.is_null() {
                zStmtSql = b"\0" as *const u8 as *const libc::c_char;
            }
            while *(*__ctype_b_loc())
                .offset(
                    *zStmtSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                ) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zStmtSql = zStmtSql.offset(1);
                zStmtSql;
            }
            if !pArg.is_null() {
                (*pArg).pStmt = pStmt;
                (*pArg).cnt = 0 as libc::c_int;
            }
            if !pArg.is_null() && (*pArg).autoEQP as libc::c_int != 0
                && sqlite3_stmt_isexplain(pStmt) == 0 as libc::c_int
            {
                let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                let mut triggerEQP: libc::c_int = 0 as libc::c_int;
                disable_debug_trace_modes();
                sqlite3_db_config(
                    db,
                    1008 as libc::c_int,
                    -(1 as libc::c_int),
                    &mut triggerEQP as *mut libc::c_int,
                );
                if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int {
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        1 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                pExplain = pStmt;
                sqlite3_reset(pExplain);
                rc = sqlite3_stmt_explain(pExplain, 2 as libc::c_int);
                if rc == 0 as libc::c_int {
                    while sqlite3_step(pExplain) == 100 as libc::c_int {
                        let mut zEQPLine: *const libc::c_char = sqlite3_column_text(
                            pExplain,
                            3 as libc::c_int,
                        ) as *const libc::c_char;
                        let iEqpId: libc::c_int = sqlite3_column_int(
                            pExplain,
                            0 as libc::c_int,
                        );
                        let iParentId: libc::c_int = sqlite3_column_int(
                            pExplain,
                            1 as libc::c_int,
                        );
                        if zEQPLine.is_null() {
                            zEQPLine = b"\0" as *const u8 as *const libc::c_char;
                        }
                        if *zEQPLine.offset(0 as libc::c_int as isize) as libc::c_int
                            == '-' as i32
                        {
                            eqp_render(pArg, 0 as libc::c_int as i64_0);
                        }
                        eqp_append(pArg, iEqpId, iParentId, zEQPLine);
                    }
                    eqp_render(pArg, 0 as libc::c_int as i64_0);
                }
                if (*pArg).autoEQP as libc::c_int >= 3 as libc::c_int {
                    sqlite3_reset(pExplain);
                    rc = sqlite3_stmt_explain(pExplain, 1 as libc::c_int);
                    if rc == 0 as libc::c_int {
                        (*pArg).cMode = 9 as libc::c_int;
                        if sqlite3_stmt_isexplain(pExplain) == 1 as libc::c_int {} else {
                            __assert_fail(
                                b"sqlite3_stmt_isexplain(pExplain)==1\0" as *const u8
                                    as *const libc::c_char,
                                b"shell.c\0" as *const u8 as *const libc::c_char,
                                20180 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 52],
                                    &[libc::c_char; 52],
                                >(b"int shell_exec(ShellState *, const char *, char **)\0"))
                                    .as_ptr(),
                            );
                        }
                        'c_94049: {
                            if sqlite3_stmt_isexplain(pExplain) == 1 as libc::c_int
                            {} else {
                                __assert_fail(
                                    b"sqlite3_stmt_isexplain(pExplain)==1\0" as *const u8
                                        as *const libc::c_char,
                                    b"shell.c\0" as *const u8 as *const libc::c_char,
                                    20180 as libc::c_int as libc::c_uint,
                                    (*::core::mem::transmute::<
                                        &[u8; 52],
                                        &[libc::c_char; 52],
                                    >(b"int shell_exec(ShellState *, const char *, char **)\0"))
                                        .as_ptr(),
                                );
                            }
                        };
                        explain_data_prepare(pArg, pExplain);
                        exec_prepared_stmt(pArg, pExplain);
                        explain_data_delete(pArg);
                    }
                }
                if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int
                    && triggerEQP == 0 as libc::c_int
                {
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        0 as libc::c_int,
                        0 as libc::c_int,
                    );
                }
                sqlite3_reset(pStmt);
                sqlite3_stmt_explain(pStmt, 0 as libc::c_int);
                restore_debug_trace_modes();
            }
            if !pArg.is_null() {
                let bIsExplain: libc::c_int = (sqlite3_stmt_isexplain(pStmt)
                    == 1 as libc::c_int) as libc::c_int;
                (*pArg).cMode = (*pArg).mode;
                if (*pArg).autoExplain != 0 {
                    if bIsExplain != 0 {
                        (*pArg).cMode = 9 as libc::c_int;
                    }
                    if sqlite3_stmt_isexplain(pStmt) == 2 as libc::c_int {
                        (*pArg).cMode = 12 as libc::c_int;
                    }
                }
                if (*pArg).cMode == 9 as libc::c_int && bIsExplain != 0 {
                    explain_data_prepare(pArg, pStmt);
                }
            }
            bind_prepared_stmt(pArg, pStmt);
            exec_prepared_stmt(pArg, pStmt);
            explain_data_delete(pArg);
            eqp_render(pArg, 0 as libc::c_int as i64_0);
            if !pArg.is_null() && (*pArg).statsOn != 0 {
                display_stats(db, pArg, 0 as libc::c_int);
            }
            if !pArg.is_null() && (*pArg).scanstatsOn as libc::c_int != 0 {
                display_scanstats(db, pArg);
            }
            rc2 = sqlite3_finalize(pStmt);
            if rc != 7 as libc::c_int {
                rc = rc2;
            }
            if rc == 0 as libc::c_int {
                zSql = zLeftover;
                while *(*__ctype_b_loc())
                    .offset(
                        *zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                {
                    zSql = zSql.offset(1);
                    zSql;
                }
            } else if !pzErrMsg.is_null() {
                *pzErrMsg = save_err_msg(
                    db,
                    b"stepping\0" as *const u8 as *const libc::c_char,
                    rc,
                    0 as *const libc::c_char,
                );
            }
            if !pArg.is_null() {
                (*pArg).pStmt = 0 as *mut sqlite3_stmt;
            }
        }
    }
    return rc;
}
unsafe extern "C" fn freeColumnList(azCol: *mut *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while !(*azCol.offset(i as isize)).is_null() {
        sqlite3_free(*azCol.offset(i as isize) as *mut libc::c_void);
        i += 1;
        i;
    }
    sqlite3_free(azCol as *mut libc::c_void);
}
unsafe extern "C" fn tableColumnList(
    p: *mut ShellState,
    zTab: *const libc::c_char,
) -> *mut *mut libc::c_char {
    let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut nPK: libc::c_int = 0 as libc::c_int;
    let mut isIPK: libc::c_int = 0 as libc::c_int;
    let mut preserveRowid: libc::c_int = ((*p).shellFlgs
        & 0x8 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint)
        as libc::c_int;
    let mut rc: libc::c_int = 0;
    zSql = sqlite3_mprintf(
        b"PRAGMA table_info=%Q\0" as *const u8 as *const libc::c_char,
        zTab,
    );
    shell_check_oom(zSql as *const libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    if rc != 0 {
        return 0 as *mut *mut libc::c_char;
    }
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        if nCol >= nAlloc - 2 as libc::c_int {
            nAlloc = nAlloc * 2 as libc::c_int + nCol + 10 as libc::c_int;
            azCol = sqlite3_realloc(
                azCol as *mut libc::c_void,
                (nAlloc as libc::c_ulong)
                    .wrapping_mul(
                        ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int,
            ) as *mut *mut libc::c_char;
            shell_check_oom(azCol as *const libc::c_void);
        }
        nCol += 1;
        let ref mut fresh92 = *azCol.offset(nCol as isize);
        *fresh92 = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            sqlite3_column_text(pStmt, 1 as libc::c_int),
        );
        shell_check_oom(*azCol.offset(nCol as isize) as *const libc::c_void);
        if sqlite3_column_int(pStmt, 5 as libc::c_int) != 0 {
            nPK += 1;
            nPK;
            if nPK == 1 as libc::c_int
                && sqlite3_stricmp(
                    sqlite3_column_text(pStmt, 2 as libc::c_int) as *const libc::c_char,
                    b"INTEGER\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                isIPK = 1 as libc::c_int;
            } else {
                isIPK = 0 as libc::c_int;
            }
        }
    }
    sqlite3_finalize(pStmt);
    if azCol.is_null() {
        return 0 as *mut *mut libc::c_char;
    }
    let ref mut fresh93 = *azCol.offset(0 as libc::c_int as isize);
    *fresh93 = 0 as *mut libc::c_char;
    let ref mut fresh94 = *azCol.offset((nCol + 1 as libc::c_int) as isize);
    *fresh94 = 0 as *mut libc::c_char;
    if preserveRowid != 0 && isIPK != 0 {
        zSql = sqlite3_mprintf(
            b"SELECT 1 FROM pragma_index_list(%Q) WHERE origin='pk'\0" as *const u8
                as *const libc::c_char,
            zTab,
        );
        shell_check_oom(zSql as *const libc::c_void);
        rc = sqlite3_prepare_v2(
            (*p).db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
        if rc != 0 {
            freeColumnList(azCol);
            return 0 as *mut *mut libc::c_char;
        }
        rc = sqlite3_step(pStmt);
        sqlite3_finalize(pStmt);
        preserveRowid = (rc == 100 as libc::c_int) as libc::c_int;
    }
    if preserveRowid != 0 {
        static mut azRowid: [*mut libc::c_char; 3] = [
            b"rowid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"_rowid_\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
            b"oid\0" as *const u8 as *const libc::c_char as *mut libc::c_char,
        ];
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        j = 0 as libc::c_int;
        while j < 3 as libc::c_int {
            i = 1 as libc::c_int;
            while i <= nCol {
                if sqlite3_stricmp(azRowid[j as usize], *azCol.offset(i as isize))
                    == 0 as libc::c_int
                {
                    break;
                }
                i += 1;
                i;
            }
            if i > nCol {
                rc = sqlite3_table_column_metadata(
                    (*p).db,
                    0 as *const libc::c_char,
                    zTab,
                    azRowid[j as usize],
                    0 as *mut *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                );
                if rc == 0 as libc::c_int {
                    let ref mut fresh95 = *azCol.offset(0 as libc::c_int as isize);
                    *fresh95 = azRowid[j as usize];
                }
                break;
            } else {
                j += 1;
                j;
            }
        }
    }
    return azCol;
}
unsafe extern "C" fn toggleSelectOrder(db: *mut sqlite3) {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut iSetting: libc::c_int = 0 as libc::c_int;
    let mut zStmt: [libc::c_char; 100] = [0; 100];
    sqlite3_prepare_v2(
        db,
        b"PRAGMA reverse_unordered_selects\0" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        iSetting = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    sqlite3_finalize(pStmt);
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
        zStmt.as_mut_ptr(),
        b"PRAGMA reverse_unordered_selects(%d)\0" as *const u8 as *const libc::c_char,
        (iSetting == 0) as libc::c_int,
    );
    sqlite3_exec(
        db,
        zStmt.as_mut_ptr(),
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
unsafe extern "C" fn dump_callback(
    pArg: *mut libc::c_void,
    nArg: libc::c_int,
    azArg: *mut *mut libc::c_char,
    _azNotUsed: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zTable: *const libc::c_char = 0 as *const libc::c_char;
    let mut zType: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let p: *mut ShellState = pArg as *mut ShellState;
    let mut dataOnly: libc::c_int = 0;
    let mut noSys: libc::c_int = 0;
    if nArg != 3 as libc::c_int || azArg.is_null() {
        return 0 as libc::c_int;
    }
    zTable = *azArg.offset(0 as libc::c_int as isize);
    zType = *azArg.offset(1 as libc::c_int as isize);
    zSql = *azArg.offset(2 as libc::c_int as isize);
    if zTable.is_null() {
        return 0 as libc::c_int;
    }
    if zType.is_null() {
        return 0 as libc::c_int;
    }
    dataOnly = ((*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    noSys = ((*p).shellFlgs & 0x200 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint) as libc::c_int;
    if cli_strcmp(zTable, b"sqlite_sequence\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int && noSys == 0
    {
        if dataOnly == 0 {
            fprintf(
                (*p).out,
                b"DELETE FROM sqlite_sequence;\n\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if sqlite3_strglob(
        b"sqlite_stat?\0" as *const u8 as *const libc::c_char,
        zTable,
    ) == 0 as libc::c_int && noSys == 0
    {
        if dataOnly == 0 {
            fprintf(
                (*p).out,
                b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if cli_strncmp(
        zTable,
        b"sqlite_\0" as *const u8 as *const libc::c_char,
        7 as libc::c_int as size_t,
    ) == 0 as libc::c_int
    {
        return 0 as libc::c_int
    } else if !(dataOnly != 0) {
        if cli_strncmp(
            zSql,
            b"CREATE VIRTUAL TABLE\0" as *const u8 as *const libc::c_char,
            20 as libc::c_int as size_t,
        ) == 0 as libc::c_int
        {
            let mut zIns: *mut libc::c_char = 0 as *mut libc::c_char;
            if (*p).writableSchema == 0 {
                fprintf(
                    (*p).out,
                    b"PRAGMA writable_schema=ON;\n\0" as *const u8 as *const libc::c_char,
                );
                (*p).writableSchema = 1 as libc::c_int;
            }
            zIns = sqlite3_mprintf(
                b"INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)VALUES('table','%q','%q',0,'%q');\0"
                    as *const u8 as *const libc::c_char,
                zTable,
                zTable,
                zSql,
            );
            shell_check_oom(zIns as *const libc::c_void);
            fprintf((*p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zIns);
            sqlite3_free(zIns as *mut libc::c_void);
            return 0 as libc::c_int;
        } else {
            printSchemaLine(
                (*p).out,
                zSql,
                b";\n\0" as *const u8 as *const libc::c_char,
            );
        }
    }
    if cli_strcmp(zType, b"table\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        let mut sSelect: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut sTable: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut i: libc::c_int = 0;
        let mut savedDestTable: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut savedMode: libc::c_int = 0;
        azCol = tableColumnList(p, zTable);
        if azCol.is_null() {
            (*p).nErr += 1;
            (*p).nErr;
            return 0 as libc::c_int;
        }
        initText(&mut sTable);
        appendText(&mut sTable, zTable, quoteChar(zTable));
        if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
            appendText(
                &mut sTable,
                b"(\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
            appendText(
                &mut sTable,
                *azCol.offset(0 as libc::c_int as isize),
                0 as libc::c_int as libc::c_char,
            );
            i = 1 as libc::c_int;
            while !(*azCol.offset(i as isize)).is_null() {
                appendText(
                    &mut sTable,
                    b",\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                appendText(
                    &mut sTable,
                    *azCol.offset(i as isize),
                    quoteChar(*azCol.offset(i as isize)),
                );
                i += 1;
                i;
            }
            appendText(
                &mut sTable,
                b")\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        initText(&mut sSelect);
        appendText(
            &mut sSelect,
            b"SELECT \0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
            appendText(
                &mut sSelect,
                *azCol.offset(0 as libc::c_int as isize),
                0 as libc::c_int as libc::c_char,
            );
            appendText(
                &mut sSelect,
                b",\0" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        i = 1 as libc::c_int;
        while !(*azCol.offset(i as isize)).is_null() {
            appendText(
                &mut sSelect,
                *azCol.offset(i as isize),
                quoteChar(*azCol.offset(i as isize)),
            );
            if !(*azCol.offset((i + 1 as libc::c_int) as isize)).is_null() {
                appendText(
                    &mut sSelect,
                    b",\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
            }
            i += 1;
            i;
        }
        freeColumnList(azCol);
        appendText(
            &mut sSelect,
            b" FROM \0" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        appendText(&mut sSelect, zTable, quoteChar(zTable));
        savedDestTable = (*p).zDestTable;
        savedMode = (*p).mode;
        (*p).zDestTable = sTable.z;
        (*p).cMode = 5 as libc::c_int;
        (*p).mode = (*p).cMode;
        rc = shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
        if rc & 0xff as libc::c_int == 11 as libc::c_int {
            fprintf(
                (*p).out,
                b"/****** CORRUPTION ERROR *******/\n\0" as *const u8
                    as *const libc::c_char,
            );
            toggleSelectOrder((*p).db);
            shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
            toggleSelectOrder((*p).db);
        }
        (*p).zDestTable = savedDestTable;
        (*p).mode = savedMode;
        freeText(&mut sTable);
        freeText(&mut sSelect);
        if rc != 0 {
            (*p).nErr += 1;
            (*p).nErr;
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn run_schema_dump_query(
    p: *mut ShellState,
    zQuery: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).db,
        zQuery,
        Some(
            dump_callback
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *mut *mut libc::c_char,
                    *mut *mut libc::c_char,
                ) -> libc::c_int,
        ),
        p as *mut libc::c_void,
        &mut zErr,
    );
    if rc == 11 as libc::c_int {
        let mut zQ2: *mut libc::c_char = 0 as *mut libc::c_char;
        let len: libc::c_int = strlen30(zQuery);
        fprintf(
            (*p).out,
            b"/****** CORRUPTION ERROR *******/\n\0" as *const u8 as *const libc::c_char,
        );
        if !zErr.is_null() {
            fprintf(
                (*p).out,
                b"/****** %s ******/\n\0" as *const u8 as *const libc::c_char,
                zErr,
            );
            sqlite3_free(zErr as *mut libc::c_void);
            zErr = 0 as *mut libc::c_char;
        }
        zQ2 = malloc((len + 100 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
        if zQ2.is_null() {
            return rc;
        }
        sqlite3_snprintf(
            len + 100 as libc::c_int,
            zQ2,
            b"%s ORDER BY rowid DESC\0" as *const u8 as *const libc::c_char,
            zQuery,
        );
        rc = sqlite3_exec(
            (*p).db,
            zQ2,
            Some(
                dump_callback
                    as unsafe extern "C" fn(
                        *mut libc::c_void,
                        libc::c_int,
                        *mut *mut libc::c_char,
                        *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            p as *mut libc::c_void,
            &mut zErr,
        );
        if rc != 0 {
            fprintf(
                (*p).out,
                b"/****** ERROR: %s ******/\n\0" as *const u8 as *const libc::c_char,
                zErr,
            );
        } else {
            rc = 11 as libc::c_int;
        }
        sqlite3_free(zErr as *mut libc::c_void);
        free(zQ2 as *mut libc::c_void);
    }
    return rc;
}
static mut azHelp: [*const libc::c_char; 202] = [
    b".archive ...             Manage SQL archives\0" as *const u8
        as *const libc::c_char,
    b"   Each command must have exactly one of the following options:\0" as *const u8
        as *const libc::c_char,
    b"     -c, --create               Create a new archive\0" as *const u8
        as *const libc::c_char,
    b"     -u, --update               Add or update files with changed mtime\0"
        as *const u8 as *const libc::c_char,
    b"     -i, --insert               Like -u but always add even if unchanged\0"
        as *const u8 as *const libc::c_char,
    b"     -r, --remove               Remove files from archive\0" as *const u8
        as *const libc::c_char,
    b"     -t, --list                 List contents of archive\0" as *const u8
        as *const libc::c_char,
    b"     -x, --extract              Extract files from archive\0" as *const u8
        as *const libc::c_char,
    b"   Optional arguments:\0" as *const u8 as *const libc::c_char,
    b"     -v, --verbose              Print each filename as it is processed\0"
        as *const u8 as *const libc::c_char,
    b"     -f FILE, --file FILE       Use archive FILE (default is current db)\0"
        as *const u8 as *const libc::c_char,
    b"     -a FILE, --append FILE     Open FILE using the apndvfs VFS\0" as *const u8
        as *const libc::c_char,
    b"     -C DIR, --directory DIR    Read/extract files from directory DIR\0"
        as *const u8 as *const libc::c_char,
    b"     -g, --glob                 Use glob matching for names in archive\0"
        as *const u8 as *const libc::c_char,
    b"     -n, --dryrun               Show the SQL that would have occurred\0"
        as *const u8 as *const libc::c_char,
    b"   Examples:\0" as *const u8 as *const libc::c_char,
    b"     .ar -cf ARCHIVE foo bar  # Create ARCHIVE from files foo and bar\0"
        as *const u8 as *const libc::c_char,
    b"     .ar -tf ARCHIVE          # List members of ARCHIVE\0" as *const u8
        as *const libc::c_char,
    b"     .ar -xvf ARCHIVE         # Verbosely extract files from ARCHIVE\0"
        as *const u8 as *const libc::c_char,
    b"   See also:\0" as *const u8 as *const libc::c_char,
    b"      http://sqlite.org/cli.html#sqlite_archive_support\0" as *const u8
        as *const libc::c_char,
    b".auth ON|OFF             Show authorizer callbacks\0" as *const u8
        as *const libc::c_char,
    b".backup ?DB? FILE        Backup DB (default \"main\") to FILE\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"       --append            Use the appendvfs\0" as *const u8
        as *const libc::c_char,
    b"       --async             Write to FILE without journal and fsync()\0"
        as *const u8 as *const libc::c_char,
    b".bail on|off             Stop after hitting an error.  Default OFF\0" as *const u8
        as *const libc::c_char,
    b".cd DIRECTORY            Change the working directory to DIRECTORY\0" as *const u8
        as *const libc::c_char,
    b".changes on|off          Show number of rows changed by SQL\0" as *const u8
        as *const libc::c_char,
    b".check GLOB              Fail if output since .testcase does not match\0"
        as *const u8 as *const libc::c_char,
    b".clone NEWDB             Clone data into NEWDB from the existing database\0"
        as *const u8 as *const libc::c_char,
    b".connection [close] [#]  Open or close an auxiliary database connection\0"
        as *const u8 as *const libc::c_char,
    b".databases               List names and files of attached databases\0" as *const u8
        as *const libc::c_char,
    b".dbconfig ?op? ?val?     List or change sqlite3_db_config() options\0" as *const u8
        as *const libc::c_char,
    b".dbinfo ?DB?             Show status information about the database\0" as *const u8
        as *const libc::c_char,
    b".dump ?OBJECTS?          Render database content as SQL\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --data-only            Output only INSERT statements\0" as *const u8
        as *const libc::c_char,
    b"     --newlines             Allow unescaped newline characters in output\0"
        as *const u8 as *const libc::c_char,
    b"     --nosys                Omit system tables (ex: \"sqlite_stat1\")\0"
        as *const u8 as *const libc::c_char,
    b"     --preserve-rowids      Include ROWID values in the output\0" as *const u8
        as *const libc::c_char,
    b"   OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump\0"
        as *const u8 as *const libc::c_char,
    b"   Additional LIKE patterns can be given in subsequent arguments\0" as *const u8
        as *const libc::c_char,
    b".echo on|off             Turn command echo on or off\0" as *const u8
        as *const libc::c_char,
    b".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN\0"
        as *const u8 as *const libc::c_char,
    b"   Other Modes:\0" as *const u8 as *const libc::c_char,
    b"      trigger               Like \"full\" but also show trigger bytecode\0"
        as *const u8 as *const libc::c_char,
    b".excel                   Display the output of next command in spreadsheet\0"
        as *const u8 as *const libc::c_char,
    b"   --bom                   Put a UTF8 byte-order mark on intermediate file\0"
        as *const u8 as *const libc::c_char,
    b".exit ?CODE?             Exit this program with return-code CODE\0" as *const u8
        as *const libc::c_char,
    b".expert                  EXPERIMENTAL. Suggest indexes for queries\0" as *const u8
        as *const libc::c_char,
    b".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto\0"
        as *const u8 as *const libc::c_char,
    b".filectrl CMD ...        Run various sqlite3_file_control() operations\0"
        as *const u8 as *const libc::c_char,
    b"   --schema SCHEMA         Use SCHEMA instead of \"main\"\0" as *const u8
        as *const libc::c_char,
    b"   --help                  Show CMD details\0" as *const u8 as *const libc::c_char,
    b".fullschema ?--indent?   Show schema and the content of sqlite_stat tables\0"
        as *const u8 as *const libc::c_char,
    b".headers on|off          Turn display of headers on or off\0" as *const u8
        as *const libc::c_char,
    b".help ?-all? ?PATTERN?   Show help text for PATTERN\0" as *const u8
        as *const libc::c_char,
    b".import FILE TABLE       Import data from FILE into TABLE\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --ascii               Use \\037 and \\036 as column and row separators\0"
        as *const u8 as *const libc::c_char,
    b"     --csv                 Use , and \\n as column and row separators\0"
        as *const u8 as *const libc::c_char,
    b"     --skip N              Skip the first N rows of input\0" as *const u8
        as *const libc::c_char,
    b"     --schema S            Target table to be S.TABLE\0" as *const u8
        as *const libc::c_char,
    b"     -v                    \"Verbose\" - increase auxiliary output\0" as *const u8
        as *const libc::c_char,
    b"   Notes:\0" as *const u8 as *const libc::c_char,
    b"     *  If TABLE does not exist, it is created.  The first row of input\0"
        as *const u8 as *const libc::c_char,
    b"        determines the column names.\0" as *const u8 as *const libc::c_char,
    b"     *  If neither --csv or --ascii are used, the input mode is derived\0"
        as *const u8 as *const libc::c_char,
    b"        from the \".mode\" output mode\0" as *const u8 as *const libc::c_char,
    b"     *  If FILE begins with \"|\" then it is a command that generates the\0"
        as *const u8 as *const libc::c_char,
    b"        input text.\0" as *const u8 as *const libc::c_char,
    b",imposter INDEX TABLE    Create imposter table TABLE on index INDEX\0" as *const u8
        as *const libc::c_char,
    b".indexes ?TABLE?         Show names of indexes\0" as *const u8
        as *const libc::c_char,
    b"                           If TABLE is specified, only show indexes for\0"
        as *const u8 as *const libc::c_char,
    b"                           tables matching TABLE using the LIKE operator.\0"
        as *const u8 as *const libc::c_char,
    b".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT\0"
        as *const u8 as *const libc::c_char,
    b".lint OPTIONS            Report potential schema issues.\0" as *const u8
        as *const libc::c_char,
    b"     Options:\0" as *const u8 as *const libc::c_char,
    b"        fkey-indexes     Find missing foreign key indexes\0" as *const u8
        as *const libc::c_char,
    b".load FILE ?ENTRY?       Load an extension library\0" as *const u8
        as *const libc::c_char,
    b".log FILE|on|off         Turn logging on or off.  FILE can be stderr/stdout\0"
        as *const u8 as *const libc::c_char,
    b".mode MODE ?OPTIONS?     Set output mode\0" as *const u8 as *const libc::c_char,
    b"   MODE is one of:\0" as *const u8 as *const libc::c_char,
    b"     ascii       Columns/rows delimited by 0x1F and 0x1E\0" as *const u8
        as *const libc::c_char,
    b"     box         Tables using unicode box-drawing characters\0" as *const u8
        as *const libc::c_char,
    b"     csv         Comma-separated values\0" as *const u8 as *const libc::c_char,
    b"     column      Output in columns.  (See .width)\0" as *const u8
        as *const libc::c_char,
    b"     html        HTML <table> code\0" as *const u8 as *const libc::c_char,
    b"     insert      SQL insert statements for TABLE\0" as *const u8
        as *const libc::c_char,
    b"     json        Results in a JSON array\0" as *const u8 as *const libc::c_char,
    b"     line        One value per line\0" as *const u8 as *const libc::c_char,
    b"     list        Values delimited by \"|\"\0" as *const u8 as *const libc::c_char,
    b"     markdown    Markdown table format\0" as *const u8 as *const libc::c_char,
    b"     qbox        Shorthand for \"box --wrap 60 --quote\"\0" as *const u8
        as *const libc::c_char,
    b"     quote       Escape answers as for SQL\0" as *const u8 as *const libc::c_char,
    b"     table       ASCII-art table\0" as *const u8 as *const libc::c_char,
    b"     tabs        Tab-separated values\0" as *const u8 as *const libc::c_char,
    b"     tcl         TCL list elements\0" as *const u8 as *const libc::c_char,
    b"   OPTIONS: (for columnar modes or insert mode):\0" as *const u8
        as *const libc::c_char,
    b"     --wrap N       Wrap output lines to no longer than N characters\0"
        as *const u8 as *const libc::c_char,
    b"     --wordwrap B   Wrap or not at word boundaries per B (on/off)\0" as *const u8
        as *const libc::c_char,
    b"     --ww           Shorthand for \"--wordwrap 1\"\0" as *const u8
        as *const libc::c_char,
    b"     --quote        Quote output text as SQL literals\0" as *const u8
        as *const libc::c_char,
    b"     --noquote      Do not quote output text\0" as *const u8
        as *const libc::c_char,
    b"     TABLE          The name of SQL table used for \"insert\" mode\0" as *const u8
        as *const libc::c_char,
    b".nonce STRING            Suspend safe mode for one command if nonce matches\0"
        as *const u8 as *const libc::c_char,
    b".nullvalue STRING        Use STRING in place of NULL values\0" as *const u8
        as *const libc::c_char,
    b".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE\0"
        as *const u8 as *const libc::c_char,
    b"     If FILE begins with '|' then open as a pipe\0" as *const u8
        as *const libc::c_char,
    b"       --bom  Put a UTF8 byte-order mark at the beginning\0" as *const u8
        as *const libc::c_char,
    b"       -e     Send output to the system text editor\0" as *const u8
        as *const libc::c_char,
    b"       -x     Send output as CSV to a spreadsheet (same as \".excel\")\0"
        as *const u8 as *const libc::c_char,
    b".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE\0" as *const u8
        as *const libc::c_char,
    b"     Options:\0" as *const u8 as *const libc::c_char,
    b"        --append        Use appendvfs to append database to the end of FILE\0"
        as *const u8 as *const libc::c_char,
    b"        --deserialize   Load into memory using sqlite3_deserialize()\0"
        as *const u8 as *const libc::c_char,
    b"        --hexdb         Load the output of \"dbtotxt\" as an in-memory db\0"
        as *const u8 as *const libc::c_char,
    b"        --maxsize N     Maximum size for --hexdb or --deserialized database\0"
        as *const u8 as *const libc::c_char,
    b"        --new           Initialize FILE to an empty database\0" as *const u8
        as *const libc::c_char,
    b"        --nofollow      Do not follow symbolic links\0" as *const u8
        as *const libc::c_char,
    b"        --readonly      Open FILE readonly\0" as *const u8 as *const libc::c_char,
    b"        --zip           FILE is a ZIP archive\0" as *const u8
        as *const libc::c_char,
    b".output ?FILE?           Send output to FILE or stdout if FILE is omitted\0"
        as *const u8 as *const libc::c_char,
    b"   If FILE begins with '|' then open it as a pipe.\0" as *const u8
        as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"     --bom                 Prefix output with a UTF8 byte-order mark\0"
        as *const u8 as *const libc::c_char,
    b"     -e                    Send output to the system text editor\0" as *const u8
        as *const libc::c_char,
    b"     -x                    Send output as CSV to a spreadsheet\0" as *const u8
        as *const libc::c_char,
    b".parameter CMD ...       Manage SQL parameter bindings\0" as *const u8
        as *const libc::c_char,
    b"   clear                   Erase all bindings\0" as *const u8
        as *const libc::c_char,
    b"   init                    Initialize the TEMP table that holds bindings\0"
        as *const u8 as *const libc::c_char,
    b"   list                    List the current parameter bindings\0" as *const u8
        as *const libc::c_char,
    b"   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE\0"
        as *const u8 as *const libc::c_char,
    b"                           PARAMETER should start with one of: $ : @ ?\0"
        as *const u8 as *const libc::c_char,
    b"   unset PARAMETER         Remove PARAMETER from the binding table\0" as *const u8
        as *const libc::c_char,
    b".print STRING...         Print literal STRING\0" as *const u8
        as *const libc::c_char,
    b".progress N              Invoke progress handler after every N opcodes\0"
        as *const u8 as *const libc::c_char,
    b"   --limit N                 Interrupt after N progress callbacks\0" as *const u8
        as *const libc::c_char,
    b"   --once                    Do no more than one progress interrupt\0" as *const u8
        as *const libc::c_char,
    b"   --quiet|-q                No output except at interrupts\0" as *const u8
        as *const libc::c_char,
    b"   --reset                   Reset the count for each input and interrupt\0"
        as *const u8 as *const libc::c_char,
    b".prompt MAIN CONTINUE    Replace the standard prompts\0" as *const u8
        as *const libc::c_char,
    b".quit                    Stop interpreting input stream, exit if primary.\0"
        as *const u8 as *const libc::c_char,
    b".read FILE               Read input from FILE or command output\0" as *const u8
        as *const libc::c_char,
    b"    If FILE begins with \"|\", it is a command that generates the input.\0"
        as *const u8 as *const libc::c_char,
    b".recover                 Recover as much data as possible from corrupt db.\0"
        as *const u8 as *const libc::c_char,
    b"   --ignore-freelist        Ignore pages that appear to be on db freelist\0"
        as *const u8 as *const libc::c_char,
    b"   --lost-and-found TABLE   Alternative name for the lost-and-found table\0"
        as *const u8 as *const libc::c_char,
    b"   --no-rowids              Do not attempt to recover rowid values\0" as *const u8
        as *const libc::c_char,
    b"                            that are not also INTEGER PRIMARY KEYs\0" as *const u8
        as *const libc::c_char,
    b".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE\0"
        as *const u8 as *const libc::c_char,
    b".save ?OPTIONS? FILE     Write database to FILE (an alias for .backup ...)\0"
        as *const u8 as *const libc::c_char,
    b".scanstats on|off|est    Turn sqlite3_stmt_scanstatus() metrics on or off\0"
        as *const u8 as *const libc::c_char,
    b".schema ?PATTERN?        Show the CREATE statements matching PATTERN\0"
        as *const u8 as *const libc::c_char,
    b"   Options:\0" as *const u8 as *const libc::c_char,
    b"      --indent             Try to pretty-print the schema\0" as *const u8
        as *const libc::c_char,
    b"      --nosys              Omit objects whose names start with \"sqlite_\"\0"
        as *const u8 as *const libc::c_char,
    b",selftest ?OPTIONS?      Run tests defined in the SELFTEST table\0" as *const u8
        as *const libc::c_char,
    b"    Options:\0" as *const u8 as *const libc::c_char,
    b"       --init               Create a new SELFTEST table\0" as *const u8
        as *const libc::c_char,
    b"       -v                   Verbose output\0" as *const u8 as *const libc::c_char,
    b".separator COL ?ROW?     Change the column and row separators\0" as *const u8
        as *const libc::c_char,
    b".sha3sum ...             Compute a SHA3 hash of database content\0" as *const u8
        as *const libc::c_char,
    b"    Options:\0" as *const u8 as *const libc::c_char,
    b"      --schema              Also hash the sqlite_schema table\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-224            Use the sha3-224 algorithm\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-256            Use the sha3-256 algorithm (default)\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-384            Use the sha3-384 algorithm\0" as *const u8
        as *const libc::c_char,
    b"      --sha3-512            Use the sha3-512 algorithm\0" as *const u8
        as *const libc::c_char,
    b"    Any other argument is a LIKE pattern for tables to hash\0" as *const u8
        as *const libc::c_char,
    b".shell CMD ARGS...       Run CMD ARGS... in a system shell\0" as *const u8
        as *const libc::c_char,
    b".show                    Show the current values for various settings\0"
        as *const u8 as *const libc::c_char,
    b".stats ?ARG?             Show stats or turn stats on or off\0" as *const u8
        as *const libc::c_char,
    b"   off                      Turn off automatic stat display\0" as *const u8
        as *const libc::c_char,
    b"   on                       Turn on automatic stat display\0" as *const u8
        as *const libc::c_char,
    b"   stmt                     Show statement stats\0" as *const u8
        as *const libc::c_char,
    b"   vmstep                   Show the virtual machine step count only\0"
        as *const u8 as *const libc::c_char,
    b".system CMD ARGS...      Run CMD ARGS... in a system shell\0" as *const u8
        as *const libc::c_char,
    b".tables ?TABLE?          List names of tables matching LIKE pattern TABLE\0"
        as *const u8 as *const libc::c_char,
    b",testcase NAME           Begin redirecting output to 'testcase-out.txt'\0"
        as *const u8 as *const libc::c_char,
    b",testctrl CMD ...        Run various sqlite3_test_control() operations\0"
        as *const u8 as *const libc::c_char,
    b"                           Run \".testctrl\" with no arguments for details\0"
        as *const u8 as *const libc::c_char,
    b".timeout MS              Try opening locked tables for MS milliseconds\0"
        as *const u8 as *const libc::c_char,
    b".timer on|off            Turn SQL timer on or off\0" as *const u8
        as *const libc::c_char,
    b".trace ?OPTIONS?         Output each SQL statement as it is run\0" as *const u8
        as *const libc::c_char,
    b"    FILE                    Send output to FILE\0" as *const u8
        as *const libc::c_char,
    b"    stdout                  Send output to stdout\0" as *const u8
        as *const libc::c_char,
    b"    stderr                  Send output to stderr\0" as *const u8
        as *const libc::c_char,
    b"    off                     Disable tracing\0" as *const u8 as *const libc::c_char,
    b"    --expanded              Expand query parameters\0" as *const u8
        as *const libc::c_char,
    b"    --plain                 Show SQL as it is input\0" as *const u8
        as *const libc::c_char,
    b"    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)\0"
        as *const u8 as *const libc::c_char,
    b"    --profile               Profile statements (SQLITE_TRACE_PROFILE)\0"
        as *const u8 as *const libc::c_char,
    b"    --row                   Trace each row (SQLITE_TRACE_ROW)\0" as *const u8
        as *const libc::c_char,
    b"    --close                 Trace connection close (SQLITE_TRACE_CLOSE)\0"
        as *const u8 as *const libc::c_char,
    b".version                 Show source, library and compiler versions\0" as *const u8
        as *const libc::c_char,
    b".vfsinfo ?AUX?           Information about the top-level VFS\0" as *const u8
        as *const libc::c_char,
    b".vfslist                 List all available VFSes\0" as *const u8
        as *const libc::c_char,
    b".vfsname ?AUX?           Print the name of the VFS stack\0" as *const u8
        as *const libc::c_char,
    b".width NUM1 NUM2 ...     Set minimum column widths for columnar output\0"
        as *const u8 as *const libc::c_char,
    b"     Negative values right-justify\0" as *const u8 as *const libc::c_char,
];
unsafe extern "C" fn showHelp(
    out: *mut FILE,
    zPattern: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut zPat: *mut libc::c_char = 0 as *mut libc::c_char;
    if zPattern.is_null()
        || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        || cli_strcmp(zPattern, b"-a\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        || cli_strcmp(zPattern, b"-all\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        || cli_strcmp(zPattern, b"--all\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        let mut hw: HelpWanted = HW_SummaryOnly;
        let mut hh: HelpHave = HH_More;
        if !zPattern.is_null() {
            hw = (if *zPattern as libc::c_int == '0' as i32 {
                HW_NoCull as libc::c_int | HW_Undoc as libc::c_int
            } else {
                HW_NoCull as libc::c_int
            }) as HelpWanted;
        }
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 202]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            match *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
            {
                44 => {
                    hh = (HH_Summary as libc::c_int | HH_Undoc as libc::c_int)
                        as HelpHave;
                }
                46 => {
                    hh = HH_Summary;
                }
                _ => {
                    hh = ::core::mem::transmute::<
                        libc::c_uint,
                        HelpHave,
                    >(hh as libc::c_uint & !(HH_Summary as libc::c_int) as libc::c_uint);
                }
            }
            if (hw as libc::c_uint ^ hh as libc::c_uint)
                & HH_Undoc as libc::c_int as libc::c_uint
                == 0 as libc::c_int as libc::c_uint
            {
                if hh as libc::c_uint & HH_Summary as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        out,
                        b".%s\n\0" as *const u8 as *const libc::c_char,
                        (azHelp[i as usize]).offset(1 as libc::c_int as isize),
                    );
                    n += 1;
                    n;
                } else if hw as libc::c_uint
                    & HW_SummaryOnly as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[i as usize],
                    );
                }
            }
            i += 1;
            i;
        }
    } else {
        zPat = sqlite3_mprintf(b".%s*\0" as *const u8 as *const libc::c_char, zPattern);
        shell_check_oom(zPat as *const libc::c_void);
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 202]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if sqlite3_strglob(zPat, azHelp[i as usize]) == 0 as libc::c_int {
                fprintf(
                    out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                j = i + 1 as libc::c_int;
                n += 1;
                n;
            }
            i += 1;
            i;
        }
        sqlite3_free(zPat as *mut libc::c_void);
        if n != 0 {
            if n == 1 as libc::c_int {
                while j
                    < (::core::mem::size_of::<[*const libc::c_char; 202]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        ) as libc::c_int - 1 as libc::c_int
                    && *(azHelp[j as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_int == ' ' as i32
                {
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                    j += 1;
                    j;
                }
            }
            return n;
        }
        zPat = sqlite3_mprintf(
            b"%%%s%%\0" as *const u8 as *const libc::c_char,
            zPattern,
        );
        shell_check_oom(zPat as *const libc::c_void);
        i = 0 as libc::c_int;
        while i
            < (::core::mem::size_of::<[*const libc::c_char; 202]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*const libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {
            if *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == ',' as i32
            {
                while i
                    < (::core::mem::size_of::<[*const libc::c_char; 202]>()
                        as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<*const libc::c_char>()
                                as libc::c_ulong,
                        ) as libc::c_int - 1 as libc::c_int
                    && *(azHelp[(i + 1 as libc::c_int) as usize])
                        .offset(0 as libc::c_int as isize) as libc::c_int == ' ' as i32
                {
                    i += 1;
                    i;
                }
            } else {
                if *(azHelp[i as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                    == '.' as i32
                {
                    j = i;
                }
                if sqlite3_strlike(
                    zPat,
                    azHelp[i as usize],
                    0 as libc::c_int as libc::c_uint,
                ) == 0 as libc::c_int
                {
                    fprintf(
                        out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                    while j
                        < (::core::mem::size_of::<[*const libc::c_char; 202]>()
                            as libc::c_ulong)
                            .wrapping_div(
                                ::core::mem::size_of::<*const libc::c_char>()
                                    as libc::c_ulong,
                            ) as libc::c_int - 1 as libc::c_int
                        && *(azHelp[(j + 1 as libc::c_int) as usize])
                            .offset(0 as libc::c_int as isize) as libc::c_int
                            == ' ' as i32
                    {
                        j += 1;
                        j;
                        fprintf(
                            out,
                            b"%s\n\0" as *const u8 as *const libc::c_char,
                            azHelp[j as usize],
                        );
                    }
                    i = j;
                    n += 1;
                    n;
                }
            }
            i += 1;
            i;
        }
        sqlite3_free(zPat as *mut libc::c_void);
    }
    return n;
}
unsafe extern "C" fn readFile(
    zName: *const libc::c_char,
    pnByte: *mut libc::c_int,
) -> *mut libc::c_char {
    let in_0: *mut FILE = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    let mut nIn: libc::c_long = 0;
    let mut nRead: size_t = 0;
    let mut pBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    if in_0.is_null() {
        return 0 as *mut libc::c_char;
    }
    rc = fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
    if rc != 0 as libc::c_int {
        fprintf(
            stderr,
            b"Error: '%s' not seekable\n\0" as *const u8 as *const libc::c_char,
            zName,
        );
        fclose(in_0);
        return 0 as *mut libc::c_char;
    }
    nIn = ftell(in_0);
    rewind(in_0);
    pBuf = sqlite3_malloc64((nIn + 1 as libc::c_int as libc::c_long) as sqlite3_uint64)
        as *mut libc::c_char;
    if pBuf.is_null() {
        fprintf(stderr, b"Error: out of memory\n\0" as *const u8 as *const libc::c_char);
        fclose(in_0);
        return 0 as *mut libc::c_char;
    }
    nRead = fread(
        pBuf as *mut libc::c_void,
        nIn as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        in_0,
    );
    fclose(in_0);
    if nRead != 1 as libc::c_int as libc::c_ulong {
        sqlite3_free(pBuf as *mut libc::c_void);
        fprintf(
            stderr,
            b"Error: cannot read '%s'\n\0" as *const u8 as *const libc::c_char,
            zName,
        );
        return 0 as *mut libc::c_char;
    }
    *pBuf.offset(nIn as isize) = 0 as libc::c_int as libc::c_char;
    if !pnByte.is_null() {
        *pnByte = nIn as libc::c_int;
    }
    return pBuf;
}
#[no_mangle]
pub unsafe extern "C" fn deduceDatabaseType(
    zName: *const libc::c_char,
    dfltZip: libc::c_int,
) -> libc::c_int {
    let f: *mut FILE = fopen(zName, b"rb\0" as *const u8 as *const libc::c_char);
    let mut n: size_t = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zBuf: [libc::c_char; 100] = [0; 100];
    if f.is_null() {
        if dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\0" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            return 3 as libc::c_int
        } else {
            return 1 as libc::c_int
        }
    }
    n = fread(
        zBuf.as_mut_ptr() as *mut libc::c_void,
        16 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        f,
    );
    if n == 1 as libc::c_int as libc::c_ulong
        && memcmp(
            zBuf.as_mut_ptr() as *const libc::c_void,
            b"SQLite format 3\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
            16 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        fclose(f);
        return 1 as libc::c_int;
    }
    fseek(f, -(25 as libc::c_int) as libc::c_long, 2 as libc::c_int);
    n = fread(
        zBuf.as_mut_ptr() as *mut libc::c_void,
        25 as libc::c_int as libc::c_ulong,
        1 as libc::c_int as libc::c_ulong,
        f,
    );
    if n == 1 as libc::c_int as libc::c_ulong
        && memcmp(
            zBuf.as_mut_ptr() as *const libc::c_void,
            b"Start-Of-SQLite3-\0" as *const u8 as *const libc::c_char
                as *const libc::c_void,
            17 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        rc = 2 as libc::c_int;
    } else {
        fseek(f, -(22 as libc::c_int) as libc::c_long, 2 as libc::c_int);
        n = fread(
            zBuf.as_mut_ptr() as *mut libc::c_void,
            22 as libc::c_int as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            f,
        );
        if n == 1 as libc::c_int as libc::c_ulong
            && zBuf[0 as libc::c_int as usize] as libc::c_int == 0x50 as libc::c_int
            && zBuf[1 as libc::c_int as usize] as libc::c_int == 0x4b as libc::c_int
            && zBuf[2 as libc::c_int as usize] as libc::c_int == 0x5 as libc::c_int
            && zBuf[3 as libc::c_int as usize] as libc::c_int == 0x6 as libc::c_int
        {
            rc = 3 as libc::c_int;
        } else if n == 0 as libc::c_int as libc::c_ulong && dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\0" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            rc = 3 as libc::c_int;
        }
    }
    fclose(f);
    return rc;
}
unsafe extern "C" fn readHexDb(
    p: *mut ShellState,
    pnData: *mut libc::c_int,
) -> *mut libc::c_uchar {
    let mut a: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    let mut nLine: libc::c_int = 0;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pgsz: libc::c_int = 0 as libc::c_int;
    let mut iOffset: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
    let mut x: [libc::c_uint; 16] = [0; 16];
    let mut zLine: [libc::c_char; 1000] = [0; 1000];
    if !zDbFilename.is_null() {
        in_0 = fopen(zDbFilename, b"r\0" as *const u8 as *const libc::c_char);
        if in_0.is_null() {
            fprintf(
                stderr,
                b"cannot open \"%s\" for reading\n\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
            );
            return 0 as *mut libc::c_uchar;
        }
        nLine = 0 as libc::c_int;
    } else {
        in_0 = (*p).in_0;
        nLine = (*p).lineno;
        if in_0.is_null() {
            in_0 = stdin;
        }
    }
    *pnData = 0 as libc::c_int;
    nLine += 1;
    nLine;
    if !(fgets(
        zLine.as_mut_ptr(),
        ::core::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong as libc::c_int,
        in_0,
    ))
        .is_null()
    {
        rc = sscanf(
            zLine.as_mut_ptr(),
            b"| size %d pagesize %d\0" as *const u8 as *const libc::c_char,
            &mut n as *mut libc::c_int,
            &mut pgsz as *mut libc::c_int,
        );
        if !(rc != 2 as libc::c_int) {
            if !(n < 0 as libc::c_int) {
                if !(pgsz < 512 as libc::c_int || pgsz > 65536 as libc::c_int
                    || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int)
                {
                    n = n + pgsz - 1 as libc::c_int & !(pgsz - 1 as libc::c_int);
                    a = sqlite3_malloc(if n != 0 { n } else { 1 as libc::c_int })
                        as *mut libc::c_uchar;
                    shell_check_oom(a as *const libc::c_void);
                    memset(a as *mut libc::c_void, 0 as libc::c_int, n as libc::c_ulong);
                    if pgsz < 512 as libc::c_int || pgsz > 65536 as libc::c_int
                        || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"invalid pagesize\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        nLine += 1;
                        nLine;
                        while !(fgets(
                            zLine.as_mut_ptr(),
                            ::core::mem::size_of::<[libc::c_char; 1000]>()
                                as libc::c_ulong as libc::c_int,
                            in_0,
                        ))
                            .is_null()
                        {
                            rc = sscanf(
                                zLine.as_mut_ptr(),
                                b"| page %d offset %d\0" as *const u8
                                    as *const libc::c_char,
                                &mut j as *mut libc::c_int,
                                &mut k as *mut libc::c_int,
                            );
                            if rc == 2 as libc::c_int {
                                iOffset = k;
                            } else {
                                if cli_strncmp(
                                    zLine.as_mut_ptr(),
                                    b"| end \0" as *const u8 as *const libc::c_char,
                                    6 as libc::c_int as size_t,
                                ) == 0 as libc::c_int
                                {
                                    break;
                                }
                                rc = sscanf(
                                    zLine.as_mut_ptr(),
                                    b"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\0"
                                        as *const u8 as *const libc::c_char,
                                    &mut j as *mut libc::c_int,
                                    &mut *x.as_mut_ptr().offset(0 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(1 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(2 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(3 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(4 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(5 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(6 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(7 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(8 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(9 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(10 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(11 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(12 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(13 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(14 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                    &mut *x.as_mut_ptr().offset(15 as libc::c_int as isize)
                                        as *mut libc::c_uint,
                                );
                                if rc == 17 as libc::c_int {
                                    k = iOffset + j;
                                    if k + 16 as libc::c_int <= n && k >= 0 as libc::c_int {
                                        let mut ii: libc::c_int = 0;
                                        ii = 0 as libc::c_int;
                                        while ii < 16 as libc::c_int {
                                            *a
                                                .offset(
                                                    (k + ii) as isize,
                                                ) = (x[ii as usize] & 0xff as libc::c_int as libc::c_uint)
                                                as libc::c_uchar;
                                            ii += 1;
                                            ii;
                                        }
                                    }
                                }
                            }
                            nLine += 1;
                            nLine;
                        }
                        *pnData = n;
                        if in_0 != (*p).in_0 {
                            fclose(in_0);
                        } else {
                            (*p).lineno = nLine;
                        }
                        return a;
                    }
                }
            }
        }
    }
    if in_0 != (*p).in_0 {
        fclose(in_0);
    } else {
        while !(fgets(
            zLine.as_mut_ptr(),
            ::core::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong
                as libc::c_int,
            (*p).in_0,
        ))
            .is_null()
        {
            nLine += 1;
            nLine;
            if cli_strncmp(
                zLine.as_mut_ptr(),
                b"| end \0" as *const u8 as *const libc::c_char,
                6 as libc::c_int as size_t,
            ) == 0 as libc::c_int
            {
                break;
            }
        }
        (*p).lineno = nLine;
    }
    sqlite3_free(a as *mut libc::c_void);
    fprintf(
        stderr,
        b"Error on line %d of --hexdb input\n\0" as *const u8 as *const libc::c_char,
        nLine,
    );
    return 0 as *mut libc::c_uchar;
}
unsafe extern "C" fn shellUSleepFunc(
    context: *mut sqlite3_context,
    _argcUnused: libc::c_int,
    argv: *mut *mut sqlite3_value,
) {
    let sleep: libc::c_int = sqlite3_value_int(
        *argv.offset(0 as libc::c_int as isize),
    );
    sqlite3_sleep(sleep / 1000 as libc::c_int);
    sqlite3_result_int(context, sleep);
}
unsafe extern "C" fn open_db(p: *mut ShellState, openFlags: libc::c_int) {
    if ((*p).db).is_null() {
        let zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
        if (*p).openMode as libc::c_int == 0 as libc::c_int {
            if zDbFilename.is_null()
                || *zDbFilename.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
            {
                (*p).openMode = 1 as libc::c_int as u8_0;
            } else {
                (*p)
                    .openMode = deduceDatabaseType(
                    zDbFilename,
                    (openFlags & 0x2 as libc::c_int != 0 as libc::c_int) as libc::c_int,
                ) as u8_0;
            }
        }
        match (*p).openMode as libc::c_int {
            2 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    b"apndvfs\0" as *const u8 as *const libc::c_char,
                );
            }
            6 | 5 => {
                sqlite3_open(0 as *const libc::c_char, &mut (*p).db);
            }
            3 => {
                sqlite3_open(
                    b":memory:\0" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
            }
            4 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x1 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            0 | 1 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            _ => {}
        }
        globalDb = (*p).db;
        if ((*p).db).is_null() || 0 as libc::c_int != sqlite3_errcode((*p).db) {
            fprintf(
                stderr,
                b"Error: unable to open database \"%s\": %s\n\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
                sqlite3_errmsg((*p).db),
            );
            if openFlags & 0x1 as libc::c_int == 0 as libc::c_int {
                exit(1 as libc::c_int);
            }
            sqlite3_close((*p).db);
            sqlite3_open(
                b":memory:\0" as *const u8 as *const libc::c_char,
                &mut (*p).db,
            );
            if ((*p).db).is_null() || 0 as libc::c_int != sqlite3_errcode((*p).db) {
                fprintf(
                    stderr,
                    b"Also: unable to open substitute in-memory database.\n\0"
                        as *const u8 as *const libc::c_char,
                );
                exit(1 as libc::c_int);
            } else {
                fprintf(
                    stderr,
                    b"Notice: using substitute in-memory database instead of \"%s\"\n\0"
                        as *const u8 as *const libc::c_char,
                    zDbFilename,
                );
            }
        }
        sqlite3_db_config(
            (*p).db,
            1018 as libc::c_int,
            0 as libc::c_int,
            0 as *mut libc::c_int,
        );
        let testmode_on: libc::c_int = ((*p).shellFlgs
            & 0x400 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint)
            as libc::c_int;
        sqlite3_db_config((*p).db, 1017 as libc::c_int, testmode_on, 0 as libc::c_int);
        sqlite3_db_config(
            (*p).db,
            1010 as libc::c_int,
            (testmode_on == 0) as libc::c_int,
            0 as libc::c_int,
        );
        sqlite3_enable_load_extension((*p).db, 1 as libc::c_int);
        sqlite3_shathree_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_uint_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_decimal_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_base64_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_base85_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_regexp_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_ieee_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_series_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_fileio_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        sqlite3_completion_init(
            (*p).db,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        if (*p).bSafeModePersist == 0 {
            sqlite3_zipfile_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_sqlar_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
        }
        sqlite3_create_function(
            (*p).db,
            b"strtod\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellStrtod
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"dtostr\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellDtostr
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"dtostr\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellDtostr
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_add_schema\0" as *const u8 as *const libc::c_char,
            3 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellAddSchemaName
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_module_schema\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellModuleSchema
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"shell_putsnl\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            p as *mut libc::c_void,
            Some(
                shellPutsFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"usleep\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                shellUSleepFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"edit\0" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                editFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        sqlite3_create_function(
            (*p).db,
            b"edit\0" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                editFunc
                    as unsafe extern "C" fn(
                        *mut sqlite3_context,
                        libc::c_int,
                        *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        );
        if (*p).openMode as libc::c_int == 3 as libc::c_int {
            let zSql: *mut libc::c_char = sqlite3_mprintf(
                b"CREATE VIRTUAL TABLE zip USING zipfile(%Q);\0" as *const u8
                    as *const libc::c_char,
                zDbFilename,
            );
            shell_check_oom(zSql as *const libc::c_void);
            sqlite3_exec(
                (*p).db,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql as *mut libc::c_void);
        } else if (*p).openMode as libc::c_int == 5 as libc::c_int
            || (*p).openMode as libc::c_int == 6 as libc::c_int
        {
            let mut rc: libc::c_int = 0;
            let mut nData: libc::c_int = 0 as libc::c_int;
            let mut aData: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
            if (*p).openMode as libc::c_int == 5 as libc::c_int {
                aData = readFile(zDbFilename, &mut nData) as *mut libc::c_uchar;
            } else {
                aData = readHexDb(p, &mut nData);
            }
            if aData.is_null() {
                return;
            }
            rc = sqlite3_deserialize(
                (*p).db,
                b"main\0" as *const u8 as *const libc::c_char,
                aData,
                nData as sqlite3_int64,
                nData as sqlite3_int64,
                (2 as libc::c_int | 1 as libc::c_int) as libc::c_uint,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: sqlite3_deserialize() returns %d\n\0" as *const u8
                        as *const libc::c_char,
                    rc,
                );
            }
            if (*p).szMax > 0 as libc::c_int as libc::c_longlong {
                sqlite3_file_control(
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    36 as libc::c_int,
                    &mut (*p).szMax as *mut sqlite3_int64 as *mut libc::c_void,
                );
            }
        }
    }
    if !((*p).db).is_null() {
        if (*p).bSafeModePersist != 0 {
            sqlite3_set_authorizer(
                (*p).db,
                Some(
                    safeModeAuth
                        as unsafe extern "C" fn(
                            *mut libc::c_void,
                            libc::c_int,
                            *const libc::c_char,
                            *const libc::c_char,
                            *const libc::c_char,
                            *const libc::c_char,
                        ) -> libc::c_int,
                ),
                p as *mut libc::c_void,
            );
        }
        sqlite3_db_config(
            (*p).db,
            1018 as libc::c_int,
            (*p).scanstatsOn as libc::c_int,
            0 as *mut libc::c_int,
        );
    }
}
#[no_mangle]
pub unsafe extern "C" fn close_db(db: *mut sqlite3) {
    let rc: libc::c_int = sqlite3_close(db);
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: sqlite3_close() returns %d: %s\n\0" as *const u8
                as *const libc::c_char,
            rc,
            sqlite3_errmsg(db),
        );
    }
}
unsafe extern "C" fn readline_completion_generator(
    text: *const libc::c_char,
    state: libc::c_int,
) -> *mut libc::c_char {
    static mut pStmt: *mut sqlite3_stmt = 0 as *const sqlite3_stmt as *mut sqlite3_stmt;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    if state == 0 as libc::c_int {
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        sqlite3_finalize(pStmt);
        zSql = sqlite3_mprintf(
            b"SELECT DISTINCT candidate COLLATE nocase  FROM completion(%Q) ORDER BY 1\0"
                as *const u8 as *const libc::c_char,
            text,
        );
        shell_check_oom(zSql as *const libc::c_void);
        sqlite3_prepare_v2(
            globalDb,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
    }
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        let z: *const libc::c_char = sqlite3_column_text(pStmt, 0 as libc::c_int)
            as *const libc::c_char;
        zRet = if !z.is_null() { strdup(z) } else { 0 as *mut libc::c_char };
    } else {
        sqlite3_finalize(pStmt);
        pStmt = 0 as *mut sqlite3_stmt;
        zRet = 0 as *mut libc::c_char;
    }
    return zRet;
}
unsafe extern "C" fn readline_completion(
    zText: *const libc::c_char,
    _iStart: libc::c_int,
    _iEnd: libc::c_int,
) -> *mut *mut libc::c_char {
    rl_attempted_completion_over = 1 as libc::c_int;
    return rl_completion_matches(
        zText,
        Some(
            readline_completion_generator
                as unsafe extern "C" fn(
                    *const libc::c_char,
                    libc::c_int,
                ) -> *mut libc::c_char,
        ),
    );
}
unsafe extern "C" fn resolve_backslashes(mut z: *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    while *z as libc::c_int != 0 && *z as libc::c_int != '\\' as i32 {
        z = z.offset(1);
        z;
    }
    j = 0 as libc::c_int;
    i = j;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int) {
            break;
        }
        if c as libc::c_int == '\\' as i32
            && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                != 0 as libc::c_int
        {
            i += 1;
            c = *z.offset(i as isize);
            if c as libc::c_int == 'a' as i32 {
                c = '\u{7}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'b' as i32 {
                c = '\u{8}' as i32 as libc::c_char;
            } else if c as libc::c_int == 't' as i32 {
                c = '\t' as i32 as libc::c_char;
            } else if c as libc::c_int == 'n' as i32 {
                c = '\n' as i32 as libc::c_char;
            } else if c as libc::c_int == 'v' as i32 {
                c = '\u{b}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'f' as i32 {
                c = '\u{c}' as i32 as libc::c_char;
            } else if c as libc::c_int == 'r' as i32 {
                c = '\r' as i32 as libc::c_char;
            } else if c as libc::c_int == '"' as i32 {
                c = '"' as i32 as libc::c_char;
            } else if c as libc::c_int == '\'' as i32 {
                c = '\'' as i32 as libc::c_char;
            } else if c as libc::c_int == '\\' as i32 {
                c = '\\' as i32 as libc::c_char;
            } else if c as libc::c_int == 'x' as i32 {
                let mut nhd: libc::c_int = 0 as libc::c_int;
                let mut hdv: libc::c_int = 0;
                let mut hv: u8_0 = 0 as libc::c_int as u8_0;
                while nhd < 2 as libc::c_int
                    && {
                        c = *z.offset((i + 1 as libc::c_int + nhd) as isize);
                        c as libc::c_int != 0 as libc::c_int
                    }
                    && {
                        hdv = hexDigitValue(c);
                        hdv >= 0 as libc::c_int
                    }
                {
                    hv = ((hv as libc::c_int) << 4 as libc::c_int | hdv) as u8_0;
                    nhd += 1;
                    nhd;
                }
                i += nhd;
                c = hv as libc::c_char;
            } else if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '7' as i32 {
                c = (c as libc::c_int - '0' as i32) as libc::c_char;
                if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    >= '0' as i32
                    && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        <= '7' as i32
                {
                    i += 1;
                    i;
                    c = (((c as libc::c_int) << 3 as libc::c_int)
                        + *z.offset(i as isize) as libc::c_int - '0' as i32)
                        as libc::c_char;
                    if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                        >= '0' as i32
                        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                            <= '7' as i32
                    {
                        i += 1;
                        i;
                        c = (((c as libc::c_int) << 3 as libc::c_int)
                            + *z.offset(i as isize) as libc::c_int - '0' as i32)
                            as libc::c_char;
                    }
                }
            }
        }
        *z.offset(j as isize) = c;
        i += 1;
        i;
        j += 1;
        j;
    }
    if j < i {
        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
    }
}
unsafe extern "C" fn booleanValue(zArg: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        i = 2 as libc::c_int;
        while hexDigitValue(*zArg.offset(i as isize)) >= 0 as libc::c_int {
            i += 1;
            i;
        }
    } else {
        i = 0 as libc::c_int;
        while *zArg.offset(i as isize) as libc::c_int >= '0' as i32
            && *zArg.offset(i as isize) as libc::c_int <= '9' as i32
        {
            i += 1;
            i;
        }
    }
    if i > 0 as libc::c_int
        && *zArg.offset(i as isize) as libc::c_int == 0 as libc::c_int
    {
        return (integerValue(zArg) & 0xffffffff as libc::c_uint as libc::c_longlong)
            as libc::c_int;
    }
    if sqlite3_stricmp(zArg, b"on\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"yes\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        return 1 as libc::c_int;
    }
    if sqlite3_stricmp(zArg, b"off\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"no\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    }
    fprintf(
        stderr,
        b"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n\0" as *const u8
            as *const libc::c_char,
        zArg,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn setOrClearFlag(
    p: *mut ShellState,
    mFlag: libc::c_uint,
    zArg: *const libc::c_char,
) {
    if booleanValue(zArg) != 0 {
        (*p).shellFlgs |= mFlag;
    } else {
        (*p).shellFlgs &= !mFlag;
    };
}
unsafe extern "C" fn output_file_close(f: *mut FILE) {
    if !f.is_null() && f != stdout && f != stderr {
        fclose(f);
    }
}
unsafe extern "C" fn output_file_open(
    zFile: *const libc::c_char,
    bTextMode: libc::c_int,
) -> *mut FILE {
    let mut f: *mut FILE = 0 as *mut FILE;
    if cli_strcmp(zFile, b"stdout\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = stdout;
    } else if cli_strcmp(zFile, b"stderr\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = stderr;
    } else if cli_strcmp(zFile, b"off\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        f = 0 as *mut FILE;
    } else {
        f = fopen(
            zFile,
            if bTextMode != 0 {
                b"w\0" as *const u8 as *const libc::c_char
            } else {
                b"wb\0" as *const u8 as *const libc::c_char
            },
        );
        if f.is_null() {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
    return f;
}
unsafe extern "C" fn sql_trace_callback(
    mType: libc::c_uint,
    pArg: *mut libc::c_void,
    pP: *mut libc::c_void,
    pX: *mut libc::c_void,
) -> libc::c_int {
    let p: *mut ShellState = pArg as *mut ShellState;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut nSql: i64_0 = 0;
    if ((*p).traceOut).is_null() {
        return 0 as libc::c_int;
    }
    if mType == 0x8 as libc::c_int as libc::c_uint {
        fprintf(
            (*p).traceOut,
            b"-- closing database connection\n\0" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    }
    if mType != 0x4 as libc::c_int as libc::c_uint && !pX.is_null()
        && *(pX as *const libc::c_char).offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
    {
        zSql = pX as *const libc::c_char;
    } else {
        pStmt = pP as *mut sqlite3_stmt;
        match (*p).eTraceType as libc::c_int {
            1 => {
                zSql = sqlite3_expanded_sql(pStmt);
            }
            _ => {
                zSql = sqlite3_sql(pStmt);
            }
        }
    }
    if zSql.is_null() {
        return 0 as libc::c_int;
    }
    nSql = strlen(zSql) as i64_0;
    if nSql > 1000000000 as libc::c_int as libc::c_longlong {
        nSql = 1000000000 as libc::c_int as i64_0;
    }
    while nSql > 0 as libc::c_int as libc::c_longlong
        && *zSql.offset((nSql - 1 as libc::c_int as libc::c_longlong) as isize)
            as libc::c_int == ';' as i32
    {
        nSql -= 1;
        nSql;
    }
    match mType {
        4 | 1 => {
            fprintf(
                (*p).traceOut,
                b"%.*s;\n\0" as *const u8 as *const libc::c_char,
                nSql as libc::c_int,
                zSql,
            );
        }
        2 => {
            let nNanosec: sqlite3_int64 = if !pX.is_null() {
                *(pX as *mut sqlite3_int64)
            } else {
                0 as libc::c_int as libc::c_longlong
            };
            fprintf(
                (*p).traceOut,
                b"%.*s; -- %lld ns\n\0" as *const u8 as *const libc::c_char,
                nSql as libc::c_int,
                zSql,
                nNanosec,
            );
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn test_breakpoint() {
    static mut nCall: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let fresh96 = nCall;
    nCall = nCall.wrapping_add(1);
    if fresh96 == 0xffffffff as libc::c_uint {
        printf(b"Many .breakpoints have run\n\0" as *const u8 as *const libc::c_char);
    }
}
unsafe extern "C" fn import_cleanup(p: *mut ImportCtx) {
    if !((*p).in_0).is_null() && ((*p).xCloser).is_some() {
        ((*p).xCloser).expect("non-null function pointer")((*p).in_0);
        (*p).in_0 = 0 as *mut FILE;
    }
    sqlite3_free((*p).z as *mut libc::c_void);
    (*p).z = 0 as *mut libc::c_char;
}
unsafe extern "C" fn import_append_char(p: *mut ImportCtx, c: libc::c_int) {
    if (*p).n + 1 as libc::c_int >= (*p).nAlloc {
        (*p).nAlloc += (*p).nAlloc + 100 as libc::c_int;
        (*p)
            .z = sqlite3_realloc64(
            (*p).z as *mut libc::c_void,
            (*p).nAlloc as sqlite3_uint64,
        ) as *mut libc::c_char;
        shell_check_oom((*p).z as *const libc::c_void);
    }
    let fresh97 = (*p).n;
    (*p).n = (*p).n + 1;
    *((*p).z).offset(fresh97 as isize) = c as libc::c_char;
}
unsafe extern "C" fn csv_read_one_field(p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let cSep: libc::c_int = (*p).cColSep as u8_0 as libc::c_int;
    let rSep: libc::c_int = (*p).cRowSep as u8_0 as libc::c_int;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    }
    if c == '"' as i32 {
        let mut pc: libc::c_int = 0;
        let mut ppc: libc::c_int = 0;
        let startLine: libc::c_int = (*p).nLine;
        let cQuote: libc::c_int = c;
        ppc = 0 as libc::c_int;
        pc = ppc;
        loop {
            c = fgetc((*p).in_0);
            if c == rSep {
                (*p).nLine += 1;
                (*p).nLine;
            }
            if c == cQuote {
                if pc == cQuote {
                    pc = 0 as libc::c_int;
                    continue;
                }
            }
            if c == cSep && pc == cQuote || c == rSep && pc == cQuote
                || c == rSep && pc == '\r' as i32 && ppc == cQuote
                || c == -(1 as libc::c_int) && pc == cQuote
            {
                loop {
                    (*p).n -= 1;
                    (*p).n;
                    if !(*((*p).z).offset((*p).n as isize) as libc::c_int != cQuote) {
                        break;
                    }
                }
                (*p).cTerm = c;
                break;
            } else {
                if pc == cQuote && c != '\r' as i32 {
                    fprintf(
                        stderr,
                        b"%s:%d: unescaped %c character\n\0" as *const u8
                            as *const libc::c_char,
                        (*p).zFile,
                        (*p).nLine,
                        cQuote,
                    );
                }
                if c == -(1 as libc::c_int) {
                    fprintf(
                        stderr,
                        b"%s:%d: unterminated %c-quoted field\n\0" as *const u8
                            as *const libc::c_char,
                        (*p).zFile,
                        startLine,
                        cQuote,
                    );
                    (*p).cTerm = c;
                    break;
                } else {
                    import_append_char(p, c);
                    ppc = pc;
                    pc = c;
                }
            }
        }
    } else {
        if c & 0xff as libc::c_int == 0xef as libc::c_int
            && (*p).bNotFirst == 0 as libc::c_int
        {
            import_append_char(p, c);
            c = fgetc((*p).in_0);
            if c & 0xff as libc::c_int == 0xbb as libc::c_int {
                import_append_char(p, c);
                c = fgetc((*p).in_0);
                if c & 0xff as libc::c_int == 0xbf as libc::c_int {
                    (*p).bNotFirst = 1 as libc::c_int;
                    (*p).n = 0 as libc::c_int;
                    return csv_read_one_field(p);
                }
            }
        }
        while c != -(1 as libc::c_int) && c != cSep && c != rSep {
            import_append_char(p, c);
            c = fgetc((*p).in_0);
        }
        if c == rSep {
            (*p).nLine += 1;
            (*p).nLine;
            if (*p).n > 0 as libc::c_int
                && *((*p).z).offset(((*p).n - 1 as libc::c_int) as isize) as libc::c_int
                    == '\r' as i32
            {
                (*p).n -= 1;
                (*p).n;
            }
        }
        (*p).cTerm = c;
    }
    if !((*p).z).is_null() {
        *((*p).z).offset((*p).n as isize) = 0 as libc::c_int as libc::c_char;
    }
    (*p).bNotFirst = 1 as libc::c_int;
    return (*p).z;
}
unsafe extern "C" fn ascii_read_one_field(p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let cSep: libc::c_int = (*p).cColSep as u8_0 as libc::c_int;
    let rSep: libc::c_int = (*p).cRowSep as u8_0 as libc::c_int;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    }
    while c != -(1 as libc::c_int) && c != cSep && c != rSep {
        import_append_char(p, c);
        c = fgetc((*p).in_0);
    }
    if c == rSep {
        (*p).nLine += 1;
        (*p).nLine;
    }
    (*p).cTerm = c;
    if !((*p).z).is_null() {
        *((*p).z).offset((*p).n as isize) = 0 as libc::c_int as libc::c_char;
    }
    return (*p).z;
}
unsafe extern "C" fn tryToCloneData(
    p: *mut ShellState,
    newDb: *mut sqlite3,
    zTable: *const libc::c_char,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pInsert: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zInsert: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let nTable: libc::c_int = strlen30(zTable);
    let mut k: libc::c_int = 0 as libc::c_int;
    let mut cnt: libc::c_int = 0 as libc::c_int;
    let spinRate: libc::c_int = 10000 as libc::c_int;
    zQuery = sqlite3_mprintf(
        b"SELECT * FROM \"%w\"\0" as *const u8 as *const libc::c_char,
        zTable,
    );
    shell_check_oom(zQuery as *const libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error %d: %s on [%s]\n\0" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        n = sqlite3_column_count(pQuery);
        zInsert = sqlite3_malloc64(
            (200 as libc::c_int + nTable + n * 3 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_char;
        shell_check_oom(zInsert as *const libc::c_void);
        sqlite3_snprintf(
            200 as libc::c_int + nTable,
            zInsert,
            b"INSERT OR IGNORE INTO \"%s\" VALUES(?\0" as *const u8
                as *const libc::c_char,
            zTable,
        );
        i = strlen30(zInsert);
        j = 1 as libc::c_int;
        while j < n {
            memcpy(
                zInsert.offset(i as isize) as *mut libc::c_void,
                b",?\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                2 as libc::c_int as libc::c_ulong,
            );
            i += 2 as libc::c_int;
            j += 1;
            j;
        }
        memcpy(
            zInsert.offset(i as isize) as *mut libc::c_void,
            b");\0" as *const u8 as *const libc::c_char as *const libc::c_void,
            3 as libc::c_int as libc::c_ulong,
        );
        rc = sqlite3_prepare_v2(
            newDb,
            zInsert,
            -(1 as libc::c_int),
            &mut pInsert,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error %d: %s on [%s]\n\0" as *const u8 as *const libc::c_char,
                sqlite3_extended_errcode(newDb),
                sqlite3_errmsg(newDb),
                zInsert,
            );
        } else {
            k = 0 as libc::c_int;
            while k < 2 as libc::c_int {
                loop {
                    rc = sqlite3_step(pQuery);
                    if !(rc == 100 as libc::c_int) {
                        break;
                    }
                    i = 0 as libc::c_int;
                    while i < n {
                        match sqlite3_column_type(pQuery, i) {
                            5 => {
                                sqlite3_bind_null(pInsert, i + 1 as libc::c_int);
                            }
                            1 => {
                                sqlite3_bind_int64(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_int64(pQuery, i),
                                );
                            }
                            2 => {
                                sqlite3_bind_double(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_double(pQuery, i),
                                );
                            }
                            3 => {
                                sqlite3_bind_text(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_text(pQuery, i) as *const libc::c_char,
                                    -(1 as libc::c_int),
                                    None,
                                );
                            }
                            4 => {
                                sqlite3_bind_blob(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_blob(pQuery, i),
                                    sqlite3_column_bytes(pQuery, i),
                                    None,
                                );
                            }
                            _ => {}
                        }
                        i += 1;
                        i;
                    }
                    rc = sqlite3_step(pInsert);
                    if rc != 0 as libc::c_int && rc != 100 as libc::c_int
                        && rc != 101 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"Error %d: %s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_extended_errcode(newDb),
                            sqlite3_errmsg(newDb),
                        );
                    }
                    sqlite3_reset(pInsert);
                    cnt += 1;
                    cnt;
                    if cnt % spinRate == 0 as libc::c_int {
                        printf(
                            b"%c\x08\0" as *const u8 as *const libc::c_char,
                            (*::core::mem::transmute::<
                                &[u8; 5],
                                &[libc::c_char; 5],
                            >(b"|/-\\\0"))[(cnt / spinRate % 4 as libc::c_int) as usize]
                                as libc::c_int,
                        );
                        fflush(stdout);
                    }
                }
                if rc == 101 as libc::c_int {
                    break;
                }
                sqlite3_finalize(pQuery);
                sqlite3_free(zQuery as *mut libc::c_void);
                zQuery = sqlite3_mprintf(
                    b"SELECT * FROM \"%w\" ORDER BY rowid DESC;\0" as *const u8
                        as *const libc::c_char,
                    zTable,
                );
                shell_check_oom(zQuery as *const libc::c_void);
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zQuery,
                    -(1 as libc::c_int),
                    &mut pQuery,
                    0 as *mut *const libc::c_char,
                );
                if rc != 0 {
                    fprintf(
                        stderr,
                        b"Warning: cannot step \"%s\" backwards\0" as *const u8
                            as *const libc::c_char,
                        zTable,
                    );
                    break;
                } else {
                    k += 1;
                    k;
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_finalize(pInsert);
    sqlite3_free(zQuery as *mut libc::c_void);
    sqlite3_free(zInsert as *mut libc::c_void);
}
unsafe extern "C" fn tryToCloneSchema(
    p: *mut ShellState,
    newDb: *mut sqlite3,
    zWhere: *const libc::c_char,
    xForEach: Option::<
        unsafe extern "C" fn(*mut ShellState, *mut sqlite3, *const libc::c_char) -> (),
    >,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut zName: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zSql: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    zQuery = sqlite3_mprintf(
        b"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid ASC\0" as *const u8
            as *const libc::c_char,
        zWhere,
    );
    shell_check_oom(zQuery as *const libc::c_void);
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: (%d) %s on [%s]\n\0" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        loop {
            rc = sqlite3_step(pQuery);
            if !(rc == 100 as libc::c_int) {
                break;
            }
            zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
            zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
            if zName.is_null() || zSql.is_null() {
                continue;
            }
            if sqlite3_stricmp(
                zName as *mut libc::c_char,
                b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
            ) != 0 as libc::c_int
            {
                printf(b"%s... \0" as *const u8 as *const libc::c_char, zName);
                fflush(stdout);
                sqlite3_exec(
                    newDb,
                    zSql as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    &mut zErrMsg,
                );
                if !zErrMsg.is_null() {
                    fprintf(
                        stderr,
                        b"Error: %s\nSQL: [%s]\n\0" as *const u8 as *const libc::c_char,
                        zErrMsg,
                        zSql,
                    );
                    sqlite3_free(zErrMsg as *mut libc::c_void);
                    zErrMsg = 0 as *mut libc::c_char;
                }
            }
            if xForEach.is_some() {
                xForEach
                    .expect(
                        "non-null function pointer",
                    )(p, newDb, zName as *const libc::c_char);
            }
            printf(b"done\n\0" as *const u8 as *const libc::c_char);
        }
        if rc != 101 as libc::c_int {
            sqlite3_finalize(pQuery);
            sqlite3_free(zQuery as *mut libc::c_void);
            zQuery = sqlite3_mprintf(
                b"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\0"
                    as *const u8 as *const libc::c_char,
                zWhere,
            );
            shell_check_oom(zQuery as *const libc::c_void);
            rc = sqlite3_prepare_v2(
                (*p).db,
                zQuery,
                -(1 as libc::c_int),
                &mut pQuery,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: (%d) %s on [%s]\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_extended_errcode((*p).db),
                    sqlite3_errmsg((*p).db),
                    zQuery,
                );
            } else {
                while sqlite3_step(pQuery) == 100 as libc::c_int {
                    zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
                    zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
                    if zName.is_null() || zSql.is_null() {
                        continue;
                    }
                    if sqlite3_stricmp(
                        zName as *mut libc::c_char,
                        b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        continue;
                    }
                    printf(b"%s... \0" as *const u8 as *const libc::c_char, zName);
                    fflush(stdout);
                    sqlite3_exec(
                        newDb,
                        zSql as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        &mut zErrMsg,
                    );
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\nSQL: [%s]\n\0" as *const u8
                                as *const libc::c_char,
                            zErrMsg,
                            zSql,
                        );
                        sqlite3_free(zErrMsg as *mut libc::c_void);
                        zErrMsg = 0 as *mut libc::c_char;
                    }
                    if xForEach.is_some() {
                        xForEach
                            .expect(
                                "non-null function pointer",
                            )(p, newDb, zName as *const libc::c_char);
                    }
                    printf(b"done\n\0" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_free(zQuery as *mut libc::c_void);
}
unsafe extern "C" fn tryToClone(
    p: *mut ShellState,
    zNewDb: *const libc::c_char,
) {
    let mut rc: libc::c_int = 0;
    let mut newDb: *mut sqlite3 = 0 as *mut sqlite3;
    if access(zNewDb, 0 as libc::c_int) == 0 as libc::c_int {
        fprintf(
            stderr,
            b"File \"%s\" already exists.\n\0" as *const u8 as *const libc::c_char,
            zNewDb,
        );
        return;
    }
    rc = sqlite3_open(zNewDb, &mut newDb);
    if rc != 0 {
        fprintf(
            stderr,
            b"Cannot create output database: %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(newDb),
        );
    } else {
        sqlite3_exec(
            (*p).db,
            b"PRAGMA writable_schema=ON;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        sqlite3_exec(
            newDb,
            b"BEGIN EXCLUSIVE;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        tryToCloneSchema(
            p,
            newDb,
            b"type='table'\0" as *const u8 as *const libc::c_char,
            Some(
                tryToCloneData
                    as unsafe extern "C" fn(
                        *mut ShellState,
                        *mut sqlite3,
                        *const libc::c_char,
                    ) -> (),
            ),
        );
        tryToCloneSchema(
            p,
            newDb,
            b"type!='table'\0" as *const u8 as *const libc::c_char,
            None,
        );
        sqlite3_exec(
            newDb,
            b"COMMIT;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
        sqlite3_exec(
            (*p).db,
            b"PRAGMA writable_schema=OFF;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    }
    close_db(newDb);
}
unsafe extern "C" fn output_reset(p: *mut ShellState) {
    if (*p).outfile[0 as libc::c_int as usize] as libc::c_int == '|' as i32 {
        pclose((*p).out);
    } else {
        output_file_close((*p).out);
        if (*p).doXdgOpen != 0 {
            let zXdgOpenCmd: *const libc::c_char = b"xdg-open\0" as *const u8
                as *const libc::c_char;
            let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
            zCmd = sqlite3_mprintf(
                b"%s %s\0" as *const u8 as *const libc::c_char,
                zXdgOpenCmd,
                (*p).zTempFile,
            );
            if system(zCmd) != 0 {
                fprintf(
                    stderr,
                    b"Failed: [%s]\n\0" as *const u8 as *const libc::c_char,
                    zCmd,
                );
            } else {
                sqlite3_sleep(2000 as libc::c_int);
            }
            sqlite3_free(zCmd as *mut libc::c_void);
            outputModePop(p);
            (*p).doXdgOpen = 0 as libc::c_int as u8_0;
        }
    }
    (*p).outfile[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    (*p).out = stdout;
}
unsafe extern "C" fn db_int(
    db: *mut sqlite3,
    zSql: *const libc::c_char,
) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut res: libc::c_int = 0 as libc::c_int;
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if !pStmt.is_null() && sqlite3_step(pStmt) == 100 as libc::c_int {
        res = sqlite3_column_int(pStmt, 0 as libc::c_int);
    }
    sqlite3_finalize(pStmt);
    return res;
}
unsafe extern "C" fn get2byteInt(a: *mut libc::c_uchar) -> libc::c_uint {
    return (((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *a.offset(1 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn get4byteInt(a: *mut libc::c_uchar) -> libc::c_uint {
    return (((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 24 as libc::c_int)
        + ((*a.offset(1 as libc::c_int as isize) as libc::c_int) << 16 as libc::c_int)
        + ((*a.offset(2 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *a.offset(3 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn shell_dbinfo_command(
    p: *mut ShellState,
    nArg: libc::c_int,
    azArg: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut aField: [C2RustUnnamed_23; 12] = [
        {
            let init = C2RustUnnamed_23 {
                zName: b"file change counter:\0" as *const u8 as *const libc::c_char,
                ofst: 24 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"database page count:\0" as *const u8 as *const libc::c_char,
                ofst: 28 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"freelist page count:\0" as *const u8 as *const libc::c_char,
                ofst: 36 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"schema cookie:\0" as *const u8 as *const libc::c_char,
                ofst: 40 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"schema format:\0" as *const u8 as *const libc::c_char,
                ofst: 44 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"default cache size:\0" as *const u8 as *const libc::c_char,
                ofst: 48 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"autovacuum top root:\0" as *const u8 as *const libc::c_char,
                ofst: 52 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"incremental vacuum:\0" as *const u8 as *const libc::c_char,
                ofst: 64 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"text encoding:\0" as *const u8 as *const libc::c_char,
                ofst: 56 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"user version:\0" as *const u8 as *const libc::c_char,
                ofst: 60 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"application id:\0" as *const u8 as *const libc::c_char,
                ofst: 68 as libc::c_int,
            };
            init
        },
        {
            let init = C2RustUnnamed_23 {
                zName: b"software version:\0" as *const u8 as *const libc::c_char,
                ofst: 96 as libc::c_int,
            };
            init
        },
    ];
    static mut aQuery: [C2RustUnnamed_22; 5] = [
        {
            let init = C2RustUnnamed_22 {
                zName: b"number of tables:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='table'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let init = C2RustUnnamed_22 {
                zName: b"number of indexes:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='index'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let init = C2RustUnnamed_22 {
                zName: b"number of triggers:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='trigger'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let init = C2RustUnnamed_22 {
                zName: b"number of views:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type='view'\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let init = C2RustUnnamed_22 {
                zName: b"schema size:\0" as *const u8 as *const libc::c_char,
                zSql: b"SELECT total(length(sql)) FROM %s\0" as *const u8
                    as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut iDataVersion: libc::c_uint = 0;
    let mut zSchemaTab: *mut libc::c_char = 0 as *mut libc::c_char;
    let zDb: *mut libc::c_char = (if nArg >= 2 as libc::c_int {
        *azArg.offset(1 as libc::c_int as isize) as *const libc::c_char
    } else {
        b"main\0" as *const u8 as *const libc::c_char
    }) as *mut libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aHdr: [libc::c_uchar; 100] = [0; 100];
    open_db(p, 0 as libc::c_int);
    if ((*p).db).is_null() {
        return 1 as libc::c_int;
    }
    rc = sqlite3_prepare_v2(
        (*p).db,
        b"SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1\0" as *const u8
            as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"error: %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg((*p).db),
        );
        sqlite3_finalize(pStmt);
        return 1 as libc::c_int;
    }
    sqlite3_bind_text(pStmt, 1 as libc::c_int, zDb, -(1 as libc::c_int), None);
    if sqlite3_step(pStmt) == 100 as libc::c_int
        && sqlite3_column_bytes(pStmt, 0 as libc::c_int) > 100 as libc::c_int
    {
        let pb: *const u8_0 = sqlite3_column_blob(pStmt, 0 as libc::c_int)
            as *const u8_0;
        shell_check_oom(pb as *const libc::c_void);
        memcpy(
            aHdr.as_mut_ptr() as *mut libc::c_void,
            pb as *const libc::c_void,
            100 as libc::c_int as libc::c_ulong,
        );
        sqlite3_finalize(pStmt);
    } else {
        fprintf(
            stderr,
            b"unable to read database header\n\0" as *const u8 as *const libc::c_char,
        );
        sqlite3_finalize(pStmt);
        return 1 as libc::c_int;
    }
    i = get2byteInt(aHdr.as_mut_ptr().offset(16 as libc::c_int as isize)) as libc::c_int;
    if i == 1 as libc::c_int {
        i = 65536 as libc::c_int;
    }
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"database page size:\0" as *const u8 as *const libc::c_char,
        i,
    );
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"write format:\0" as *const u8 as *const libc::c_char,
        aHdr[18 as libc::c_int as usize] as libc::c_int,
    );
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"read format:\0" as *const u8 as *const libc::c_char,
        aHdr[19 as libc::c_int as usize] as libc::c_int,
    );
    fprintf(
        (*p).out,
        b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
        b"reserved bytes:\0" as *const u8 as *const libc::c_char,
        aHdr[20 as libc::c_int as usize] as libc::c_int,
    );
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<[C2RustUnnamed_23; 12]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_23>() as libc::c_ulong)
            as libc::c_int
    {
        let ofst: libc::c_int = aField[i as usize].ofst;
        let val: libc::c_uint = get4byteInt(aHdr.as_mut_ptr().offset(ofst as isize));
        fprintf(
            (*p).out,
            b"%-20s %u\0" as *const u8 as *const libc::c_char,
            aField[i as usize].zName,
            val,
        );
        match ofst {
            56 => {
                if val == 1 as libc::c_int as libc::c_uint {
                    fprintf((*p).out, b" (utf8)\0" as *const u8 as *const libc::c_char);
                }
                if val == 2 as libc::c_int as libc::c_uint {
                    fprintf(
                        (*p).out,
                        b" (utf16le)\0" as *const u8 as *const libc::c_char,
                    );
                }
                if val == 3 as libc::c_int as libc::c_uint {
                    fprintf(
                        (*p).out,
                        b" (utf16be)\0" as *const u8 as *const libc::c_char,
                    );
                }
            }
            _ => {}
        }
        fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
        i += 1;
        i;
    }
    if zDb.is_null() {
        zSchemaTab = sqlite3_mprintf(
            b"main.sqlite_schema\0" as *const u8 as *const libc::c_char,
        );
    } else if cli_strcmp(zDb, b"temp\0" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
    {
        zSchemaTab = sqlite3_mprintf(
            b"%s\0" as *const u8 as *const libc::c_char,
            b"sqlite_temp_schema\0" as *const u8 as *const libc::c_char,
        );
    } else {
        zSchemaTab = sqlite3_mprintf(
            b"\"%w\".sqlite_schema\0" as *const u8 as *const libc::c_char,
            zDb,
        );
    }
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<[C2RustUnnamed_22; 5]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<C2RustUnnamed_22>() as libc::c_ulong)
            as libc::c_int
    {
        let zSql: *mut libc::c_char = sqlite3_mprintf(
            aQuery[i as usize].zSql,
            zSchemaTab,
        );
        let val_0: libc::c_int = db_int((*p).db, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
        fprintf(
            (*p).out,
            b"%-20s %d\n\0" as *const u8 as *const libc::c_char,
            aQuery[i as usize].zName,
            val_0,
        );
        i += 1;
        i;
    }
    sqlite3_free(zSchemaTab as *mut libc::c_void);
    sqlite3_file_control(
        (*p).db,
        zDb,
        35 as libc::c_int,
        &mut iDataVersion as *mut libc::c_uint as *mut libc::c_void,
    );
    fprintf(
        (*p).out,
        b"%-20s %u\n\0" as *const u8 as *const libc::c_char,
        b"data version\0" as *const u8 as *const libc::c_char,
        iDataVersion,
    );
    return 0 as libc::c_int;
}
unsafe extern "C" fn shellDatabaseError(db: *mut sqlite3) -> libc::c_int {
    let zErr: *const libc::c_char = sqlite3_errmsg(db);
    fprintf(stderr, b"Error: %s\n\0" as *const u8 as *const libc::c_char, zErr);
    return 1 as libc::c_int;
}
unsafe extern "C" fn testcase_glob(
    mut zGlob: *const libc::c_char,
    mut z: *const libc::c_char,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut invert: libc::c_int = 0;
    let mut seen: libc::c_int = 0;
    loop {
        let fresh98 = zGlob;
        zGlob = zGlob.offset(1);
        c = *fresh98 as libc::c_int;
        if !(c != 0 as libc::c_int) {
            break;
        }
        if *(*__ctype_b_loc()).offset(c as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            }
            while *(*__ctype_b_loc())
                .offset(*zGlob as libc::c_uchar as libc::c_int as isize) as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                zGlob = zGlob.offset(1);
                zGlob;
            }
            while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                != 0
            {
                z = z.offset(1);
                z;
            }
        } else if c == '*' as i32 {
            loop {
                let fresh99 = zGlob;
                zGlob = zGlob.offset(1);
                c = *fresh99 as libc::c_int;
                if !(c == '*' as i32 || c == '?' as i32) {
                    break;
                }
                if c == '?' as i32
                    && {
                        let fresh100 = z;
                        z = z.offset(1);
                        *fresh100 as libc::c_int == 0 as libc::c_int
                    }
                {
                    return 0 as libc::c_int;
                }
            }
            if c == 0 as libc::c_int {
                return 1 as libc::c_int
            } else if c == '[' as i32 {
                while *z as libc::c_int != 0
                    && testcase_glob(zGlob.offset(-(1 as libc::c_int as isize)), z)
                        == 0 as libc::c_int
                {
                    z = z.offset(1);
                    z;
                }
                return (*z as libc::c_int != 0 as libc::c_int) as libc::c_int;
            }
            loop {
                let fresh101 = z;
                z = z.offset(1);
                c2 = *fresh101 as libc::c_int;
                if !(c2 != 0 as libc::c_int) {
                    break;
                }
                while c2 != c {
                    let fresh102 = z;
                    z = z.offset(1);
                    c2 = *fresh102 as libc::c_int;
                    if c2 == 0 as libc::c_int {
                        return 0 as libc::c_int;
                    }
                }
                if testcase_glob(zGlob, z) != 0 {
                    return 1 as libc::c_int;
                }
            }
            return 0 as libc::c_int;
        } else if c == '?' as i32 {
            let fresh103 = z;
            z = z.offset(1);
            if *fresh103 as libc::c_int == 0 as libc::c_int {
                return 0 as libc::c_int;
            }
        } else if c == '[' as i32 {
            let mut prior_c: libc::c_int = 0 as libc::c_int;
            seen = 0 as libc::c_int;
            invert = 0 as libc::c_int;
            let fresh104 = z;
            z = z.offset(1);
            c = *fresh104 as libc::c_int;
            if c == 0 as libc::c_int {
                return 0 as libc::c_int;
            }
            let fresh105 = zGlob;
            zGlob = zGlob.offset(1);
            c2 = *fresh105 as libc::c_int;
            if c2 == '^' as i32 {
                invert = 1 as libc::c_int;
                let fresh106 = zGlob;
                zGlob = zGlob.offset(1);
                c2 = *fresh106 as libc::c_int;
            }
            if c2 == ']' as i32 {
                if c == ']' as i32 {
                    seen = 1 as libc::c_int;
                }
                let fresh107 = zGlob;
                zGlob = zGlob.offset(1);
                c2 = *fresh107 as libc::c_int;
            }
            while c2 != 0 && c2 != ']' as i32 {
                if c2 == '-' as i32
                    && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                        != ']' as i32
                    && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                        != 0 as libc::c_int && prior_c > 0 as libc::c_int
                {
                    let fresh108 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh108 as libc::c_int;
                    if c >= prior_c && c <= c2 {
                        seen = 1 as libc::c_int;
                    }
                    prior_c = 0 as libc::c_int;
                } else {
                    if c == c2 {
                        seen = 1 as libc::c_int;
                    }
                    prior_c = c2;
                }
                let fresh109 = zGlob;
                zGlob = zGlob.offset(1);
                c2 = *fresh109 as libc::c_int;
            }
            if c2 == 0 as libc::c_int || seen ^ invert == 0 as libc::c_int {
                return 0 as libc::c_int;
            }
        } else if c == '#' as i32 {
            if (*z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                || *z.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32)
                && *(*__ctype_b_loc())
                    .offset(
                        *z.offset(1 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                z = z.offset(1);
                z;
            }
            if *(*__ctype_b_loc())
                .offset(
                    *z.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int == 0
            {
                return 0 as libc::c_int;
            }
            z = z.offset(1);
            z;
            while *(*__ctype_b_loc())
                .offset(
                    *z.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                        as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            {
                z = z.offset(1);
                z;
            }
        } else {
            let fresh110 = z;
            z = z.offset(1);
            if c != *fresh110 as libc::c_int {
                return 0 as libc::c_int;
            }
        }
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
        as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        z = z.offset(1);
        z;
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn optionMatch(
    mut zStr: *const libc::c_char,
    zOpt: *const libc::c_char,
) -> libc::c_int {
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
        return 0 as libc::c_int;
    }
    zStr = zStr.offset(1);
    zStr;
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        zStr = zStr.offset(1);
        zStr;
    }
    return (cli_strcmp(zStr, zOpt) == 0 as libc::c_int) as libc::c_int;
}
#[no_mangle]
pub unsafe extern "C" fn shellDeleteFile(
    zFilename: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    rc = unlink(zFilename);
    return rc;
}
unsafe extern "C" fn clearTempFile(p: *mut ShellState) {
    if ((*p).zTempFile).is_null() {
        return;
    }
    if (*p).doXdgOpen != 0 {
        return;
    }
    if shellDeleteFile((*p).zTempFile) != 0 {
        return;
    }
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    (*p).zTempFile = 0 as *mut libc::c_char;
}
unsafe extern "C" fn newTempFile(
    p: *mut ShellState,
    zSuffix: *const libc::c_char,
) {
    clearTempFile(p);
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    (*p).zTempFile = 0 as *mut libc::c_char;
    if !((*p).db).is_null() {
        sqlite3_file_control(
            (*p).db,
            0 as *const libc::c_char,
            16 as libc::c_int,
            &mut (*p).zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
        );
    }
    if ((*p).zTempFile).is_null() {
        let mut zTemp: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut r: sqlite3_uint64 = 0;
        sqlite3_randomness(
            ::core::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTemp = getenv(b"TEMP\0" as *const u8 as *const libc::c_char);
        if zTemp.is_null() {
            zTemp = getenv(b"TMP\0" as *const u8 as *const libc::c_char);
        }
        if zTemp.is_null() {
            zTemp = b"/tmp\0" as *const u8 as *const libc::c_char as *mut libc::c_char;
        }
        (*p)
            .zTempFile = sqlite3_mprintf(
            b"%s/temp%llx.%s\0" as *const u8 as *const libc::c_char,
            zTemp,
            r,
            zSuffix,
        );
    } else {
        (*p)
            .zTempFile = sqlite3_mprintf(
            b"%z.%s\0" as *const u8 as *const libc::c_char,
            (*p).zTempFile,
            zSuffix,
        );
    }
    shell_check_oom((*p).zTempFile as *const libc::c_void);
}
unsafe extern "C" fn shellFkeyCollateClause(
    pCtx: *mut sqlite3_context,
    nVal: libc::c_int,
    apVal: *mut *mut sqlite3_value,
) {
    let db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    let mut zParent: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChild: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    if nVal == 4 as libc::c_int {} else {
        __assert_fail(
            b"nVal==4\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            22432 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 70],
                &[libc::c_char; 70],
            >(
                b"void shellFkeyCollateClause(sqlite3_context *, int, sqlite3_value **)\0",
            ))
                .as_ptr(),
        );
    }
    'c_112945: {
        if nVal == 4 as libc::c_int {} else {
            __assert_fail(
                b"nVal==4\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                22432 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 70],
                    &[libc::c_char; 70],
                >(
                    b"void shellFkeyCollateClause(sqlite3_context *, int, sqlite3_value **)\0",
                ))
                    .as_ptr(),
            );
        }
    };
    zParent = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize))
        as *const libc::c_char;
    zParentCol = sqlite3_value_text(*apVal.offset(1 as libc::c_int as isize))
        as *const libc::c_char;
    zChild = sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize))
        as *const libc::c_char;
    zChildCol = sqlite3_value_text(*apVal.offset(3 as libc::c_int as isize))
        as *const libc::c_char;
    sqlite3_result_text(
        pCtx,
        b"\0" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        None,
    );
    rc = sqlite3_table_column_metadata(
        db,
        b"main\0" as *const u8 as *const libc::c_char,
        zParent,
        zParentCol,
        0 as *mut *const libc::c_char,
        &mut zParentSeq,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_table_column_metadata(
            db,
            b"main\0" as *const u8 as *const libc::c_char,
            zChild,
            zChildCol,
            0 as *mut *const libc::c_char,
            &mut zChildSeq,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
    }
    if rc == 0 as libc::c_int && sqlite3_stricmp(zParentSeq, zChildSeq) != 0 {
        let z: *mut libc::c_char = sqlite3_mprintf(
            b" COLLATE %s\0" as *const u8 as *const libc::c_char,
            zParentSeq,
        );
        sqlite3_result_text(
            pCtx,
            z,
            -(1 as libc::c_int),
            ::core::mem::transmute::<
                libc::intptr_t,
                sqlite3_destructor_type,
            >(-(1 as libc::c_int) as libc::intptr_t),
        );
        sqlite3_free(z as *mut libc::c_void);
    }
}
unsafe extern "C" fn lintFkeyIndexes(
    pState: *mut ShellState,
    azArg: *mut *mut libc::c_char,
    nArg: libc::c_int,
) -> libc::c_int {
    let db: *mut sqlite3 = (*pState).db;
    let out: *mut FILE = (*pState).out;
    let mut bVerbose: libc::c_int = 0 as libc::c_int;
    let mut bGroupByParent: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut zIndent: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let zSql: *const libc::c_char = b"SELECT      'EXPLAIN QUERY PLAN SELECT 1 FROM ' || quote(s.name) || ' WHERE '  || group_concat(quote(s.name) || '.' || quote(f.[from]) || '=?'   || fkey_collate_clause(       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),' AND '),      'SEARCH ' || s.name || ' USING COVERING INDEX*('  || group_concat('*=?', ' AND ') || ')',      s.name  || '(' || group_concat(f.[from],  ', ') || ')',      f.[table] || '(' || group_concat(COALESCE(f.[to], p.[name])) || ')',      'CREATE INDEX ' || quote(s.name ||'_'|| group_concat(f.[from], '_'))  || ' ON ' || quote(s.name) || '('  || group_concat(quote(f.[from]) ||        fkey_collate_clause(          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), ', ')  || ');',      f.[table] FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) GROUP BY s.name, f.id ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)\0"
        as *const u8 as *const libc::c_char;
    let zGlobIPK: *const libc::c_char = b"SEARCH * USING INTEGER PRIMARY KEY (rowid=?)\0"
        as *const u8 as *const libc::c_char;
    i = 2 as libc::c_int;
    while i < nArg {
        let n: libc::c_int = strlen30(*azArg.offset(i as isize));
        if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-verbose\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bVerbose = 1 as libc::c_int;
        } else if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-groupbyparent\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bGroupByParent = 1 as libc::c_int;
            zIndent = b"    \0" as *const u8 as *const libc::c_char;
        } else {
            fprintf(
                stderr,
                b"Usage: %s %s ?-verbose? ?-groupbyparent?\n\0" as *const u8
                    as *const libc::c_char,
                *azArg.offset(0 as libc::c_int as isize),
                *azArg.offset(1 as libc::c_int as isize),
            );
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    rc = sqlite3_create_function(
        db,
        b"fkey_collate_clause\0" as *const u8 as *const libc::c_char,
        4 as libc::c_int,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            shellFkeyCollateClause
                as unsafe extern "C" fn(
                    *mut sqlite3_context,
                    libc::c_int,
                    *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pSql,
            0 as *mut *const libc::c_char,
        );
    }
    if rc == 0 as libc::c_int {
        sqlite3_bind_int(pSql, 1 as libc::c_int, bGroupByParent);
    }
    if rc == 0 as libc::c_int {
        let mut rc2: libc::c_int = 0;
        let mut zPrev: *mut libc::c_char = 0 as *mut libc::c_char;
        while 100 as libc::c_int == sqlite3_step(pSql) {
            let mut res: libc::c_int = -(1 as libc::c_int);
            let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let zEQP: *const libc::c_char = sqlite3_column_text(
                pSql,
                0 as libc::c_int,
            ) as *const libc::c_char;
            let zGlob: *const libc::c_char = sqlite3_column_text(
                pSql,
                1 as libc::c_int,
            ) as *const libc::c_char;
            let zFrom: *const libc::c_char = sqlite3_column_text(
                pSql,
                2 as libc::c_int,
            ) as *const libc::c_char;
            let zTarget: *const libc::c_char = sqlite3_column_text(
                pSql,
                3 as libc::c_int,
            ) as *const libc::c_char;
            let zCI: *const libc::c_char = sqlite3_column_text(
                pSql,
                4 as libc::c_int,
            ) as *const libc::c_char;
            let zParent: *const libc::c_char = sqlite3_column_text(
                pSql,
                5 as libc::c_int,
            ) as *const libc::c_char;
            if zEQP.is_null() {
                continue;
            }
            if zGlob.is_null() {
                continue;
            }
            rc = sqlite3_prepare_v2(
                db,
                zEQP,
                -(1 as libc::c_int),
                &mut pExplain,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 as libc::c_int {
                break;
            }
            if 100 as libc::c_int == sqlite3_step(pExplain) {
                let zPlan: *const libc::c_char = sqlite3_column_text(
                    pExplain,
                    3 as libc::c_int,
                ) as *const libc::c_char;
                res = (!zPlan.is_null()
                    && (0 as libc::c_int == sqlite3_strglob(zGlob, zPlan)
                        || 0 as libc::c_int == sqlite3_strglob(zGlobIPK, zPlan)))
                    as libc::c_int;
            }
            rc = sqlite3_finalize(pExplain);
            if rc != 0 as libc::c_int {
                break;
            }
            if res < 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: internal error\0" as *const u8 as *const libc::c_char,
                );
                break;
            } else {
                if bGroupByParent != 0 && (bVerbose != 0 || res == 0 as libc::c_int)
                    && (zPrev.is_null() || sqlite3_stricmp(zParent, zPrev) != 0)
                {
                    fprintf(
                        out,
                        b"-- Parent table %s\n\0" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                    sqlite3_free(zPrev as *mut libc::c_void);
                    zPrev = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                }
                if res == 0 as libc::c_int {
                    fprintf(
                        out,
                        b"%s%s --> %s\n\0" as *const u8 as *const libc::c_char,
                        zIndent,
                        zCI,
                        zTarget,
                    );
                } else if bVerbose != 0 {
                    fprintf(
                        out,
                        b"%s/* no extra indexes required for %s -> %s */\n\0"
                            as *const u8 as *const libc::c_char,
                        zIndent,
                        zFrom,
                        zTarget,
                    );
                }
            }
        }
        sqlite3_free(zPrev as *mut libc::c_void);
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        rc2 = sqlite3_finalize(pSql);
        if rc == 0 as libc::c_int && rc2 != 0 as libc::c_int {
            rc = rc2;
            fprintf(
                stderr,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
    } else {
        fprintf(
            stderr,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(db),
        );
    }
    return rc;
}
unsafe extern "C" fn lintDotCommand(
    pState: *mut ShellState,
    azArg: *mut *mut libc::c_char,
    nArg: libc::c_int,
) -> libc::c_int {
    let mut n: libc::c_int = 0;
    n = if nArg >= 2 as libc::c_int {
        strlen30(*azArg.offset(1 as libc::c_int as isize))
    } else {
        0 as libc::c_int
    };
    if n < 1 as libc::c_int
        || sqlite3_strnicmp(
            *azArg.offset(1 as libc::c_int as isize),
            b"fkey-indexes\0" as *const u8 as *const libc::c_char,
            n,
        ) != 0
    {
        fprintf(
            stderr,
            b"Usage %s sub-command ?switches...?\n\0" as *const u8
                as *const libc::c_char,
            *azArg.offset(0 as libc::c_int as isize),
        );
        fprintf(
            stderr,
            b"Where sub-commands are:\n\0" as *const u8 as *const libc::c_char,
        );
        fprintf(stderr, b"    fkey-indexes\n\0" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    } else {
        return lintFkeyIndexes(pState, azArg, nArg)
    };
}
unsafe extern "C" fn shellPrepare(
    db: *mut sqlite3,
    pRc: *mut libc::c_int,
    zSql: *const libc::c_char,
    ppStmt: *mut *mut sqlite3_stmt,
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let rc: libc::c_int = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            ppStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"sql error: %s (%d)\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
                sqlite3_errcode(db),
            );
            *pRc = rc;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellPreparePrintf(
    db: *mut sqlite3,
    pRc: *mut libc::c_int,
    ppStmt: *mut *mut sqlite3_stmt,
    zFmt: *const libc::c_char,
    args: ...
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut ap: ::core::ffi::VaListImpl;
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            *pRc = 7 as libc::c_int;
        } else {
            shellPrepare(db, pRc, z, ppStmt);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellFinalize(
    pRc: *mut libc::c_int,
    pStmt: *mut sqlite3_stmt,
) {
    if !pStmt.is_null() {
        let db: *mut sqlite3 = sqlite3_db_handle(pStmt);
        let rc: libc::c_int = sqlite3_finalize(pStmt);
        if *pRc == 0 as libc::c_int {
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"SQL error: %s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_errmsg(db),
                );
            }
            *pRc = rc;
        }
    }
}
#[no_mangle]
pub unsafe extern "C" fn shellReset(
    pRc: *mut libc::c_int,
    pStmt: *mut sqlite3_stmt,
) {
    let rc: libc::c_int = sqlite3_reset(pStmt);
    if *pRc == 0 as libc::c_int {
        if rc != 0 as libc::c_int {
            let db: *mut sqlite3 = sqlite3_db_handle(pStmt);
            fprintf(
                stderr,
                b"SQL error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        *pRc = rc;
    }
}
unsafe extern "C" fn arUsage(f: *mut FILE) -> libc::c_int {
    showHelp(f, b"archive\0" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
unsafe extern "C" fn arErrorMsg(
    pAr: *mut ArCommand,
    zFmt: *const libc::c_char,
    args: ...
) -> libc::c_int {
    let mut ap: ::core::ffi::VaListImpl;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    fprintf(stderr, b"Error: %s\n\0" as *const u8 as *const libc::c_char, z);
    if (*pAr).fromCmdLine != 0 {
        fprintf(
            stderr,
            b"Use \"-A\" for more help\n\0" as *const u8 as *const libc::c_char,
        );
    } else {
        fprintf(
            stderr,
            b"Use \".archive --help\" for more help\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    sqlite3_free(z as *mut libc::c_void);
    return 1 as libc::c_int;
}
unsafe extern "C" fn arProcessSwitch(
    pAr: *mut ArCommand,
    eSwitch: libc::c_int,
    zArg: *const libc::c_char,
) -> libc::c_int {
    let current_block_10: u64;
    match eSwitch {
        1 | 4 | 5 | 7 | 2 | 3 | 6 => {
            if (*pAr).eCmd != 0 {
                return arErrorMsg(
                    pAr,
                    b"multiple command options\0" as *const u8 as *const libc::c_char,
                );
            }
            (*pAr).eCmd = eSwitch as u8_0;
            current_block_10 = 17860125682698302841;
        }
        12 => {
            (*pAr).bDryRun = 1 as libc::c_int as u8_0;
            current_block_10 = 17860125682698302841;
        }
        13 => {
            (*pAr).bGlob = 1 as libc::c_int as u8_0;
            current_block_10 = 17860125682698302841;
        }
        8 => {
            (*pAr).bVerbose = 1 as libc::c_int as u8_0;
            current_block_10 = 17860125682698302841;
        }
        11 => {
            (*pAr).bAppend = 1 as libc::c_int as u8_0;
            current_block_10 = 15175151419291770614;
        }
        9 => {
            current_block_10 = 15175151419291770614;
        }
        10 => {
            (*pAr).zDir = zArg;
            current_block_10 = 17860125682698302841;
        }
        _ => {
            current_block_10 = 17860125682698302841;
        }
    }
    match current_block_10 {
        15175151419291770614 => {
            (*pAr).zFile = zArg;
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn arParseCommand(
    azArg: *mut *mut libc::c_char,
    nArg: libc::c_int,
    pAr: *mut ArCommand,
) -> libc::c_int {
    let mut aSwitch: [ArSwitch; 13] = [
        {
            let init = ArSwitch {
                zLong: b"create\0" as *const u8 as *const libc::c_char,
                cShort: 'c' as i32 as libc::c_char,
                eSwitch: 1 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"extract\0" as *const u8 as *const libc::c_char,
                cShort: 'x' as i32 as libc::c_char,
                eSwitch: 4 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"insert\0" as *const u8 as *const libc::c_char,
                cShort: 'i' as i32 as libc::c_char,
                eSwitch: 3 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"list\0" as *const u8 as *const libc::c_char,
                cShort: 't' as i32 as libc::c_char,
                eSwitch: 5 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"remove\0" as *const u8 as *const libc::c_char,
                cShort: 'r' as i32 as libc::c_char,
                eSwitch: 7 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"update\0" as *const u8 as *const libc::c_char,
                cShort: 'u' as i32 as libc::c_char,
                eSwitch: 2 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"help\0" as *const u8 as *const libc::c_char,
                cShort: 'h' as i32 as libc::c_char,
                eSwitch: 6 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"verbose\0" as *const u8 as *const libc::c_char,
                cShort: 'v' as i32 as libc::c_char,
                eSwitch: 8 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"file\0" as *const u8 as *const libc::c_char,
                cShort: 'f' as i32 as libc::c_char,
                eSwitch: 9 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"append\0" as *const u8 as *const libc::c_char,
                cShort: 'a' as i32 as libc::c_char,
                eSwitch: 11 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"directory\0" as *const u8 as *const libc::c_char,
                cShort: 'C' as i32 as libc::c_char,
                eSwitch: 10 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"dryrun\0" as *const u8 as *const libc::c_char,
                cShort: 'n' as i32 as libc::c_char,
                eSwitch: 12 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let init = ArSwitch {
                zLong: b"glob\0" as *const u8 as *const libc::c_char,
                cShort: 'g' as i32 as libc::c_char,
                eSwitch: 13 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
    ];
    let nSwitch: libc::c_int = (::core::mem::size_of::<[ArSwitch; 13]>()
        as libc::c_ulong)
        .wrapping_div(::core::mem::size_of::<ArSwitch>() as libc::c_ulong)
        as libc::c_int;
    let pEnd: *mut ArSwitch = &mut *aSwitch.as_mut_ptr().offset(nSwitch as isize)
        as *mut ArSwitch;
    if nArg <= 1 as libc::c_int {
        fprintf(
            stderr,
            b"Wrong number of arguments.  Usage:\n\0" as *const u8 as *const libc::c_char,
        );
        return arUsage(stderr);
    } else {
        let mut z: *mut libc::c_char = *azArg.offset(1 as libc::c_int as isize);
        if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
            let mut i: libc::c_int = 0;
            let mut iArg: libc::c_int = 2 as libc::c_int;
            i = 0 as libc::c_int;
            while *z.offset(i as isize) != 0 {
                let mut zArg: *const libc::c_char = 0 as *const libc::c_char;
                let mut pOpt: *mut ArSwitch = 0 as *mut ArSwitch;
                pOpt = &mut *aSwitch.as_mut_ptr().offset(0 as libc::c_int as isize)
                    as *mut ArSwitch;
                while pOpt < pEnd {
                    if *z.offset(i as isize) as libc::c_int
                        == (*pOpt).cShort as libc::c_int
                    {
                        break;
                    }
                    pOpt = pOpt.offset(1);
                    pOpt;
                }
                if pOpt == pEnd {
                    return arErrorMsg(
                        pAr,
                        b"unrecognized option: %c\0" as *const u8 as *const libc::c_char,
                        *z.offset(i as isize) as libc::c_int,
                    );
                }
                if (*pOpt).bArg != 0 {
                    if iArg >= nArg {
                        return arErrorMsg(
                            pAr,
                            b"option requires an argument: %c\0" as *const u8
                                as *const libc::c_char,
                            *z.offset(i as isize) as libc::c_int,
                        );
                    }
                    let fresh111 = iArg;
                    iArg = iArg + 1;
                    zArg = *azArg.offset(fresh111 as isize);
                }
                if arProcessSwitch(pAr, (*pOpt).eSwitch as libc::c_int, zArg) != 0 {
                    return 1 as libc::c_int;
                }
                i += 1;
                i;
            }
            (*pAr).nArg = nArg - iArg;
            if (*pAr).nArg > 0 as libc::c_int {
                (*pAr)
                    .azArg = &mut *azArg.offset(iArg as isize) as *mut *mut libc::c_char;
            }
        } else {
            let mut iArg_0: libc::c_int = 0;
            iArg_0 = 1 as libc::c_int;
            while iArg_0 < nArg {
                let mut n: libc::c_int = 0;
                z = *azArg.offset(iArg_0 as isize);
                if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                    (*pAr)
                        .azArg = &mut *azArg.offset(iArg_0 as isize)
                        as *mut *mut libc::c_char;
                    (*pAr).nArg = nArg - iArg_0;
                    break;
                } else {
                    n = strlen30(z);
                    if *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32
                    {
                        let mut i_0: libc::c_int = 0;
                        i_0 = 1 as libc::c_int;
                        while i_0 < n {
                            let mut zArg_0: *const libc::c_char = 0
                                as *const libc::c_char;
                            let mut pOpt_0: *mut ArSwitch = 0 as *mut ArSwitch;
                            pOpt_0 = &mut *aSwitch
                                .as_mut_ptr()
                                .offset(0 as libc::c_int as isize) as *mut ArSwitch;
                            while pOpt_0 < pEnd {
                                if *z.offset(i_0 as isize) as libc::c_int
                                    == (*pOpt_0).cShort as libc::c_int
                                {
                                    break;
                                }
                                pOpt_0 = pOpt_0.offset(1);
                                pOpt_0;
                            }
                            if pOpt_0 == pEnd {
                                return arErrorMsg(
                                    pAr,
                                    b"unrecognized option: %c\0" as *const u8
                                        as *const libc::c_char,
                                    *z.offset(i_0 as isize) as libc::c_int,
                                );
                            }
                            if (*pOpt_0).bArg != 0 {
                                if i_0 < n - 1 as libc::c_int {
                                    zArg_0 = &mut *z.offset((i_0 + 1 as libc::c_int) as isize)
                                        as *mut libc::c_char;
                                    i_0 = n;
                                } else {
                                    if iArg_0 >= nArg - 1 as libc::c_int {
                                        return arErrorMsg(
                                            pAr,
                                            b"option requires an argument: %c\0" as *const u8
                                                as *const libc::c_char,
                                            *z.offset(i_0 as isize) as libc::c_int,
                                        );
                                    }
                                    iArg_0 += 1;
                                    zArg_0 = *azArg.offset(iArg_0 as isize);
                                }
                            }
                            if arProcessSwitch(
                                pAr,
                                (*pOpt_0).eSwitch as libc::c_int,
                                zArg_0,
                            ) != 0
                            {
                                return 1 as libc::c_int;
                            }
                            i_0 += 1;
                            i_0;
                        }
                    } else if *z.offset(2 as libc::c_int as isize) as libc::c_int
                        == '\0' as i32
                    {
                        (*pAr)
                            .azArg = &mut *azArg
                            .offset((iArg_0 + 1 as libc::c_int) as isize)
                            as *mut *mut libc::c_char;
                        (*pAr).nArg = nArg - iArg_0 - 1 as libc::c_int;
                        break;
                    } else {
                        let mut zArg_1: *const libc::c_char = 0 as *const libc::c_char;
                        let mut pMatch: *mut ArSwitch = 0 as *mut ArSwitch;
                        let mut pOpt_1: *mut ArSwitch = 0 as *mut ArSwitch;
                        pOpt_1 = &mut *aSwitch
                            .as_mut_ptr()
                            .offset(0 as libc::c_int as isize) as *mut ArSwitch;
                        while pOpt_1 < pEnd {
                            let zLong: *const libc::c_char = (*pOpt_1).zLong;
                            if n - 2 as libc::c_int <= strlen30(zLong)
                                && 0 as libc::c_int
                                    == memcmp(
                                        &mut *z.offset(2 as libc::c_int as isize)
                                            as *mut libc::c_char as *const libc::c_void,
                                        zLong as *const libc::c_void,
                                        (n - 2 as libc::c_int) as libc::c_ulong,
                                    )
                            {
                                if !pMatch.is_null() {
                                    return arErrorMsg(
                                        pAr,
                                        b"ambiguous option: %s\0" as *const u8
                                            as *const libc::c_char,
                                        z,
                                    )
                                } else {
                                    pMatch = pOpt_1;
                                }
                            }
                            pOpt_1 = pOpt_1.offset(1);
                            pOpt_1;
                        }
                        if pMatch.is_null() {
                            return arErrorMsg(
                                pAr,
                                b"unrecognized option: %s\0" as *const u8
                                    as *const libc::c_char,
                                z,
                            );
                        }
                        if (*pMatch).bArg != 0 {
                            if iArg_0 >= nArg - 1 as libc::c_int {
                                return arErrorMsg(
                                    pAr,
                                    b"option requires an argument: %s\0" as *const u8
                                        as *const libc::c_char,
                                    z,
                                );
                            }
                            iArg_0 += 1;
                            zArg_1 = *azArg.offset(iArg_0 as isize);
                        }
                        if arProcessSwitch(pAr, (*pMatch).eSwitch as libc::c_int, zArg_1)
                            != 0
                        {
                            return 1 as libc::c_int;
                        }
                    }
                    iArg_0 += 1;
                    iArg_0;
                }
            }
        }
    }
    if (*pAr).eCmd as libc::c_int == 0 as libc::c_int {
        fprintf(
            stderr,
            b"Required argument missing.  Usage:\n\0" as *const u8 as *const libc::c_char,
        );
        return arUsage(stderr);
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn arCheckEntries(pAr: *mut ArCommand) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pAr).nArg != 0 {
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut pTest: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let zSel: *const libc::c_char = if (*pAr).bGlob as libc::c_int != 0 {
            b"SELECT name FROM %s WHERE glob($name,name)\0" as *const u8
                as *const libc::c_char
        } else {
            b"SELECT name FROM %s WHERE name=$name\0" as *const u8 as *const libc::c_char
        };
        shellPreparePrintf(
            (*pAr).db,
            &mut rc as *mut libc::c_int,
            &mut pTest as *mut *mut sqlite3_stmt,
            zSel,
            (*pAr).zSrcTable,
        );
        j = sqlite3_bind_parameter_index(
            pTest,
            b"$name\0" as *const u8 as *const libc::c_char,
        );
        i = 0 as libc::c_int;
        while i < (*pAr).nArg && rc == 0 as libc::c_int {
            let z: *mut libc::c_char = *((*pAr).azArg).offset(i as isize);
            let mut n: libc::c_int = strlen30(z);
            let mut bOk: libc::c_int = 0 as libc::c_int;
            while n > 0 as libc::c_int
                && *z.offset((n - 1 as libc::c_int) as isize) as libc::c_int
                    == '/' as i32
            {
                n -= 1;
                n;
            }
            *z.offset(n as isize) = '\0' as i32 as libc::c_char;
            sqlite3_bind_text(pTest, j, z, -(1 as libc::c_int), None);
            if 100 as libc::c_int == sqlite3_step(pTest) {
                bOk = 1 as libc::c_int;
            }
            shellReset(&mut rc, pTest);
            if rc == 0 as libc::c_int && bOk == 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"not found in archive: %s\n\0" as *const u8 as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int;
            }
            i += 1;
            i;
        }
        shellFinalize(&mut rc, pTest);
    }
    return rc;
}
unsafe extern "C" fn arWhereClause(
    pRc: *mut libc::c_int,
    pAr: *mut ArCommand,
    pzWhere: *mut *mut libc::c_char,
) {
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let zSameOp: *const libc::c_char = if (*pAr).bGlob as libc::c_int != 0 {
        b"GLOB\0" as *const u8 as *const libc::c_char
    } else {
        b"=\0" as *const u8 as *const libc::c_char
    };
    if *pRc == 0 as libc::c_int {
        if (*pAr).nArg == 0 as libc::c_int {
            zWhere = sqlite3_mprintf(b"1\0" as *const u8 as *const libc::c_char);
        } else {
            let mut i: libc::c_int = 0;
            let mut zSep: *const libc::c_char = b"\0" as *const u8
                as *const libc::c_char;
            i = 0 as libc::c_int;
            while i < (*pAr).nArg {
                let z: *const libc::c_char = *((*pAr).azArg).offset(i as isize);
                zWhere = sqlite3_mprintf(
                    b"%z%s name %s '%q' OR substr(name,1,%d) %s '%q/'\0" as *const u8
                        as *const libc::c_char,
                    zWhere,
                    zSep,
                    zSameOp,
                    z,
                    strlen30(z) + 1 as libc::c_int,
                    zSameOp,
                    z,
                );
                if zWhere.is_null() {
                    *pRc = 7 as libc::c_int;
                    break;
                } else {
                    zSep = b" OR \0" as *const u8 as *const libc::c_char;
                    i += 1;
                    i;
                }
            }
        }
    }
    *pzWhere = zWhere;
}
unsafe extern "C" fn arListCommand(pAr: *mut ArCommand) -> libc::c_int {
    let zSql: *const libc::c_char = b"SELECT %s FROM %s WHERE %s\0" as *const u8
        as *const libc::c_char;
    let azCols: [*const libc::c_char; 2] = [
        b"name\0" as *const u8 as *const libc::c_char,
        b"lsmode(mode), sz, datetime(mtime, 'unixepoch'), name\0" as *const u8
            as *const libc::c_char,
    ];
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    rc = arCheckEntries(pAr);
    arWhereClause(&mut rc, pAr, &mut zWhere);
    shellPreparePrintf(
        (*pAr).db,
        &mut rc as *mut libc::c_int,
        &mut pSql as *mut *mut sqlite3_stmt,
        zSql,
        azCols[(*pAr).bVerbose as usize],
        (*pAr).zSrcTable,
        zWhere,
    );
    if (*pAr).bDryRun != 0 {
        fprintf(
            (*(*pAr).p).out,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_sql(pSql),
        );
    } else {
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            if (*pAr).bVerbose != 0 {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s % 10d  %s  %s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSql, 0 as libc::c_int),
                    sqlite3_column_int(pSql, 1 as libc::c_int),
                    sqlite3_column_text(pSql, 2 as libc::c_int),
                    sqlite3_column_text(pSql, 3 as libc::c_int),
                );
            } else {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSql, 0 as libc::c_int),
                );
            }
        }
    }
    shellFinalize(&mut rc, pSql);
    sqlite3_free(zWhere as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arRemoveCommand(pAr: *mut ArCommand) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    if (*pAr).nArg != 0 {
        rc = arCheckEntries(pAr);
        arWhereClause(&mut rc, pAr, &mut zWhere);
    }
    if rc == 0 as libc::c_int {
        zSql = sqlite3_mprintf(
            b"DELETE FROM %s WHERE %s;\0" as *const u8 as *const libc::c_char,
            (*pAr).zSrcTable,
            zWhere,
        );
        if (*pAr).bDryRun != 0 {
            fprintf(
                (*(*pAr).p).out,
                b"%s\n\0" as *const u8 as *const libc::c_char,
                zSql,
            );
        } else {
            let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
            rc = sqlite3_exec(
                (*pAr).db,
                b"SAVEPOINT ar;\0" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                rc = sqlite3_exec(
                    (*pAr).db,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    &mut zErr,
                );
                if rc != 0 as libc::c_int {
                    sqlite3_exec(
                        (*pAr).db,
                        b"ROLLBACK TO ar; RELEASE ar;\0" as *const u8
                            as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                } else {
                    rc = sqlite3_exec(
                        (*pAr).db,
                        b"RELEASE ar;\0" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                }
            }
            if !zErr.is_null() {
                fprintf(
                    stdout,
                    b"ERROR: %s\n\0" as *const u8 as *const libc::c_char,
                    zErr,
                );
                sqlite3_free(zErr as *mut libc::c_void);
            }
        }
    }
    sqlite3_free(zWhere as *mut libc::c_void);
    sqlite3_free(zSql as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arExtractCommand(pAr: *mut ArCommand) -> libc::c_int {
    let zSql1: *const libc::c_char = b"SELECT  ($dir || name), writefile(($dir || name), %s, mode, mtime) FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0) AND name NOT GLOB '*..[/\\]*'\0"
        as *const u8 as *const libc::c_char;
    let azExtraArg: [*const libc::c_char; 2] = [
        b"sqlar_uncompress(data, sz)\0" as *const u8 as *const libc::c_char,
        b"data\0" as *const u8 as *const libc::c_char,
    ];
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zDir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    rc = arCheckEntries(pAr);
    arWhereClause(&mut rc, pAr, &mut zWhere);
    if rc == 0 as libc::c_int {
        if !((*pAr).zDir).is_null() {
            zDir = sqlite3_mprintf(
                b"%s/\0" as *const u8 as *const libc::c_char,
                (*pAr).zDir,
            );
        } else {
            zDir = sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
        }
        if zDir.is_null() {
            rc = 7 as libc::c_int;
        }
    }
    shellPreparePrintf(
        (*pAr).db,
        &mut rc as *mut libc::c_int,
        &mut pSql as *mut *mut sqlite3_stmt,
        zSql1,
        azExtraArg[(*pAr).bZip as usize],
        (*pAr).zSrcTable,
        zWhere,
    );
    if rc == 0 as libc::c_int {
        j = sqlite3_bind_parameter_index(
            pSql,
            b"$dir\0" as *const u8 as *const libc::c_char,
        );
        sqlite3_bind_text(pSql, j, zDir, -(1 as libc::c_int), None);
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            j = sqlite3_bind_parameter_index(
                pSql,
                b"$dirOnly\0" as *const u8 as *const libc::c_char,
            );
            sqlite3_bind_int(pSql, j, i);
            if (*pAr).bDryRun != 0 {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    sqlite3_sql(pSql),
                );
            } else {
                while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql)
                {
                    if i == 0 as libc::c_int && (*pAr).bVerbose as libc::c_int != 0 {
                        fprintf(
                            (*(*pAr).p).out,
                            b"%s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_column_text(pSql, 0 as libc::c_int),
                        );
                    }
                }
            }
            shellReset(&mut rc, pSql);
            i += 1;
            i;
        }
        shellFinalize(&mut rc, pSql);
    }
    sqlite3_free(zDir as *mut libc::c_void);
    sqlite3_free(zWhere as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arExecSql(
    pAr: *mut ArCommand,
    zSql: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if (*pAr).bDryRun != 0 {
        fprintf((*(*pAr).p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zSql);
        rc = 0 as libc::c_int;
    } else {
        let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
        rc = sqlite3_exec((*pAr).db, zSql, None, 0 as *mut libc::c_void, &mut zErr);
        if !zErr.is_null() {
            fprintf(stdout, b"ERROR: %s\n\0" as *const u8 as *const libc::c_char, zErr);
            sqlite3_free(zErr as *mut libc::c_void);
        }
    }
    return rc;
}
unsafe extern "C" fn arCreateOrUpdateCommand(
    pAr: *mut ArCommand,
    bUpdate: libc::c_int,
    bOnlyIfChanged: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let zCreate: *const libc::c_char = b"CREATE TABLE IF NOT EXISTS sqlar(\n  name TEXT PRIMARY KEY,  -- name of the file\n  mode INT,               -- access permissions\n  mtime INT,              -- last modification time\n  sz INT,                 -- original file size\n  data BLOB               -- compressed content\n)\0"
        as *const u8 as *const libc::c_char;
    let zDrop: *const libc::c_char = b"DROP TABLE IF EXISTS sqlar\0" as *const u8
        as *const libc::c_char;
    let zInsertFmt: [*const libc::c_char; 2] = [
        b"REPLACE INTO %s(name,mode,mtime,sz,data)\n  SELECT\n    %s,\n    mode,\n    mtime,\n    CASE substr(lsmode(mode),1,1)\n      WHEN '-' THEN length(data)\n      WHEN 'd' THEN 0\n      ELSE -1 END,\n    sqlar_compress(data)\n  FROM fsdir(%Q,%Q) AS disk\n  WHERE lsmode(mode) NOT LIKE '?%%'%s;\0"
            as *const u8 as *const libc::c_char,
        b"REPLACE INTO %s(name,mode,mtime,data)\n  SELECT\n    %s,\n    mode,\n    mtime,\n    data\n  FROM fsdir(%Q,%Q) AS disk\n  WHERE lsmode(mode) NOT LIKE '?%%'%s;\0"
            as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut zTab: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zTemp: [libc::c_char; 50] = [0; 50];
    let mut zExists: *mut libc::c_char = 0 as *mut libc::c_char;
    arExecSql(pAr, b"PRAGMA page_size=512\0" as *const u8 as *const libc::c_char);
    rc = arExecSql(pAr, b"SAVEPOINT ar;\0" as *const u8 as *const libc::c_char);
    if rc != 0 as libc::c_int {
        return rc;
    }
    zTemp[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    if (*pAr).bZip != 0 {
        if !((*pAr).zFile).is_null() {
            let mut r: sqlite3_uint64 = 0;
            sqlite3_randomness(
                ::core::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
                &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
            );
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong
                    as libc::c_int,
                zTemp.as_mut_ptr(),
                b"zip%016llx\0" as *const u8 as *const libc::c_char,
                r,
            );
            zTab = zTemp.as_mut_ptr();
            zSql = sqlite3_mprintf(
                b"CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)\0" as *const u8
                    as *const libc::c_char,
                zTab,
                (*pAr).zFile,
            );
            rc = arExecSql(pAr, zSql);
            sqlite3_free(zSql as *mut libc::c_void);
        } else {
            zTab = b"zip\0" as *const u8 as *const libc::c_char;
        }
        current_block = 11584701595673473500;
    } else {
        zTab = b"sqlar\0" as *const u8 as *const libc::c_char;
        if bUpdate == 0 as libc::c_int {
            rc = arExecSql(pAr, zDrop);
            if rc != 0 as libc::c_int {
                current_block = 8732950637305026731;
            } else {
                current_block = 13242334135786603907;
            }
        } else {
            current_block = 13242334135786603907;
        }
        match current_block {
            8732950637305026731 => {}
            _ => {
                rc = arExecSql(pAr, zCreate);
                current_block = 11584701595673473500;
            }
        }
    }
    match current_block {
        11584701595673473500 => {
            if bOnlyIfChanged != 0 {
                zExists = sqlite3_mprintf(
                    b" AND NOT EXISTS(SELECT 1 FROM %s AS mem WHERE mem.name=disk.name AND mem.mtime=disk.mtime AND mem.mode=disk.mode)\0"
                        as *const u8 as *const libc::c_char,
                    zTab,
                );
            } else {
                zExists = sqlite3_mprintf(b"\0" as *const u8 as *const libc::c_char);
            }
            if zExists.is_null() {
                rc = 7 as libc::c_int;
            }
            i = 0 as libc::c_int;
            while i < (*pAr).nArg && rc == 0 as libc::c_int {
                let zSql2: *mut libc::c_char = sqlite3_mprintf(
                    zInsertFmt[(*pAr).bZip as usize],
                    zTab,
                    if (*pAr).bVerbose as libc::c_int != 0 {
                        b"shell_putsnl(name)\0" as *const u8 as *const libc::c_char
                    } else {
                        b"name\0" as *const u8 as *const libc::c_char
                    },
                    *((*pAr).azArg).offset(i as isize),
                    (*pAr).zDir,
                    zExists,
                );
                rc = arExecSql(pAr, zSql2);
                sqlite3_free(zSql2 as *mut libc::c_void);
                i += 1;
                i;
            }
        }
        _ => {}
    }
    if rc != 0 as libc::c_int {
        sqlite3_exec(
            (*pAr).db,
            b"ROLLBACK TO ar; RELEASE ar;\0" as *const u8 as *const libc::c_char,
            None,
            0 as *mut libc::c_void,
            0 as *mut *mut libc::c_char,
        );
    } else {
        rc = arExecSql(pAr, b"RELEASE ar;\0" as *const u8 as *const libc::c_char);
        if (*pAr).bZip as libc::c_int != 0 && !((*pAr).zFile).is_null() {
            zSql = sqlite3_mprintf(
                b"DROP TABLE %s\0" as *const u8 as *const libc::c_char,
                zTemp.as_mut_ptr(),
            );
            arExecSql(pAr, zSql);
            sqlite3_free(zSql as *mut libc::c_void);
        }
    }
    sqlite3_free(zExists as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn arDotCommand(
    pState: *mut ShellState,
    fromCmdLine: libc::c_int,
    azArg: *mut *mut libc::c_char,
    nArg: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut cmd: ArCommand = ArCommand {
        eCmd: 0,
        bVerbose: 0,
        bZip: 0,
        bDryRun: 0,
        bAppend: 0,
        bGlob: 0,
        fromCmdLine: 0,
        nArg: 0,
        zSrcTable: 0 as *mut libc::c_char,
        zFile: 0 as *const libc::c_char,
        zDir: 0 as *const libc::c_char,
        azArg: 0 as *mut *mut libc::c_char,
        p: 0 as *mut ShellState,
        db: 0 as *mut sqlite3,
    };
    let mut rc: libc::c_int = 0;
    memset(
        &mut cmd as *mut ArCommand as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ArCommand>() as libc::c_ulong,
    );
    cmd.fromCmdLine = fromCmdLine as u8_0;
    rc = arParseCommand(azArg, nArg, &mut cmd);
    if rc == 0 as libc::c_int {
        let mut eDbType: libc::c_int = 0 as libc::c_int;
        cmd.p = pState;
        cmd.db = (*pState).db;
        if !(cmd.zFile).is_null() {
            eDbType = deduceDatabaseType(cmd.zFile, 1 as libc::c_int);
        } else {
            eDbType = (*pState).openMode as libc::c_int;
        }
        if eDbType == 3 as libc::c_int {
            if cmd.eCmd as libc::c_int == 4 as libc::c_int
                || cmd.eCmd as libc::c_int == 5 as libc::c_int
            {
                if (cmd.zFile).is_null() {
                    cmd
                        .zSrcTable = sqlite3_mprintf(
                        b"zip\0" as *const u8 as *const libc::c_char,
                    );
                } else {
                    cmd
                        .zSrcTable = sqlite3_mprintf(
                        b"zipfile(%Q)\0" as *const u8 as *const libc::c_char,
                        cmd.zFile,
                    );
                }
            }
            cmd.bZip = 1 as libc::c_int as u8_0;
            current_block = 15897653523371991391;
        } else if !(cmd.zFile).is_null() {
            let mut flags: libc::c_int = 0;
            if cmd.bAppend != 0 {
                eDbType = 2 as libc::c_int;
            }
            if cmd.eCmd as libc::c_int == 1 as libc::c_int
                || cmd.eCmd as libc::c_int == 3 as libc::c_int
                || cmd.eCmd as libc::c_int == 7 as libc::c_int
                || cmd.eCmd as libc::c_int == 2 as libc::c_int
            {
                flags = 0x2 as libc::c_int | 0x4 as libc::c_int;
            } else {
                flags = 0x1 as libc::c_int;
            }
            cmd.db = 0 as *mut sqlite3;
            if cmd.bDryRun != 0 {
                fprintf(
                    (*pState).out,
                    b"-- open database '%s'%s\n\0" as *const u8 as *const libc::c_char,
                    cmd.zFile,
                    if eDbType == 2 as libc::c_int {
                        b" using 'apndvfs'\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
            }
            rc = sqlite3_open_v2(
                cmd.zFile,
                &mut cmd.db,
                flags,
                if eDbType == 2 as libc::c_int {
                    b"apndvfs\0" as *const u8 as *const libc::c_char
                } else {
                    0 as *const libc::c_char
                },
            );
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"cannot open file: %s (%s)\n\0" as *const u8 as *const libc::c_char,
                    cmd.zFile,
                    sqlite3_errmsg(cmd.db),
                );
                current_block = 16630776850499120253;
            } else {
                sqlite3_fileio_init(
                    cmd.db,
                    0 as *mut *mut libc::c_char,
                    0 as *const sqlite3_api_routines,
                );
                sqlite3_sqlar_init(
                    cmd.db,
                    0 as *mut *mut libc::c_char,
                    0 as *const sqlite3_api_routines,
                );
                sqlite3_create_function(
                    cmd.db,
                    b"shell_putsnl\0" as *const u8 as *const libc::c_char,
                    1 as libc::c_int,
                    1 as libc::c_int,
                    cmd.p as *mut libc::c_void,
                    Some(
                        shellPutsFunc
                            as unsafe extern "C" fn(
                                *mut sqlite3_context,
                                libc::c_int,
                                *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                    None,
                    None,
                );
                current_block = 15897653523371991391;
            }
        } else {
            current_block = 15897653523371991391;
        }
        match current_block {
            16630776850499120253 => {}
            _ => {
                if (cmd.zSrcTable).is_null()
                    && cmd.bZip as libc::c_int == 0 as libc::c_int
                    && cmd.eCmd as libc::c_int != 6 as libc::c_int
                {
                    if cmd.eCmd as libc::c_int != 1 as libc::c_int
                        && sqlite3_table_column_metadata(
                            cmd.db,
                            0 as *const libc::c_char,
                            b"sqlar\0" as *const u8 as *const libc::c_char,
                            b"name\0" as *const u8 as *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                        ) != 0
                    {
                        fprintf(
                            stderr,
                            b"database does not contain an 'sqlar' table\n\0"
                                as *const u8 as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 16630776850499120253;
                    } else {
                        cmd
                            .zSrcTable = sqlite3_mprintf(
                            b"sqlar\0" as *const u8 as *const libc::c_char,
                        );
                        current_block = 10692455896603418738;
                    }
                } else {
                    current_block = 10692455896603418738;
                }
                match current_block {
                    16630776850499120253 => {}
                    _ => {
                        match cmd.eCmd as libc::c_int {
                            1 => {
                                rc = arCreateOrUpdateCommand(
                                    &mut cmd,
                                    0 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            }
                            4 => {
                                rc = arExtractCommand(&mut cmd);
                            }
                            5 => {
                                rc = arListCommand(&mut cmd);
                            }
                            6 => {
                                arUsage((*pState).out);
                            }
                            3 => {
                                rc = arCreateOrUpdateCommand(
                                    &mut cmd,
                                    1 as libc::c_int,
                                    0 as libc::c_int,
                                );
                            }
                            7 => {
                                rc = arRemoveCommand(&mut cmd);
                            }
                            _ => {
                                if cmd.eCmd as libc::c_int == 2 as libc::c_int {} else {
                                    __assert_fail(
                                        b"cmd.eCmd==AR_CMD_UPDATE\0" as *const u8
                                            as *const libc::c_char,
                                        b"shell.c\0" as *const u8 as *const libc::c_char,
                                        23482 as libc::c_int as libc::c_uint,
                                        (*::core::mem::transmute::<
                                            &[u8; 50],
                                            &[libc::c_char; 50],
                                        >(b"int arDotCommand(ShellState *, int, char **, int)\0"))
                                            .as_ptr(),
                                    );
                                }
                                'c_125492: {
                                    if cmd.eCmd as libc::c_int == 2 as libc::c_int {} else {
                                        __assert_fail(
                                            b"cmd.eCmd==AR_CMD_UPDATE\0" as *const u8
                                                as *const libc::c_char,
                                            b"shell.c\0" as *const u8 as *const libc::c_char,
                                            23482 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 50],
                                                &[libc::c_char; 50],
                                            >(b"int arDotCommand(ShellState *, int, char **, int)\0"))
                                                .as_ptr(),
                                        );
                                    }
                                };
                                rc = arCreateOrUpdateCommand(
                                    &mut cmd,
                                    1 as libc::c_int,
                                    1 as libc::c_int,
                                );
                            }
                        }
                    }
                }
            }
        }
    }
    if cmd.db != (*pState).db {
        close_db(cmd.db);
    }
    sqlite3_free(cmd.zSrcTable as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn recoverSqlCb(
    pCtx: *mut libc::c_void,
    zSql: *const libc::c_char,
) -> libc::c_int {
    let pState: *mut ShellState = pCtx as *mut ShellState;
    fprintf((*pState).out, b"%s;\n\0" as *const u8 as *const libc::c_char, zSql);
    return 0 as libc::c_int;
}
unsafe extern "C" fn recoverDatabaseCmd(
    pState: *mut ShellState,
    nArg: libc::c_int,
    azArg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zRecoveryDb: *const libc::c_char = b"\0" as *const u8 as *const libc::c_char;
    let mut zLAF: *const libc::c_char = b"lost_and_found\0" as *const u8
        as *const libc::c_char;
    let mut bFreelist: libc::c_int = 1 as libc::c_int;
    let mut bRowids: libc::c_int = 1 as libc::c_int;
    let mut p: *mut sqlite3_recover = 0 as *mut sqlite3_recover;
    let mut i: libc::c_int = 0 as libc::c_int;
    i = 1 as libc::c_int;
    while i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1);
            z;
        }
        n = strlen30(z);
        if n <= 17 as libc::c_int
            && memcmp(
                b"-ignore-freelist\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            bFreelist = 0 as libc::c_int;
        } else if n <= 12 as libc::c_int
            && memcmp(
                b"-recovery-db\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int && i < nArg - 1 as libc::c_int
        {
            i += 1;
            i;
            zRecoveryDb = *azArg.offset(i as isize);
        } else if n <= 15 as libc::c_int
            && memcmp(
                b"-lost-and-found\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int && i < nArg - 1 as libc::c_int
        {
            i += 1;
            i;
            zLAF = *azArg.offset(i as isize);
        } else if n <= 10 as libc::c_int
            && memcmp(
                b"-no-rowids\0" as *const u8 as *const libc::c_char
                    as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            bRowids = 0 as libc::c_int;
        } else {
            fprintf(
                stderr,
                b"unexpected option: %s\n\0" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
            );
            showHelp((*pState).out, *azArg.offset(0 as libc::c_int as isize));
            return 1 as libc::c_int;
        }
        i += 1;
        i;
    }
    p = sqlite3_recover_init_sql(
        (*pState).db,
        b"main\0" as *const u8 as *const libc::c_char,
        Some(
            recoverSqlCb
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    *const libc::c_char,
                ) -> libc::c_int,
        ),
        pState as *mut libc::c_void,
    );
    sqlite3_recover_config(p, 789 as libc::c_int, zRecoveryDb as *mut libc::c_void);
    sqlite3_recover_config(p, 1 as libc::c_int, zLAF as *mut libc::c_void);
    sqlite3_recover_config(
        p,
        3 as libc::c_int,
        &mut bRowids as *mut libc::c_int as *mut libc::c_void,
    );
    sqlite3_recover_config(
        p,
        2 as libc::c_int,
        &mut bFreelist as *mut libc::c_int as *mut libc::c_void,
    );
    sqlite3_recover_run(p);
    if sqlite3_recover_errcode(p) != 0 as libc::c_int {
        let zErr: *const libc::c_char = sqlite3_recover_errmsg(p);
        let errCode: libc::c_int = sqlite3_recover_errcode(p);
        fprintf(
            stderr,
            b"sql error: %s (%d)\n\0" as *const u8 as *const libc::c_char,
            zErr,
            errCode,
        );
    }
    rc = sqlite3_recover_finish(p);
    return rc;
}
unsafe extern "C" fn rc_err_oom_die(rc: libc::c_int) {
    if rc == 7 as libc::c_int {
        shell_check_oom(0 as *const libc::c_void);
    }
    if rc == 0 as libc::c_int || rc == 101 as libc::c_int {} else {
        __assert_fail(
            b"rc==SQLITE_OK||rc==SQLITE_DONE\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            23598 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 25],
                &[libc::c_char; 25],
            >(b"void rc_err_oom_die(int)\0"))
                .as_ptr(),
        );
    }
    'c_115369: {
        if rc == 0 as libc::c_int || rc == 101 as libc::c_int {} else {
            __assert_fail(
                b"rc==SQLITE_OK||rc==SQLITE_DONE\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                23598 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 25],
                    &[libc::c_char; 25],
                >(b"void rc_err_oom_die(int)\0"))
                    .as_ptr(),
            );
        }
    };
}
static mut zCOL_DB: *const libc::c_char = b":memory:\0" as *const u8
    as *const libc::c_char;
unsafe extern "C" fn zAutoColumn(
    zColNew: *const libc::c_char,
    pDb: *mut *mut sqlite3,
    pzRenamed: *mut *mut libc::c_char,
) -> *mut libc::c_char {
    static mut zTabMake: *const libc::c_char = b"CREATE TABLE ColNames( cpos INTEGER PRIMARY KEY, name TEXT, nlen INT, chop INT, reps INT, suff TEXT);CREATE VIEW RepeatedNames AS SELECT DISTINCT t.name FROM ColNames t WHERE t.name COLLATE NOCASE IN ( SELECT o.name FROM ColNames o WHERE o.cpos<>t.cpos);\0"
        as *const u8 as *const libc::c_char;
    static mut zTabFill: *const libc::c_char = b"INSERT INTO ColNames(name,nlen,chop,reps,suff) VALUES(iif(length(?1)>0,?1,'?'),max(length(?1),1),0,0,'')\0"
        as *const u8 as *const libc::c_char;
    static mut zHasDupes: *const libc::c_char = b"SELECT count(DISTINCT (substring(name,1,nlen-chop)||suff) COLLATE NOCASE) <count(name) FROM ColNames\0"
        as *const u8 as *const libc::c_char;
    static mut zSetReps: *const libc::c_char = b"UPDATE ColNames AS t SET reps=(SELECT count(*) FROM ColNames d  WHERE substring(t.name,1,t.nlen-t.chop)=substring(d.name,1,d.nlen-d.chop) COLLATE NOCASE)\0"
        as *const u8 as *const libc::c_char;
    static mut zColDigits: *const libc::c_char = b"SELECT CAST(ceil(log(count(*)+0.5)) AS INT) FROM ColNames \0"
        as *const u8 as *const libc::c_char;
    static mut zRenameRank: *const libc::c_char = b"WITH Lzn(nlz) AS (  SELECT 0 AS nlz  UNION  SELECT nlz+1 AS nlz FROM Lzn  WHERE EXISTS(   SELECT 1   FROM ColNames t, ColNames o   WHERE    iif(t.name IN (SELECT * FROM RepeatedNames),     printf('%s_%s',      t.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,t.cpos),2)),     t.name    )    =    iif(o.name IN (SELECT * FROM RepeatedNames),     printf('%s_%s',      o.name, substring(printf('%.*c%0.*d',nlz+1,'0',$1,o.cpos),2)),     o.name    )    COLLATE NOCASE    AND o.cpos<>t.cpos   GROUP BY t.cpos  )) UPDATE Colnames AS t SET chop = 0, suff = iif(name IN (SELECT * FROM RepeatedNames),  printf('_%s', substring(   printf('%.*c%0.*d',(SELECT max(nlz) FROM Lzn)+1,'0',1,t.cpos),2)),  '' )\0"
        as *const u8 as *const libc::c_char;
    static mut zCollectVar: *const libc::c_char = b"SELECT '('||x'0a' || group_concat(  cname||' TEXT',  ','||iif((cpos-1)%4>0, ' ', x'0a'||' ')) ||')' AS ColsSpec FROM ( SELECT cpos, printf('\"%w\"',printf('%!.*s%s', nlen-chop,name,suff)) AS cname  FROM ColNames ORDER BY cpos)\0"
        as *const u8 as *const libc::c_char;
    static mut zRenamesDone: *const libc::c_char = b"SELECT group_concat( printf('\"%w\" to \"%w\"',name,printf('%!.*s%s', nlen-chop, name, suff)), ','||x'0a')FROM ColNames WHERE suff<>'' OR chop!=0\0"
        as *const u8 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    if !pDb.is_null() {} else {
        __assert_fail(
            b"pDb!=0\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            23724 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 53],
                &[libc::c_char; 53],
            >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                .as_ptr(),
        );
    }
    'c_115784: {
        if !pDb.is_null() {} else {
            __assert_fail(
                b"pDb!=0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                23724 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 53],
                    &[libc::c_char; 53],
                >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                    .as_ptr(),
            );
        }
    };
    if !zColNew.is_null() {
        if (*pDb).is_null() {
            if 0 as libc::c_int != sqlite3_open(zCOL_DB, pDb) {
                return 0 as *mut libc::c_char;
            }
            rc = sqlite3_exec(
                *pDb,
                zTabMake,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            rc_err_oom_die(rc);
        }
        if !(*pDb).is_null() {} else {
            __assert_fail(
                b"*pDb!=0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                23737 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 53],
                    &[libc::c_char; 53],
                >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                    .as_ptr(),
            );
        }
        'c_115689: {
            if !(*pDb).is_null() {} else {
                __assert_fail(
                    b"*pDb!=0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    23737 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 53],
                        &[libc::c_char; 53],
                    >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                        .as_ptr(),
                );
            }
        };
        rc = sqlite3_prepare_v2(
            *pDb,
            zTabFill,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_bind_text(
            pStmt,
            1 as libc::c_int,
            zColNew,
            -(1 as libc::c_int),
            None,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_step(pStmt);
        rc_err_oom_die(rc);
        sqlite3_finalize(pStmt);
        return 0 as *mut libc::c_char;
    } else if (*pDb).is_null() {
        return 0 as *mut libc::c_char
    } else {
        let mut zColsSpec: *mut libc::c_char = 0 as *mut libc::c_char;
        let hasDupes: libc::c_int = db_int(*pDb, zHasDupes);
        let nDigits: libc::c_int = if hasDupes != 0 {
            db_int(*pDb, zColDigits)
        } else {
            0 as libc::c_int
        };
        if hasDupes != 0 {
            rc = sqlite3_exec(
                *pDb,
                zSetReps,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            rc_err_oom_die(rc);
            rc = sqlite3_prepare_v2(
                *pDb,
                zRenameRank,
                -(1 as libc::c_int),
                &mut pStmt,
                0 as *mut *const libc::c_char,
            );
            rc_err_oom_die(rc);
            sqlite3_bind_int(pStmt, 1 as libc::c_int, nDigits);
            rc = sqlite3_step(pStmt);
            sqlite3_finalize(pStmt);
            if rc != 101 as libc::c_int {
                rc_err_oom_die(7 as libc::c_int);
            }
        }
        if db_int(*pDb, zHasDupes) == 0 as libc::c_int {} else {
            __assert_fail(
                b"db_int(*pDb, zHasDupes)==0\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                23767 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 53],
                    &[libc::c_char; 53],
                >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                    .as_ptr(),
            );
        }
        'c_115446: {
            if db_int(*pDb, zHasDupes) == 0 as libc::c_int {} else {
                __assert_fail(
                    b"db_int(*pDb, zHasDupes)==0\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    23767 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 53],
                        &[libc::c_char; 53],
                    >(b"char *zAutoColumn(const char *, sqlite3 **, char **)\0"))
                        .as_ptr(),
                );
            }
        };
        rc = sqlite3_prepare_v2(
            *pDb,
            zCollectVar,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        rc_err_oom_die(rc);
        rc = sqlite3_step(pStmt);
        if rc == 100 as libc::c_int {
            zColsSpec = sqlite3_mprintf(
                b"%s\0" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, 0 as libc::c_int),
            );
        } else {
            zColsSpec = 0 as *mut libc::c_char;
        }
        if !pzRenamed.is_null() {
            if hasDupes == 0 {
                *pzRenamed = 0 as *mut libc::c_char;
            } else {
                sqlite3_finalize(pStmt);
                if 0 as libc::c_int
                    == sqlite3_prepare_v2(
                        *pDb,
                        zRenamesDone,
                        -(1 as libc::c_int),
                        &mut pStmt,
                        0 as *mut *const libc::c_char,
                    ) && 100 as libc::c_int == sqlite3_step(pStmt)
                {
                    *pzRenamed = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        sqlite3_column_text(pStmt, 0 as libc::c_int),
                    );
                } else {
                    *pzRenamed = 0 as *mut libc::c_char;
                }
            }
        }
        sqlite3_finalize(pStmt);
        sqlite3_close(*pDb);
        *pDb = 0 as *mut sqlite3;
        return zColsSpec;
    };
}
unsafe extern "C" fn do_meta_command(
    zLine: *mut libc::c_char,
    p: *mut ShellState,
) -> libc::c_int {
    let mut dbCols: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zRenames: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zColDefs: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut current_block: u64;
    let mut h: libc::c_int = 1 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut azArg: [*mut libc::c_char; 52] = [0 as *mut libc::c_char; 52];
    if !((*p).expert.pExpert).is_null() {
        expertFinish(p, 1 as libc::c_int, 0 as *mut *mut libc::c_char);
    }
    while *zLine.offset(h as isize) as libc::c_int != 0
        && nArg
            < (::core::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as libc::c_int - 1 as libc::c_int
    {
        while *(*__ctype_b_loc())
            .offset(*zLine.offset(h as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            h += 1;
            h;
        }
        if *zLine.offset(h as isize) as libc::c_int == 0 as libc::c_int {
            break;
        }
        if *zLine.offset(h as isize) as libc::c_int == '\'' as i32
            || *zLine.offset(h as isize) as libc::c_int == '"' as i32
        {
            let fresh112 = h;
            h = h + 1;
            let delim: libc::c_int = *zLine.offset(fresh112 as isize) as libc::c_int;
            let fresh113 = nArg;
            nArg = nArg + 1;
            azArg[fresh113
                as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *zLine.offset(h as isize) as libc::c_int != delim
            {
                if *zLine.offset(h as isize) as libc::c_int == '\\' as i32
                    && delim == '"' as i32
                    && *zLine.offset((h + 1 as libc::c_int) as isize) as libc::c_int
                        != 0 as libc::c_int
                {
                    h += 1;
                    h;
                }
                h += 1;
                h;
            }
            if *zLine.offset(h as isize) as libc::c_int == delim {
                let fresh114 = h;
                h = h + 1;
                *zLine.offset(fresh114 as isize) = 0 as libc::c_int as libc::c_char;
            }
            if delim == '"' as i32 {
                resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
            }
        } else {
            let fresh115 = nArg;
            nArg = nArg + 1;
            azArg[fresh115
                as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *(*__ctype_b_loc())
                    .offset(
                        *zLine.offset(h as isize) as libc::c_uchar as libc::c_int
                            as isize,
                    ) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int == 0
            {
                h += 1;
                h;
            }
            if *zLine.offset(h as isize) != 0 {
                let fresh116 = h;
                h = h + 1;
                *zLine.offset(fresh116 as isize) = 0 as libc::c_int as libc::c_char;
            }
            resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
        }
    }
    azArg[nArg as usize] = 0 as *mut libc::c_char;
    if nArg == 0 as libc::c_int {
        return 0 as libc::c_int;
    }
    n = strlen30(azArg[0 as libc::c_int as usize]);
    c = *(azArg[0 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
        as libc::c_int;
    clearTempFile(p);
    if c == 'a' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"auth\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .auth ON|OFF\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            if booleanValue(azArg[1 as libc::c_int as usize]) != 0 {
                sqlite3_set_authorizer(
                    (*p).db,
                    Some(
                        shellAuth
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            } else if (*p).bSafeModePersist != 0 {
                sqlite3_set_authorizer(
                    (*p).db,
                    Some(
                        safeModeAuth
                            as unsafe extern "C" fn(
                                *mut libc::c_void,
                                libc::c_int,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                                *const libc::c_char,
                            ) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            } else {
                sqlite3_set_authorizer((*p).db, None, 0 as *mut libc::c_void);
            }
        }
    } else if c == 'a' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"archive\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        failIfSafeMode(
            p,
            b"cannot run .archive in safe mode\0" as *const u8 as *const libc::c_char,
        );
        rc = arDotCommand(p, 0 as libc::c_int, azArg.as_mut_ptr(), nArg);
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"backup\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        || c == 's' as i32 && n >= 3 as libc::c_int
            && cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"save\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int
    {
        let mut zDestFile: *const libc::c_char = 0 as *const libc::c_char;
        let mut zDb: *const libc::c_char = 0 as *const libc::c_char;
        let mut pDest: *mut sqlite3 = 0 as *mut sqlite3;
        let mut pBackup: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
        let mut j: libc::c_int = 0;
        let mut bAsync: libc::c_int = 0 as libc::c_int;
        let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        j = 1 as libc::c_int;
        while j < nArg {
            let mut z: *const libc::c_char = azArg[j as usize];
            if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z = z.offset(1);
                    z;
                }
                if cli_strcmp(z, b"-append\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zVfs = b"apndvfs\0" as *const u8 as *const libc::c_char;
                } else if cli_strcmp(z, b"-async\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bAsync = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                        azArg[j as usize],
                    );
                    return 1 as libc::c_int;
                }
            } else if zDestFile.is_null() {
                zDestFile = azArg[j as usize];
            } else if zDb.is_null() {
                zDb = zDestFile;
                zDestFile = azArg[j as usize];
            } else {
                fprintf(
                    stderr,
                    b"Usage: .backup ?DB? ?OPTIONS? FILENAME\n\0" as *const u8
                        as *const libc::c_char,
                );
                return 1 as libc::c_int;
            }
            j += 1;
            j;
        }
        if zDestFile.is_null() {
            fprintf(
                stderr,
                b"missing FILENAME argument on .backup\n\0" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        }
        if zDb.is_null() {
            zDb = b"main\0" as *const u8 as *const libc::c_char;
        }
        rc = sqlite3_open_v2(
            zDestFile,
            &mut pDest,
            0x2 as libc::c_int | 0x4 as libc::c_int,
            zVfs,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zDestFile,
            );
            close_db(pDest);
            return 1 as libc::c_int;
        }
        if bAsync != 0 {
            sqlite3_exec(
                pDest,
                b"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\0" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
        }
        open_db(p, 0 as libc::c_int);
        pBackup = sqlite3_backup_init(
            pDest,
            b"main\0" as *const u8 as *const libc::c_char,
            (*p).db,
            zDb,
        );
        if pBackup.is_null() {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(pDest),
            );
            close_db(pDest);
            return 1 as libc::c_int;
        }
        loop {
            rc = sqlite3_backup_step(pBackup, 100 as libc::c_int);
            if !(rc == 0 as libc::c_int) {
                break;
            }
        }
        sqlite3_backup_finish(pBackup);
        if rc == 101 as libc::c_int {
            rc = 0 as libc::c_int;
        } else {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(pDest),
            );
            rc = 1 as libc::c_int;
        }
        close_db(pDest);
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"bail\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            bail_on_error = booleanValue(azArg[1 as libc::c_int as usize]);
        } else {
            fprintf(
                stderr,
                b"Usage: .bail on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"binary\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            booleanValue(azArg[1 as libc::c_int as usize]) != 0;
        } else {
            fprintf(
                stderr,
                b"The \".binary\" command is deprecated. Use \".crnl\" instead.\n\0"
                    as *const u8 as *const libc::c_char,
            );
            fprintf(
                stderr,
                b"Usage: .binary on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'b' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"breakpoint\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        test_breakpoint();
    } else if c == 'c' as i32
        && cli_strcmp(
            azArg[0 as libc::c_int as usize],
            b"cd\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .cd in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            rc = chdir(azArg[1 as libc::c_int as usize]);
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Cannot change to directory \"%s\"\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                rc = 1 as libc::c_int;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .cd DIRECTORY\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"changes\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            setOrClearFlag(
                p,
                0x20 as libc::c_int as libc::c_uint,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .changes on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"check\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zRes: *mut libc::c_char = 0 as *mut libc::c_char;
        output_reset(p);
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .check GLOB-PATTERN\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 2 as libc::c_int;
        } else {
            zRes = readFile(
                b"testcase-out.txt\0" as *const u8 as *const libc::c_char,
                0 as *mut libc::c_int,
            );
            if zRes.is_null() {
                rc = 2 as libc::c_int;
            } else if testcase_glob(azArg[1 as libc::c_int as usize], zRes)
                == 0 as libc::c_int
            {
                fprintf(
                    stderr,
                    b"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n\0"
                        as *const u8 as *const libc::c_char,
                    ((*p).zTestcase).as_mut_ptr(),
                    azArg[1 as libc::c_int as usize],
                    zRes,
                );
                rc = 1 as libc::c_int;
            } else {
                fprintf(
                    stdout,
                    b"testcase-%s ok\n\0" as *const u8 as *const libc::c_char,
                    ((*p).zTestcase).as_mut_ptr(),
                );
                (*p).nCheck += 1;
                (*p).nCheck;
            }
        }
        sqlite3_free(zRes as *mut libc::c_void);
    } else if c == 'c' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"clone\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        failIfSafeMode(
            p,
            b"cannot run .clone in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            tryToClone(p, azArg[1 as libc::c_int as usize]);
        } else {
            fprintf(
                stderr,
                b"Usage: .clone FILENAME\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"connection\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 1 as libc::c_int {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                    .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
                    as libc::c_int
            {
                let mut zFile: *const libc::c_char = (*p).aAuxDb[i as usize].zDbFilename;
                if ((*p).aAuxDb[i as usize].db).is_null()
                    && (*p).pAuxDb
                        != &mut *((*p).aAuxDb).as_mut_ptr().offset(i as isize)
                            as *mut AuxDb
                {
                    zFile = b"(not open)\0" as *const u8 as *const libc::c_char;
                } else if zFile.is_null() {
                    zFile = b"(memory)\0" as *const u8 as *const libc::c_char;
                } else if *zFile.offset(0 as libc::c_int as isize) as libc::c_int
                    == 0 as libc::c_int
                {
                    zFile = b"(temporary-file)\0" as *const u8 as *const libc::c_char;
                }
                if (*p).pAuxDb
                    == &mut *((*p).aAuxDb).as_mut_ptr().offset(i as isize) as *mut AuxDb
                {
                    fprintf(
                        stdout,
                        b"ACTIVE %d: %s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        zFile,
                    );
                } else if !((*p).aAuxDb[i as usize].db).is_null() {
                    fprintf(
                        stdout,
                        b"       %d: %s\n\0" as *const u8 as *const libc::c_char,
                        i,
                        zFile,
                    );
                }
                i += 1;
                i;
            }
        } else if nArg == 2 as libc::c_int
            && *(*__ctype_b_loc())
                .offset(
                    *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            && *(azArg[1 as libc::c_int as usize]).offset(1 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            let i_0: libc::c_int = *(azArg[1 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32;
            if (*p).pAuxDb
                != &mut *((*p).aAuxDb).as_mut_ptr().offset(i_0 as isize) as *mut AuxDb
                && i_0 >= 0 as libc::c_int
                && i_0
                    < (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int
            {
                (*(*p).pAuxDb).db = (*p).db;
                (*p)
                    .pAuxDb = &mut *((*p).aAuxDb).as_mut_ptr().offset(i_0 as isize)
                    as *mut AuxDb;
                (*p).db = (*(*p).pAuxDb).db;
                globalDb = (*p).db;
                (*(*p).pAuxDb).db = 0 as *mut sqlite3;
            }
        } else if nArg == 3 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"close\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            && *(*__ctype_b_loc())
                .offset(
                    *(azArg[2 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int != 0
            && *(azArg[2 as libc::c_int as usize]).offset(1 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            let i_1: libc::c_int = *(azArg[2 as libc::c_int as usize])
                .offset(0 as libc::c_int as isize) as libc::c_int - '0' as i32;
            if !(i_1 < 0 as libc::c_int
                || i_1
                    >= (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int)
            {
                if (*p).pAuxDb
                    == &mut *((*p).aAuxDb).as_mut_ptr().offset(i_1 as isize)
                        as *mut AuxDb
                {
                    fprintf(
                        stderr,
                        b"cannot close the active database connection\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                } else if !((*p).aAuxDb[i_1 as usize].db).is_null() {
                    close_db((*p).aAuxDb[i_1 as usize].db);
                    (*p).aAuxDb[i_1 as usize].db = 0 as *mut sqlite3;
                }
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .connection [close] [CONNECTION-NUMBER]\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'c' as i32 && n == 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"crnl\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            booleanValue(azArg[1 as libc::c_int as usize]) != 0;
        } else {
            fprintf(
                stderr,
                b"The \".crnl\" is a no-op on non-Windows machines.\n\0" as *const u8
                    as *const libc::c_char,
            );
            fprintf(
                stderr,
                b"Usage: .crnl on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'd' as i32 && n > 1 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"databases\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut azName: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut nName: libc::c_int = 0 as libc::c_int;
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut i_2: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                sqlite3_errmsg((*p).db),
            );
            rc = 1 as libc::c_int;
        } else {
            while sqlite3_step(pStmt) == 100 as libc::c_int {
                let zSchema: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                let zFile_0: *const libc::c_char = sqlite3_column_text(
                    pStmt,
                    2 as libc::c_int,
                ) as *const libc::c_char;
                if zSchema.is_null() || zFile_0.is_null() {
                    continue;
                }
                azName = sqlite3_realloc(
                    azName as *mut libc::c_void,
                    (((nName + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                        ) as libc::c_int,
                ) as *mut *mut libc::c_char;
                shell_check_oom(azName as *const libc::c_void);
                let ref mut fresh117 = *azName
                    .offset((nName * 2 as libc::c_int) as isize);
                *fresh117 = strdup(zSchema);
                let ref mut fresh118 = *azName
                    .offset((nName * 2 as libc::c_int + 1 as libc::c_int) as isize);
                *fresh118 = strdup(zFile_0);
                nName += 1;
                nName;
            }
        }
        sqlite3_finalize(pStmt);
        i_2 = 0 as libc::c_int;
        while i_2 < nName {
            let eTxn: libc::c_int = sqlite3_txn_state(
                (*p).db,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
            );
            let bRdonly: libc::c_int = sqlite3_db_readonly(
                (*p).db,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
            );
            let z_0: *const libc::c_char = *azName
                .offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize);
            fprintf(
                (*p).out,
                b"%s: %s %s%s\n\0" as *const u8 as *const libc::c_char,
                *azName.offset((i_2 * 2 as libc::c_int) as isize),
                if !z_0.is_null()
                    && *z_0.offset(0 as libc::c_int as isize) as libc::c_int != 0
                {
                    z_0
                } else {
                    b"\"\"\0" as *const u8 as *const libc::c_char
                },
                if bRdonly != 0 {
                    b"r/o\0" as *const u8 as *const libc::c_char
                } else {
                    b"r/w\0" as *const u8 as *const libc::c_char
                },
                if eTxn == 0 as libc::c_int {
                    b"\0" as *const u8 as *const libc::c_char
                } else if eTxn == 1 as libc::c_int {
                    b" read-txn\0" as *const u8 as *const libc::c_char
                } else {
                    b" write-txn\0" as *const u8 as *const libc::c_char
                },
            );
            free(*azName.offset((i_2 * 2 as libc::c_int) as isize) as *mut libc::c_void);
            free(
                *azName.offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize)
                    as *mut libc::c_void,
            );
            i_2 += 1;
            i_2;
        }
        sqlite3_free(azName as *mut libc::c_void);
    } else if c == 'd' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"dbconfig\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aDbConfig: [DbConfigChoices; 18] = [
            {
                let init = DbConfigChoices {
                    zName: b"defensive\0" as *const u8 as *const libc::c_char,
                    op: 1010 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"dqs_ddl\0" as *const u8 as *const libc::c_char,
                    op: 1014 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"dqs_dml\0" as *const u8 as *const libc::c_char,
                    op: 1013 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"enable_fkey\0" as *const u8 as *const libc::c_char,
                    op: 1002 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"enable_qpsg\0" as *const u8 as *const libc::c_char,
                    op: 1007 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"enable_trigger\0" as *const u8 as *const libc::c_char,
                    op: 1003 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"enable_view\0" as *const u8 as *const libc::c_char,
                    op: 1015 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"fts3_tokenizer\0" as *const u8 as *const libc::c_char,
                    op: 1004 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"legacy_alter_table\0" as *const u8 as *const libc::c_char,
                    op: 1012 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"legacy_file_format\0" as *const u8 as *const libc::c_char,
                    op: 1016 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"load_extension\0" as *const u8 as *const libc::c_char,
                    op: 1005 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"no_ckpt_on_close\0" as *const u8 as *const libc::c_char,
                    op: 1006 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"reset_database\0" as *const u8 as *const libc::c_char,
                    op: 1009 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"reverse_scanorder\0" as *const u8 as *const libc::c_char,
                    op: 1019 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"stmt_scanstatus\0" as *const u8 as *const libc::c_char,
                    op: 1018 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"trigger_eqp\0" as *const u8 as *const libc::c_char,
                    op: 1008 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"trusted_schema\0" as *const u8 as *const libc::c_char,
                    op: 1017 as libc::c_int,
                };
                init
            },
            {
                let init = DbConfigChoices {
                    zName: b"writable_schema\0" as *const u8 as *const libc::c_char,
                    op: 1011 as libc::c_int,
                };
                init
            },
        ];
        let mut ii: libc::c_int = 0;
        let mut v: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        ii = 0 as libc::c_int;
        while ii
            < (::core::mem::size_of::<[DbConfigChoices; 18]>() as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<DbConfigChoices>() as libc::c_ulong)
                as libc::c_int
        {
            if !(nArg > 1 as libc::c_int
                && cli_strcmp(
                    azArg[1 as libc::c_int as usize],
                    aDbConfig[ii as usize].zName,
                ) != 0 as libc::c_int)
            {
                if nArg >= 3 as libc::c_int {
                    sqlite3_db_config(
                        (*p).db,
                        aDbConfig[ii as usize].op,
                        booleanValue(azArg[2 as libc::c_int as usize]),
                        0 as libc::c_int,
                    );
                }
                sqlite3_db_config(
                    (*p).db,
                    aDbConfig[ii as usize].op,
                    -(1 as libc::c_int),
                    &mut v as *mut libc::c_int,
                );
                fprintf(
                    (*p).out,
                    b"%19s %s\n\0" as *const u8 as *const libc::c_char,
                    aDbConfig[ii as usize].zName,
                    if v != 0 {
                        b"on\0" as *const u8 as *const libc::c_char
                    } else {
                        b"off\0" as *const u8 as *const libc::c_char
                    },
                );
                if nArg > 1 as libc::c_int {
                    break;
                }
            }
            ii += 1;
            ii;
        }
        if nArg > 1 as libc::c_int
            && ii
                == (::core::mem::size_of::<[DbConfigChoices; 18]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<DbConfigChoices>() as libc::c_ulong,
                    ) as libc::c_int
        {
            fprintf(
                stderr,
                b"Error: unknown dbconfig \"%s\"\n\0" as *const u8
                    as *const libc::c_char,
                azArg[1 as libc::c_int as usize],
            );
            fprintf(
                stderr,
                b"Enter \".dbconfig\" with no arguments for a list\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
    } else if c == 'd' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"dbinfo\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        rc = shell_dbinfo_command(p, nArg, azArg.as_mut_ptr());
    } else if c == 'r' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"recover\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        rc = recoverDatabaseCmd(p, nArg, azArg.as_mut_ptr());
    } else if c == 'd' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"dump\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zLike: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut i_3: libc::c_int = 0;
        let savedShowHeader: libc::c_int = (*p).showHeader;
        let savedShellFlags: libc::c_int = (*p).shellFlgs as libc::c_int;
        (*p).shellFlgs
            &= !(0x8 as libc::c_int | 0x10 as libc::c_int | 0x40 as libc::c_int
                | 0x100 as libc::c_int | 0x200 as libc::c_int) as libc::c_uint;
        i_3 = 1 as libc::c_int;
        loop {
            if !(i_3 < nArg) {
                current_block = 6660696667549920226;
                break;
            }
            if *(azArg[i_3 as usize]).offset(0 as libc::c_int as isize) as libc::c_int
                == '-' as i32
            {
                let mut z_1: *const libc::c_char = (azArg[i_3 as usize])
                    .offset(1 as libc::c_int as isize);
                if *z_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_1 = z_1.offset(1);
                    z_1;
                }
                if cli_strcmp(
                    z_1,
                    b"preserve-rowids\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x8 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(
                    z_1,
                    b"newlines\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x10 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(
                    z_1,
                    b"data-only\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x100 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_1, b"nosys\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).shellFlgs |= 0x200 as libc::c_int as libc::c_uint;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \".dump\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_3 as usize],
                    );
                    rc = 1 as libc::c_int;
                    sqlite3_free(zLike as *mut libc::c_void);
                    current_block = 16476549346120425317;
                    break;
                }
            } else {
                let zExpr: *mut libc::c_char = sqlite3_mprintf(
                    b"name LIKE %Q ESCAPE '\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE '\\' AND    sql LIKE 'CREATE VIRTUAL TABLE%%' AND    substr(o.name, 1, length(name)+1) == (name||'_'))\0"
                        as *const u8 as *const libc::c_char,
                    azArg[i_3 as usize],
                    azArg[i_3 as usize],
                );
                if !zLike.is_null() {
                    zLike = sqlite3_mprintf(
                        b"%z OR %z\0" as *const u8 as *const libc::c_char,
                        zLike,
                        zExpr,
                    );
                } else {
                    zLike = zExpr;
                }
            }
            i_3 += 1;
            i_3;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                open_db(p, 0 as libc::c_int);
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*p).out,
                        b"PRAGMA foreign_keys=OFF;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"BEGIN TRANSACTION;\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                (*p).writableSchema = 0 as libc::c_int;
                (*p).showHeader = 0 as libc::c_int;
                sqlite3_exec(
                    (*p).db,
                    b"SAVEPOINT dump; PRAGMA writable_schema=ON\0" as *const u8
                        as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                (*p).nErr = 0 as libc::c_int;
                if zLike.is_null() {
                    zLike = sqlite3_mprintf(
                        b"true\0" as *const u8 as *const libc::c_char,
                    );
                }
                zSql = sqlite3_mprintf(
                    b"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type=='table'  AND sql NOT NULL ORDER BY tbl_name='sqlite_sequence', rowid\0"
                        as *const u8 as *const libc::c_char,
                    zLike,
                );
                run_schema_dump_query(p, zSql);
                sqlite3_free(zSql as *mut libc::c_void);
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    zSql = sqlite3_mprintf(
                        b"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN ('index','trigger','view')\0"
                            as *const u8 as *const libc::c_char,
                        zLike,
                    );
                    run_table_dump_query(p, zSql);
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                sqlite3_free(zLike as *mut libc::c_void);
                if (*p).writableSchema != 0 {
                    fprintf(
                        (*p).out,
                        b"PRAGMA writable_schema=OFF;\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    (*p).writableSchema = 0 as libc::c_int;
                }
                sqlite3_exec(
                    (*p).db,
                    b"PRAGMA writable_schema=OFF;\0" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_exec(
                    (*p).db,
                    b"RELEASE dump;\0" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*p).out,
                        if (*p).nErr != 0 {
                            b"ROLLBACK; -- due to errors\n\0" as *const u8
                                as *const libc::c_char
                        } else {
                            b"COMMIT;\n\0" as *const u8 as *const libc::c_char
                        },
                    );
                }
                (*p).showHeader = savedShowHeader;
                (*p).shellFlgs = savedShellFlags as libc::c_uint;
            }
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"echo\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            setOrClearFlag(
                p,
                0x40 as libc::c_int as libc::c_uint,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .echo on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"eqp\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).autoEQPtest = 0 as libc::c_int as u8_0;
            if (*p).autoEQPtrace != 0 {
                if !((*p).db).is_null() {
                    sqlite3_exec(
                        (*p).db,
                        b"PRAGMA vdbe_trace=OFF;\0" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                }
                (*p).autoEQPtrace = 0 as libc::c_int as u8_0;
            }
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"full\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).autoEQP = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"trigger\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).autoEQP = 2 as libc::c_int as u8_0;
            } else {
                (*p).autoEQP = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .eqp off|on|trace|trigger|full\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"exit\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg > 1 as libc::c_int
            && {
                rc = integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int;
                rc != 0 as libc::c_int
            }
        {
            exit(rc);
        }
        rc = 2 as libc::c_int;
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"explain\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut val: libc::c_int = 1 as libc::c_int;
        if nArg >= 2 as libc::c_int {
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"auto\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                val = 99 as libc::c_int;
            } else {
                val = booleanValue(azArg[1 as libc::c_int as usize]);
            }
        }
        if val == 1 as libc::c_int && (*p).mode != 9 as libc::c_int {
            (*p).normalMode = (*p).mode;
            (*p).mode = 9 as libc::c_int;
            (*p).autoExplain = 0 as libc::c_int as u8_0;
        } else if val == 0 as libc::c_int {
            if (*p).mode == 9 as libc::c_int {
                (*p).mode = (*p).normalMode;
            }
            (*p).autoExplain = 0 as libc::c_int as u8_0;
        } else if val == 99 as libc::c_int {
            if (*p).mode == 9 as libc::c_int {
                (*p).mode = (*p).normalMode;
            }
            (*p).autoExplain = 1 as libc::c_int as u8_0;
        }
    } else if c == 'e' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"expert\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if (*p).bSafeMode != 0 {
            fprintf(
                stderr,
                b"Cannot run experimental commands such as \"%s\" in safe mode\n\0"
                    as *const u8 as *const libc::c_char,
                azArg[0 as libc::c_int as usize],
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            expertDotCommand(p, azArg.as_mut_ptr(), nArg);
        }
    } else if c == 'f' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"filectrl\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aCtrl: [C2RustUnnamed_21; 9] = [
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"chunk_size\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 6 as libc::c_int,
                    zUsage: b"SIZE\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"data_version\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 35 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"has_moved\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 20 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"lock_timeout\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 34 as libc::c_int,
                    zUsage: b"MILLISEC\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"persist_wal\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 10 as libc::c_int,
                    zUsage: b"[BOOLEAN]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"psow\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 13 as libc::c_int,
                    zUsage: b"[BOOLEAN]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"reserve_bytes\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 38 as libc::c_int,
                    zUsage: b"[N]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"size_limit\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 36 as libc::c_int,
                    zUsage: b"[LIMIT]\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_21 {
                    zCtrlName: b"tempfilename\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 16 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
        ];
        let mut filectrl: libc::c_int = -(1 as libc::c_int);
        let mut iCtrl: libc::c_int = -(1 as libc::c_int);
        let mut iRes: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut isOk: libc::c_int = 0 as libc::c_int;
        let mut n2: libc::c_int = 0;
        let mut i_4: libc::c_int = 0;
        let mut zCmd: *const libc::c_char = 0 as *const libc::c_char;
        let mut zSchema_0: *const libc::c_char = 0 as *const libc::c_char;
        open_db(p, 0 as libc::c_int);
        zCmd = if nArg >= 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"help\0" as *const u8 as *const libc::c_char
        };
        if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && (cli_strcmp(zCmd, b"--schema\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
                || cli_strcmp(zCmd, b"-schema\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int) && nArg >= 4 as libc::c_int
        {
            zSchema_0 = azArg[2 as libc::c_int as usize];
            i_4 = 3 as libc::c_int;
            while i_4 < nArg {
                azArg[(i_4 - 2 as libc::c_int) as usize] = azArg[i_4 as usize];
                i_4 += 1;
                i_4;
            }
            nArg -= 2 as libc::c_int;
            zCmd = azArg[1 as libc::c_int as usize];
        }
        if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
        {
            zCmd = zCmd.offset(1);
            zCmd;
            if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd = zCmd.offset(1);
                zCmd;
            }
        }
        if cli_strcmp(zCmd, b"help\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"Available file-controls:\n\0" as *const u8 as *const libc::c_char,
            );
            i_4 = 0 as libc::c_int;
            while i_4
                < (::core::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong,
                    ) as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"  .filectrl %s %s\n\0" as *const u8 as *const libc::c_char,
                    aCtrl[i_4 as usize].zCtrlName,
                    aCtrl[i_4 as usize].zUsage,
                );
                i_4 += 1;
                i_4;
            }
            rc = 1 as libc::c_int;
        } else {
            n2 = strlen30(zCmd);
            i_4 = 0 as libc::c_int;
            loop {
                if !(i_4
                    < (::core::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 763911284580919563;
                    break;
                }
                if cli_strncmp(zCmd, aCtrl[i_4 as usize].zCtrlName, n2 as size_t)
                    == 0 as libc::c_int
                {
                    if filectrl < 0 as libc::c_int {
                        filectrl = aCtrl[i_4 as usize].ctrlCode;
                        iCtrl = i_4;
                    } else {
                        fprintf(
                            stderr,
                            b"Error: ambiguous file-control: \"%s\"\nUse \".filectrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 16476549346120425317;
                        break;
                    }
                }
                i_4 += 1;
                i_4;
            }
            match current_block {
                16476549346120425317 => {}
                _ => {
                    if filectrl < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: unknown file-control: %s\nUse \".filectrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd,
                        );
                    } else {
                        match filectrl {
                            36 => {
                                if !(nArg != 2 as libc::c_int && nArg != 3 as libc::c_int) {
                                    iRes = if nArg == 3 as libc::c_int {
                                        integerValue(azArg[2 as libc::c_int as usize])
                                    } else {
                                        -(1 as libc::c_int) as libc::c_longlong
                                    };
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        36 as libc::c_int,
                                        &mut iRes as *mut sqlite3_int64 as *mut libc::c_void,
                                    );
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            34 | 6 => {
                                let mut x: libc::c_int = 0;
                                if !(nArg != 3 as libc::c_int) {
                                    x = integerValue(azArg[2 as libc::c_int as usize])
                                        as libc::c_int;
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    isOk = 2 as libc::c_int;
                                }
                            }
                            10 | 13 => {
                                let mut x_0: libc::c_int = 0;
                                if !(nArg != 2 as libc::c_int && nArg != 3 as libc::c_int) {
                                    x_0 = if nArg == 3 as libc::c_int {
                                        booleanValue(azArg[2 as libc::c_int as usize])
                                    } else {
                                        -(1 as libc::c_int)
                                    };
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_0 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    iRes = x_0 as sqlite3_int64;
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            35 | 20 => {
                                let mut x_1: libc::c_int = 0;
                                if !(nArg != 2 as libc::c_int) {
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_1 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                    iRes = x_1 as sqlite3_int64;
                                    isOk = 1 as libc::c_int;
                                }
                            }
                            16 => {
                                let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                if !(nArg != 2 as libc::c_int) {
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut z_2 as *mut *mut libc::c_char as *mut libc::c_void,
                                    );
                                    if !z_2.is_null() {
                                        fprintf(
                                            (*p).out,
                                            b"%s\n\0" as *const u8 as *const libc::c_char,
                                            z_2,
                                        );
                                        sqlite3_free(z_2 as *mut libc::c_void);
                                    }
                                    isOk = 2 as libc::c_int;
                                }
                            }
                            38 => {
                                let mut x_2: libc::c_int = 0;
                                if nArg >= 3 as libc::c_int {
                                    x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                    sqlite3_file_control(
                                        (*p).db,
                                        zSchema_0,
                                        filectrl,
                                        &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                    );
                                }
                                x_2 = -(1 as libc::c_int);
                                sqlite3_file_control(
                                    (*p).db,
                                    zSchema_0,
                                    filectrl,
                                    &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%d\n\0" as *const u8 as *const libc::c_char,
                                    x_2,
                                );
                                isOk = 2 as libc::c_int;
                            }
                            _ => {}
                        }
                    }
                    if isOk == 0 as libc::c_int && iCtrl >= 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Usage: .filectrl %s %s\n\0" as *const u8
                                as *const libc::c_char,
                            zCmd,
                            aCtrl[iCtrl as usize].zUsage,
                        );
                        rc = 1 as libc::c_int;
                    } else if isOk == 1 as libc::c_int {
                        let mut zBuf: [libc::c_char; 100] = [0; 100];
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 100]>()
                                as libc::c_ulong as libc::c_int,
                            zBuf.as_mut_ptr(),
                            b"%lld\0" as *const u8 as *const libc::c_char,
                            iRes,
                        );
                        fprintf(
                            (*p).out,
                            b"%s\n\0" as *const u8 as *const libc::c_char,
                            zBuf.as_mut_ptr(),
                        );
                    }
                }
            }
        }
    } else if c == 'f' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"fullschema\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut data: ShellState = ShellState {
            db: 0 as *mut sqlite3,
            autoExplain: 0,
            autoEQP: 0,
            autoEQPtest: 0,
            autoEQPtrace: 0,
            scanstatsOn: 0,
            openMode: 0,
            doXdgOpen: 0,
            nEqpLevel: 0,
            eTraceType: 0,
            bSafeMode: 0,
            bSafeModePersist: 0,
            cmOpts: ColModeOpts {
                iWrap: 0,
                bQuote: 0,
                bWordWrap: 0,
            },
            statsOn: 0,
            mEqpLines: 0,
            inputNesting: 0,
            outCount: 0,
            cnt: 0,
            lineno: 0,
            openFlags: 0,
            in_0: 0 as *mut FILE,
            out: 0 as *mut FILE,
            traceOut: 0 as *mut FILE,
            nErr: 0,
            mode: 0,
            modePrior: 0,
            cMode: 0,
            normalMode: 0,
            writableSchema: 0,
            showHeader: 0,
            nCheck: 0,
            nProgress: 0,
            mxProgress: 0,
            flgProgress: 0,
            shellFlgs: 0,
            priorShFlgs: 0,
            szMax: 0,
            zDestTable: 0 as *mut libc::c_char,
            zTempFile: 0 as *mut libc::c_char,
            zTestcase: [0; 30],
            colSeparator: [0; 20],
            rowSeparator: [0; 20],
            colSepPrior: [0; 20],
            rowSepPrior: [0; 20],
            colWidth: 0 as *mut libc::c_int,
            actualWidth: 0 as *mut libc::c_int,
            nWidth: 0,
            nullValue: [0; 20],
            outfile: [0; 4096],
            pStmt: 0 as *mut sqlite3_stmt,
            pLog: 0 as *mut FILE,
            aAuxDb: [AuxDb {
                db: 0 as *mut sqlite3,
                zDbFilename: 0 as *const libc::c_char,
                zFreeOnClose: 0 as *mut libc::c_char,
            }; 5],
            pAuxDb: 0 as *mut AuxDb,
            aiIndent: 0 as *mut libc::c_int,
            nIndent: 0,
            iIndent: 0,
            zNonce: 0 as *mut libc::c_char,
            sGraph: EQPGraph {
                pRow: 0 as *mut EQPGraphRow,
                pLast: 0 as *mut EQPGraphRow,
                zPrefix: [0; 100],
            },
            expert: ExpertInfo {
                pExpert: 0 as *mut sqlite3expert,
                bVerbose: 0,
            },
        };
        let mut doStats: libc::c_int = 0 as libc::c_int;
        memcpy(
            &mut data as *mut ShellState as *mut libc::c_void,
            p as *const libc::c_void,
            ::core::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        data.showHeader = 0 as libc::c_int;
        data.mode = 3 as libc::c_int;
        data.cMode = data.mode;
        if nArg == 2 as libc::c_int
            && optionMatch(
                azArg[1 as libc::c_int as usize],
                b"indent\0" as *const u8 as *const libc::c_char,
            ) != 0
        {
            data.mode = 11 as libc::c_int;
            data.cMode = data.mode;
            nArg = 1 as libc::c_int;
        }
        if nArg != 1 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .fullschema ?--indent?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_exec(
                (*p).db,
                b"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!='meta' AND sql NOTNULL AND name NOT LIKE 'sqlite_%' ORDER BY x\0"
                    as *const u8 as *const libc::c_char,
                Some(
                    callback
                        as unsafe extern "C" fn(
                            *mut libc::c_void,
                            libc::c_int,
                            *mut *mut libc::c_char,
                            *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                &mut data as *mut ShellState as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                let mut pStmt_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT rowid FROM sqlite_schema WHERE name GLOB 'sqlite_stat[134]'\0"
                        as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_0,
                    0 as *mut *const libc::c_char,
                );
                doStats = (sqlite3_step(pStmt_0) == 100 as libc::c_int) as libc::c_int;
                sqlite3_finalize(pStmt_0);
            }
            if doStats == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"/* No STAT tables available */\n\0" as *const u8
                        as *const libc::c_char,
                );
            } else {
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
                );
                data.mode = 5 as libc::c_int;
                data.cMode = data.mode;
                data
                    .zDestTable = b"sqlite_stat1\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                shell_exec(
                    &mut data,
                    b"SELECT * FROM sqlite_stat1\0" as *const u8 as *const libc::c_char,
                    0 as *mut *mut libc::c_char,
                );
                data
                    .zDestTable = b"sqlite_stat4\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                shell_exec(
                    &mut data,
                    b"SELECT * FROM sqlite_stat4\0" as *const u8 as *const libc::c_char,
                    0 as *mut *mut libc::c_char,
                );
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\0" as *const u8 as *const libc::c_char,
                );
            }
        }
    } else if c == 'h' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"headers\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            (*p).showHeader = booleanValue(azArg[1 as libc::c_int as usize]);
            (*p).shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
        } else {
            fprintf(
                stderr,
                b"Usage: .headers on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'h' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"help\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg >= 2 as libc::c_int {
            n = showHelp((*p).out, azArg[1 as libc::c_int as usize]);
            if n == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"Nothing matches '%s'\n\0" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
            }
        } else {
            showHelp((*p).out, 0 as *const libc::c_char);
        }
    } else if c == 'i' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"import\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zTable: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSchema_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zFile_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pStmt_1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut nCol: libc::c_int = 0;
        let mut nByte: libc::c_int = 0;
        let mut i_5: libc::c_int = 0;
        let mut j_0: libc::c_int = 0;
        let mut needCommit: libc::c_int = 0;
        let mut nSep: libc::c_int = 0;
        let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zFullTabName: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut sCtx: ImportCtx = ImportCtx {
            zFile: 0 as *const libc::c_char,
            in_0: 0 as *mut FILE,
            xCloser: None,
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
            nLine: 0,
            nRow: 0,
            nErr: 0,
            bNotFirst: 0,
            cTerm: 0,
            cColSep: 0,
            cRowSep: 0,
        };
        let mut xRead: Option::<
            unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
        > = None;
        let mut eVerbose: libc::c_int = 0 as libc::c_int;
        let mut nSkip: libc::c_int = 0 as libc::c_int;
        let mut useOutputMode: libc::c_int = 1 as libc::c_int;
        let mut zCreate: *mut libc::c_char = 0 as *mut libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .import in safe mode\0" as *const u8 as *const libc::c_char,
        );
        memset(
            &mut sCtx as *mut ImportCtx as *mut libc::c_void,
            0 as libc::c_int,
            ::core::mem::size_of::<ImportCtx>() as libc::c_ulong,
        );
        if (*p).mode == 10 as libc::c_int {
            xRead = Some(
                ascii_read_one_field
                    as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
            );
        } else {
            xRead = Some(
                csv_read_one_field
                    as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
            );
        }
        rc = 1 as libc::c_int;
        i_5 = 1 as libc::c_int;
        loop {
            if !(i_5 < nArg) {
                current_block = 12952730798101289484;
                break;
            }
            let mut z_3: *mut libc::c_char = azArg[i_5 as usize];
            if *z_3.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *z_3.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                z_3 = z_3.offset(1);
                z_3;
            }
            if *z_3.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                if zFile_1.is_null() {
                    zFile_1 = z_3;
                } else if zTable.is_null() {
                    zTable = z_3;
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: extra argument: \"%s\".  Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        z_3,
                    );
                    showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                    current_block = 16476549346120425317;
                    break;
                }
            } else if cli_strcmp(z_3, b"-v\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                eVerbose += 1;
                eVerbose;
            } else if cli_strcmp(z_3, b"-schema\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && i_5 < nArg - 1 as libc::c_int
            {
                i_5 += 1;
                zSchema_1 = azArg[i_5 as usize];
            } else if cli_strcmp(z_3, b"-skip\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && i_5 < nArg - 1 as libc::c_int
            {
                i_5 += 1;
                nSkip = integerValue(azArg[i_5 as usize]) as libc::c_int;
            } else if cli_strcmp(z_3, b"-ascii\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sCtx
                    .cColSep = (*::core::mem::transmute::<
                    &[u8; 2],
                    &[libc::c_char; 2],
                >(b"\x1F\0"))[0 as libc::c_int as usize] as libc::c_int;
                sCtx
                    .cRowSep = (*::core::mem::transmute::<
                    &[u8; 2],
                    &[libc::c_char; 2],
                >(b"\x1E\0"))[0 as libc::c_int as usize] as libc::c_int;
                xRead = Some(
                    ascii_read_one_field
                        as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
                );
                useOutputMode = 0 as libc::c_int;
            } else if cli_strcmp(z_3, b"-csv\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                sCtx.cColSep = ',' as i32;
                sCtx.cRowSep = '\n' as i32;
                xRead = Some(
                    csv_read_one_field
                        as unsafe extern "C" fn(*mut ImportCtx) -> *mut libc::c_char,
                );
                useOutputMode = 0 as libc::c_int;
            } else {
                fprintf(
                    (*p).out,
                    b"ERROR: unknown option: \"%s\".  Usage:\n\0" as *const u8
                        as *const libc::c_char,
                    z_3,
                );
                showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                current_block = 16476549346120425317;
                break;
            }
            i_5 += 1;
            i_5;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if zTable.is_null() {
                    fprintf(
                        (*p).out,
                        b"ERROR: missing %s argument. Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        if zFile_1.is_null() {
                            b"FILE\0" as *const u8 as *const libc::c_char
                        } else {
                            b"TABLE\0" as *const u8 as *const libc::c_char
                        },
                    );
                    showHelp((*p).out, b"import\0" as *const u8 as *const libc::c_char);
                } else {
                    ::core::ptr::write_volatile(
                        &mut seenInterrupt as *mut libc::c_int,
                        0 as libc::c_int,
                    );
                    open_db(p, 0 as libc::c_int);
                    if useOutputMode != 0 {
                        nSep = strlen30(((*p).colSeparator).as_mut_ptr());
                        if nSep == 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: non-null column separator required for import\n\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 16476549346120425317;
                        } else if nSep > 1 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: multi-character column separators not allowed for import\n\0"
                                    as *const u8 as *const libc::c_char,
                            );
                            current_block = 16476549346120425317;
                        } else {
                            nSep = strlen30(((*p).rowSeparator).as_mut_ptr());
                            if nSep == 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: non-null row separator required for import\n\0"
                                        as *const u8 as *const libc::c_char,
                                );
                                current_block = 16476549346120425317;
                            } else {
                                if nSep == 2 as libc::c_int && (*p).mode == 8 as libc::c_int
                                    && cli_strcmp(
                                        ((*p).rowSeparator).as_mut_ptr(),
                                        b"\r\n\0" as *const u8 as *const libc::c_char,
                                    ) == 0 as libc::c_int
                                {
                                    sqlite3_snprintf(
                                        ::core::mem::size_of::<[libc::c_char; 20]>()
                                            as libc::c_ulong as libc::c_int,
                                        ((*p).rowSeparator).as_mut_ptr(),
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                    nSep = strlen30(((*p).rowSeparator).as_mut_ptr());
                                }
                                if nSep > 1 as libc::c_int {
                                    fprintf(
                                        stderr,
                                        b"Error: multi-character row separators not allowed for import\n\0"
                                            as *const u8 as *const libc::c_char,
                                    );
                                    current_block = 16476549346120425317;
                                } else {
                                    sCtx
                                        .cColSep = (*p).colSeparator[0 as libc::c_int as usize]
                                        as u8_0 as libc::c_int;
                                    sCtx
                                        .cRowSep = (*p).rowSeparator[0 as libc::c_int as usize]
                                        as u8_0 as libc::c_int;
                                    current_block = 11371699899008650854;
                                }
                            }
                        }
                    } else {
                        current_block = 11371699899008650854;
                    }
                    match current_block {
                        16476549346120425317 => {}
                        _ => {
                            sCtx.zFile = zFile_1;
                            sCtx.nLine = 1 as libc::c_int;
                            if *(sCtx.zFile).offset(0 as libc::c_int as isize)
                                as libc::c_int == '|' as i32
                            {
                                sCtx
                                    .in_0 = popen(
                                    (sCtx.zFile).offset(1 as libc::c_int as isize),
                                    b"r\0" as *const u8 as *const libc::c_char,
                                );
                                sCtx
                                    .zFile = b"<pipe>\0" as *const u8 as *const libc::c_char;
                                sCtx
                                    .xCloser = Some(
                                    pclose as unsafe extern "C" fn(*mut FILE) -> libc::c_int,
                                );
                            } else {
                                sCtx
                                    .in_0 = fopen(
                                    sCtx.zFile,
                                    b"rb\0" as *const u8 as *const libc::c_char,
                                );
                                sCtx
                                    .xCloser = Some(
                                    fclose as unsafe extern "C" fn(*mut FILE) -> libc::c_int,
                                );
                            }
                            if (sCtx.in_0).is_null() {
                                fprintf(
                                    stderr,
                                    b"Error: cannot open \"%s\"\n\0" as *const u8
                                        as *const libc::c_char,
                                    zFile_1,
                                );
                            } else {
                                if eVerbose >= 2 as libc::c_int
                                    || eVerbose >= 1 as libc::c_int && useOutputMode != 0
                                {
                                    let mut zSep: [libc::c_char; 2] = [0; 2];
                                    zSep[1 as libc::c_int
                                        as usize] = 0 as libc::c_int as libc::c_char;
                                    zSep[0 as libc::c_int
                                        as usize] = sCtx.cColSep as libc::c_char;
                                    fprintf(
                                        (*p).out,
                                        b"Column separator \0" as *const u8 as *const libc::c_char,
                                    );
                                    output_c_string((*p).out, zSep.as_mut_ptr());
                                    fprintf(
                                        (*p).out,
                                        b", row separator \0" as *const u8 as *const libc::c_char,
                                    );
                                    zSep[0 as libc::c_int
                                        as usize] = sCtx.cRowSep as libc::c_char;
                                    output_c_string((*p).out, zSep.as_mut_ptr());
                                    fprintf(
                                        (*p).out,
                                        b"\n\0" as *const u8 as *const libc::c_char,
                                    );
                                }
                                sCtx
                                    .z = sqlite3_malloc64(120 as libc::c_int as sqlite3_uint64)
                                    as *mut libc::c_char;
                                if (sCtx.z).is_null() {
                                    import_cleanup(&mut sCtx);
                                    shell_out_of_memory();
                                }
                                loop {
                                    let fresh119 = nSkip;
                                    nSkip = nSkip - 1;
                                    if !(fresh119 > 0 as libc::c_int) {
                                        break;
                                    }
                                    while !(xRead
                                        .expect("non-null function pointer")(&mut sCtx))
                                        .is_null() && sCtx.cTerm == sCtx.cColSep
                                    {}
                                }
                                if !zSchema_1.is_null() {
                                    zFullTabName = sqlite3_mprintf(
                                        b"\"%w\".\"%w\"\0" as *const u8 as *const libc::c_char,
                                        zSchema_1,
                                        zTable,
                                    );
                                } else {
                                    zFullTabName = sqlite3_mprintf(
                                        b"\"%w\"\0" as *const u8 as *const libc::c_char,
                                        zTable,
                                    );
                                }
                                zSql_0 = sqlite3_mprintf(
                                    b"SELECT * FROM %s\0" as *const u8 as *const libc::c_char,
                                    zFullTabName,
                                );
                                if zSql_0.is_null() || zFullTabName.is_null() {
                                    import_cleanup(&mut sCtx);
                                    shell_out_of_memory();
                                }
                                nByte = strlen30(zSql_0);
                                rc = sqlite3_prepare_v2(
                                    (*p).db,
                                    zSql_0,
                                    -(1 as libc::c_int),
                                    &mut pStmt_1,
                                    0 as *mut *const libc::c_char,
                                );
                                import_append_char(&mut sCtx, 0 as libc::c_int);
                                if rc != 0
                                    && sqlite3_strglob(
                                        b"no such table: *\0" as *const u8 as *const libc::c_char,
                                        sqlite3_errmsg((*p).db),
                                    ) == 0 as libc::c_int
                                {
                                    dbCols = 0 as *mut sqlite3;
                                    zRenames = 0 as *mut libc::c_char;
                                    zColDefs = 0 as *mut libc::c_char;
                                    zCreate = sqlite3_mprintf(
                                        b"CREATE TABLE %s\0" as *const u8 as *const libc::c_char,
                                        zFullTabName,
                                    );
                                    while !(xRead
                                        .expect("non-null function pointer")(&mut sCtx))
                                        .is_null()
                                    {
                                        zAutoColumn(
                                            sCtx.z,
                                            &mut dbCols,
                                            0 as *mut *mut libc::c_char,
                                        );
                                        if sCtx.cTerm != sCtx.cColSep {
                                            break;
                                        }
                                    }
                                    zColDefs = zAutoColumn(
                                        0 as *const libc::c_char,
                                        &mut dbCols,
                                        &mut zRenames,
                                    );
                                    if !zRenames.is_null() {
                                        fprintf(
                                            if stdin_is_interactive != 0 && (*p).in_0 == stdin {
                                                (*p).out
                                            } else {
                                                stderr
                                            },
                                            b"Columns renamed during .import %s due to duplicates:\n%s\n\0"
                                                as *const u8 as *const libc::c_char,
                                            sCtx.zFile,
                                            zRenames,
                                        );
                                        sqlite3_free(zRenames as *mut libc::c_void);
                                    }
                                    if dbCols.is_null() {} else {
                                        __assert_fail(
                                            b"dbCols==0\0" as *const u8 as *const libc::c_char,
                                            b"shell.c\0" as *const u8 as *const libc::c_char,
                                            24787 as libc::c_int as libc::c_uint,
                                            (*::core::mem::transmute::<
                                                &[u8; 42],
                                                &[libc::c_char; 42],
                                            >(b"int do_meta_command(char *, ShellState *)\0"))
                                                .as_ptr(),
                                        );
                                    }
                                    'c_115018: {
                                        if dbCols.is_null() {} else {
                                            __assert_fail(
                                                b"dbCols==0\0" as *const u8 as *const libc::c_char,
                                                b"shell.c\0" as *const u8 as *const libc::c_char,
                                                24787 as libc::c_int as libc::c_uint,
                                                (*::core::mem::transmute::<
                                                    &[u8; 42],
                                                    &[libc::c_char; 42],
                                                >(b"int do_meta_command(char *, ShellState *)\0"))
                                                    .as_ptr(),
                                            );
                                        }
                                    };
                                    if zColDefs.is_null() {
                                        fprintf(
                                            stderr,
                                            b"%s: empty file\n\0" as *const u8 as *const libc::c_char,
                                            sCtx.zFile,
                                        );
                                        current_block = 12957157471781409979;
                                    } else {
                                        zCreate = sqlite3_mprintf(
                                            b"%z%z\n\0" as *const u8 as *const libc::c_char,
                                            zCreate,
                                            zColDefs,
                                        );
                                        if eVerbose >= 1 as libc::c_int {
                                            fprintf(
                                                (*p).out,
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                zCreate,
                                            );
                                        }
                                        rc = sqlite3_exec(
                                            (*p).db,
                                            zCreate,
                                            None,
                                            0 as *mut libc::c_void,
                                            0 as *mut *mut libc::c_char,
                                        );
                                        if rc != 0 {
                                            fprintf(
                                                stderr,
                                                b"%s failed:\n%s\n\0" as *const u8 as *const libc::c_char,
                                                zCreate,
                                                sqlite3_errmsg((*p).db),
                                            );
                                            current_block = 12957157471781409979;
                                        } else {
                                            sqlite3_free(zCreate as *mut libc::c_void);
                                            zCreate = 0 as *mut libc::c_char;
                                            rc = sqlite3_prepare_v2(
                                                (*p).db,
                                                zSql_0,
                                                -(1 as libc::c_int),
                                                &mut pStmt_1,
                                                0 as *mut *const libc::c_char,
                                            );
                                            current_block = 7905081044627426364;
                                        }
                                    }
                                } else {
                                    current_block = 7905081044627426364;
                                }
                                match current_block {
                                    7905081044627426364 => {
                                        if rc != 0 {
                                            if !pStmt_1.is_null() {
                                                sqlite3_finalize(pStmt_1);
                                            }
                                            fprintf(
                                                stderr,
                                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                                sqlite3_errmsg((*p).db),
                                            );
                                            current_block = 12957157471781409979;
                                        } else {
                                            sqlite3_free(zSql_0 as *mut libc::c_void);
                                            nCol = sqlite3_column_count(pStmt_1);
                                            sqlite3_finalize(pStmt_1);
                                            pStmt_1 = 0 as *mut sqlite3_stmt;
                                            if nCol == 0 as libc::c_int {
                                                return 0 as libc::c_int;
                                            }
                                            zSql_0 = sqlite3_malloc64(
                                                (nByte * 2 as libc::c_int + 20 as libc::c_int
                                                    + nCol * 2 as libc::c_int) as sqlite3_uint64,
                                            ) as *mut libc::c_char;
                                            if zSql_0.is_null() {
                                                import_cleanup(&mut sCtx);
                                                shell_out_of_memory();
                                            }
                                            sqlite3_snprintf(
                                                nByte + 20 as libc::c_int,
                                                zSql_0,
                                                b"INSERT INTO %s VALUES(?\0" as *const u8
                                                    as *const libc::c_char,
                                                zFullTabName,
                                            );
                                            j_0 = strlen30(zSql_0);
                                            i_5 = 1 as libc::c_int;
                                            while i_5 < nCol {
                                                let fresh120 = j_0;
                                                j_0 = j_0 + 1;
                                                *zSql_0
                                                    .offset(fresh120 as isize) = ',' as i32 as libc::c_char;
                                                let fresh121 = j_0;
                                                j_0 = j_0 + 1;
                                                *zSql_0
                                                    .offset(fresh121 as isize) = '?' as i32 as libc::c_char;
                                                i_5 += 1;
                                                i_5;
                                            }
                                            let fresh122 = j_0;
                                            j_0 = j_0 + 1;
                                            *zSql_0
                                                .offset(fresh122 as isize) = ')' as i32 as libc::c_char;
                                            *zSql_0
                                                .offset(j_0 as isize) = 0 as libc::c_int as libc::c_char;
                                            if eVerbose >= 2 as libc::c_int {
                                                fprintf(
                                                    (*p).out,
                                                    b"Insert using: %s\n\0" as *const u8 as *const libc::c_char,
                                                    zSql_0,
                                                );
                                            }
                                            rc = sqlite3_prepare_v2(
                                                (*p).db,
                                                zSql_0,
                                                -(1 as libc::c_int),
                                                &mut pStmt_1,
                                                0 as *mut *const libc::c_char,
                                            );
                                            if rc != 0 {
                                                fprintf(
                                                    stderr,
                                                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                                    sqlite3_errmsg((*p).db),
                                                );
                                                if !pStmt_1.is_null() {
                                                    sqlite3_finalize(pStmt_1);
                                                }
                                                current_block = 12957157471781409979;
                                            } else {
                                                sqlite3_free(zSql_0 as *mut libc::c_void);
                                                sqlite3_free(zFullTabName as *mut libc::c_void);
                                                needCommit = sqlite3_get_autocommit((*p).db);
                                                if needCommit != 0 {
                                                    sqlite3_exec(
                                                        (*p).db,
                                                        b"BEGIN\0" as *const u8 as *const libc::c_char,
                                                        None,
                                                        0 as *mut libc::c_void,
                                                        0 as *mut *mut libc::c_char,
                                                    );
                                                }
                                                loop {
                                                    let startLine: libc::c_int = sCtx.nLine;
                                                    i_5 = 0 as libc::c_int;
                                                    while i_5 < nCol {
                                                        let z_4: *mut libc::c_char = xRead
                                                            .expect("non-null function pointer")(&mut sCtx);
                                                        if z_4.is_null() && i_5 == 0 as libc::c_int {
                                                            break;
                                                        }
                                                        if (*p).mode == 10 as libc::c_int
                                                            && (z_4.is_null()
                                                                || *z_4.offset(0 as libc::c_int as isize) as libc::c_int
                                                                    == 0 as libc::c_int) && i_5 == 0 as libc::c_int
                                                        {
                                                            break;
                                                        }
                                                        sqlite3_bind_text(
                                                            pStmt_1,
                                                            i_5 + 1 as libc::c_int,
                                                            z_4,
                                                            -(1 as libc::c_int),
                                                            ::core::mem::transmute::<
                                                                libc::intptr_t,
                                                                sqlite3_destructor_type,
                                                            >(-(1 as libc::c_int) as libc::intptr_t),
                                                        );
                                                        if i_5 < nCol - 1 as libc::c_int
                                                            && sCtx.cTerm != sCtx.cColSep
                                                        {
                                                            fprintf(
                                                                stderr,
                                                                b"%s:%d: expected %d columns but found %d - filling the rest with NULL\n\0"
                                                                    as *const u8 as *const libc::c_char,
                                                                sCtx.zFile,
                                                                startLine,
                                                                nCol,
                                                                i_5 + 1 as libc::c_int,
                                                            );
                                                            i_5 += 2 as libc::c_int;
                                                            while i_5 <= nCol {
                                                                sqlite3_bind_null(pStmt_1, i_5);
                                                                i_5 += 1;
                                                                i_5;
                                                            }
                                                        }
                                                        i_5 += 1;
                                                        i_5;
                                                    }
                                                    if sCtx.cTerm == sCtx.cColSep {
                                                        loop {
                                                            xRead.expect("non-null function pointer")(&mut sCtx);
                                                            i_5 += 1;
                                                            i_5;
                                                            if !(sCtx.cTerm == sCtx.cColSep) {
                                                                break;
                                                            }
                                                        }
                                                        fprintf(
                                                            stderr,
                                                            b"%s:%d: expected %d columns but found %d - extras ignored\n\0"
                                                                as *const u8 as *const libc::c_char,
                                                            sCtx.zFile,
                                                            startLine,
                                                            nCol,
                                                            i_5,
                                                        );
                                                    }
                                                    if i_5 >= nCol {
                                                        sqlite3_step(pStmt_1);
                                                        rc = sqlite3_reset(pStmt_1);
                                                        if rc != 0 as libc::c_int {
                                                            fprintf(
                                                                stderr,
                                                                b"%s:%d: INSERT failed: %s\n\0" as *const u8
                                                                    as *const libc::c_char,
                                                                sCtx.zFile,
                                                                startLine,
                                                                sqlite3_errmsg((*p).db),
                                                            );
                                                            sCtx.nErr += 1;
                                                            sCtx.nErr;
                                                        } else {
                                                            sCtx.nRow += 1;
                                                            sCtx.nRow;
                                                        }
                                                    }
                                                    if !(sCtx.cTerm != -(1 as libc::c_int)) {
                                                        break;
                                                    }
                                                }
                                                import_cleanup(&mut sCtx);
                                                sqlite3_finalize(pStmt_1);
                                                if needCommit != 0 {
                                                    sqlite3_exec(
                                                        (*p).db,
                                                        b"COMMIT\0" as *const u8 as *const libc::c_char,
                                                        None,
                                                        0 as *mut libc::c_void,
                                                        0 as *mut *mut libc::c_char,
                                                    );
                                                }
                                                if eVerbose > 0 as libc::c_int {
                                                    fprintf(
                                                        (*p).out,
                                                        b"Added %d rows with %d errors using %d lines of input\n\0"
                                                            as *const u8 as *const libc::c_char,
                                                        sCtx.nRow,
                                                        sCtx.nErr,
                                                        sCtx.nLine - 1 as libc::c_int,
                                                    );
                                                }
                                                current_block = 16476549346120425317;
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                                match current_block {
                                    16476549346120425317 => {}
                                    _ => {
                                        sqlite3_free(zCreate as *mut libc::c_void);
                                        sqlite3_free(zSql_0 as *mut libc::c_void);
                                        sqlite3_free(zFullTabName as *mut libc::c_void);
                                        import_cleanup(&mut sCtx);
                                        rc = 1 as libc::c_int;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    } else if c == 'i' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"imposter\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zSql_1: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zCollist: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pStmt_2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut tnum: libc::c_int = 0 as libc::c_int;
        let mut isWO: libc::c_int = 0 as libc::c_int;
        let mut lenPK: libc::c_int = 0 as libc::c_int;
        let mut i_6: libc::c_int = 0;
        if !((*p).shellFlgs & 0x400 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint)
        {
            fprintf(
                stderr,
                b".%s unavailable without --unsafe-testing\n\0" as *const u8
                    as *const libc::c_char,
                b"imposter\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else if !(nArg == 3 as libc::c_int
            || nArg == 2 as libc::c_int
                && sqlite3_stricmp(
                    azArg[1 as libc::c_int as usize],
                    b"off\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int)
        {
            fprintf(
                stderr,
                b"Usage: .imposter INDEX IMPOSTER\n       .imposter off\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            open_db(p, 0 as libc::c_int);
            if nArg == 2 as libc::c_int {
                sqlite3_test_control(
                    25 as libc::c_int,
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int,
                    1 as libc::c_int,
                );
            } else {
                zSql_1 = sqlite3_mprintf(
                    b"SELECT rootpage, 0 FROM sqlite_schema WHERE name='%q' AND type='index'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name='%q' AND type='table'   AND sql LIKE '%%without%%rowid%%'\0"
                        as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                    azArg[1 as libc::c_int as usize],
                );
                sqlite3_prepare_v2(
                    (*p).db,
                    zSql_1,
                    -(1 as libc::c_int),
                    &mut pStmt_2,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_1 as *mut libc::c_void);
                if sqlite3_step(pStmt_2) == 100 as libc::c_int {
                    tnum = sqlite3_column_int(pStmt_2, 0 as libc::c_int);
                    isWO = sqlite3_column_int(pStmt_2, 1 as libc::c_int);
                }
                sqlite3_finalize(pStmt_2);
                zSql_1 = sqlite3_mprintf(
                    b"PRAGMA index_xinfo='%q'\0" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_1,
                    -(1 as libc::c_int),
                    &mut pStmt_2,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_1 as *mut libc::c_void);
                i_6 = 0 as libc::c_int;
                while rc == 0 as libc::c_int
                    && sqlite3_step(pStmt_2) == 100 as libc::c_int
                {
                    let mut zLabel: [libc::c_char; 20] = [0; 20];
                    let mut zCol: *const libc::c_char = sqlite3_column_text(
                        pStmt_2,
                        2 as libc::c_int,
                    ) as *const libc::c_char;
                    i_6 += 1;
                    i_6;
                    if zCol.is_null() {
                        if sqlite3_column_int(pStmt_2, 1 as libc::c_int)
                            == -(1 as libc::c_int)
                        {
                            zCol = b"_ROWID_\0" as *const u8 as *const libc::c_char;
                        } else {
                            sqlite3_snprintf(
                                ::core::mem::size_of::<[libc::c_char; 20]>()
                                    as libc::c_ulong as libc::c_int,
                                zLabel.as_mut_ptr(),
                                b"expr%d\0" as *const u8 as *const libc::c_char,
                                i_6,
                            );
                            zCol = zLabel.as_mut_ptr();
                        }
                    }
                    if isWO != 0 && lenPK == 0 as libc::c_int
                        && sqlite3_column_int(pStmt_2, 5 as libc::c_int)
                            == 0 as libc::c_int && !zCollist.is_null()
                    {
                        lenPK = strlen(zCollist) as libc::c_int;
                    }
                    if zCollist.is_null() {
                        zCollist = sqlite3_mprintf(
                            b"\"%w\"\0" as *const u8 as *const libc::c_char,
                            zCol,
                        );
                    } else {
                        zCollist = sqlite3_mprintf(
                            b"%z,\"%w\"\0" as *const u8 as *const libc::c_char,
                            zCollist,
                            zCol,
                        );
                    }
                }
                sqlite3_finalize(pStmt_2);
                if i_6 == 0 as libc::c_int || tnum == 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"no such index: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                    sqlite3_free(zCollist as *mut libc::c_void);
                } else {
                    if lenPK == 0 as libc::c_int {
                        lenPK = 100000 as libc::c_int;
                    }
                    zSql_1 = sqlite3_mprintf(
                        b"CREATE TABLE \"%w\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\0"
                            as *const u8 as *const libc::c_char,
                        azArg[2 as libc::c_int as usize],
                        zCollist,
                        lenPK,
                        zCollist,
                    );
                    sqlite3_free(zCollist as *mut libc::c_void);
                    rc = sqlite3_test_control(
                        25 as libc::c_int,
                        (*p).db,
                        b"main\0" as *const u8 as *const libc::c_char,
                        1 as libc::c_int,
                        tnum,
                    );
                    if rc == 0 as libc::c_int {
                        rc = sqlite3_exec(
                            (*p).db,
                            zSql_1,
                            None,
                            0 as *mut libc::c_void,
                            0 as *mut *mut libc::c_char,
                        );
                        sqlite3_test_control(
                            25 as libc::c_int,
                            (*p).db,
                            b"main\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                        if rc != 0 {
                            fprintf(
                                stderr,
                                b"Error in [%s]: %s\n\0" as *const u8
                                    as *const libc::c_char,
                                zSql_1,
                                sqlite3_errmsg((*p).db),
                            );
                        } else {
                            fprintf(
                                stdout,
                                b"%s;\n\0" as *const u8 as *const libc::c_char,
                                zSql_1,
                            );
                            fprintf(
                                stdout,
                                b"WARNING: writing to an imposter table will corrupt the \"%s\" %s!\n\0"
                                    as *const u8 as *const libc::c_char,
                                azArg[1 as libc::c_int as usize],
                                if isWO != 0 {
                                    b"table\0" as *const u8 as *const libc::c_char
                                } else {
                                    b"index\0" as *const u8 as *const libc::c_char
                                },
                            );
                        }
                    } else {
                        fprintf(
                            stderr,
                            b"SQLITE_TESTCTRL_IMPOSTER returns %d\n\0" as *const u8
                                as *const libc::c_char,
                            rc,
                        );
                        rc = 1 as libc::c_int;
                    }
                    sqlite3_free(zSql_1 as *mut libc::c_void);
                }
            }
        }
    } else if c == 'l' as i32 && n >= 5 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"limits\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aLimit: [C2RustUnnamed_20; 12] = [
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"length\0" as *const u8 as *const libc::c_char,
                    limitCode: 0 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"sql_length\0" as *const u8 as *const libc::c_char,
                    limitCode: 1 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"column\0" as *const u8 as *const libc::c_char,
                    limitCode: 2 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"expr_depth\0" as *const u8 as *const libc::c_char,
                    limitCode: 3 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"compound_select\0" as *const u8 as *const libc::c_char,
                    limitCode: 4 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"vdbe_op\0" as *const u8 as *const libc::c_char,
                    limitCode: 5 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"function_arg\0" as *const u8 as *const libc::c_char,
                    limitCode: 6 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"attached\0" as *const u8 as *const libc::c_char,
                    limitCode: 7 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"like_pattern_length\0" as *const u8
                        as *const libc::c_char,
                    limitCode: 8 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"variable_number\0" as *const u8 as *const libc::c_char,
                    limitCode: 9 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"trigger_depth\0" as *const u8 as *const libc::c_char,
                    limitCode: 10 as libc::c_int,
                };
                init
            },
            {
                let init = C2RustUnnamed_20 {
                    zLimitName: b"worker_threads\0" as *const u8 as *const libc::c_char,
                    limitCode: 11 as libc::c_int,
                };
                init
            },
        ];
        let mut i_7: libc::c_int = 0;
        let mut n2_0: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        if nArg == 1 as libc::c_int {
            i_7 = 0 as libc::c_int;
            while i_7
                < (::core::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong,
                    ) as libc::c_int
            {
                printf(
                    b"%20s %d\n\0" as *const u8 as *const libc::c_char,
                    aLimit[i_7 as usize].zLimitName,
                    sqlite3_limit(
                        (*p).db,
                        aLimit[i_7 as usize].limitCode,
                        -(1 as libc::c_int),
                    ),
                );
                i_7 += 1;
                i_7;
            }
        } else if nArg > 3 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .limit NAME ?NEW-VALUE?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            let mut iLimit: libc::c_int = -(1 as libc::c_int);
            n2_0 = strlen30(azArg[1 as libc::c_int as usize]);
            i_7 = 0 as libc::c_int;
            loop {
                if !(i_7
                    < (::core::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 16408992005688070185;
                    break;
                }
                if sqlite3_strnicmp(
                    aLimit[i_7 as usize].zLimitName,
                    azArg[1 as libc::c_int as usize],
                    n2_0,
                ) == 0 as libc::c_int
                {
                    if iLimit < 0 as libc::c_int {
                        iLimit = i_7;
                    } else {
                        fprintf(
                            stderr,
                            b"ambiguous limit: \"%s\"\n\0" as *const u8
                                as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                        current_block = 16476549346120425317;
                        break;
                    }
                }
                i_7 += 1;
                i_7;
            }
            match current_block {
                16476549346120425317 => {}
                _ => {
                    if iLimit < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"unknown limit: \"%s\"\nenter \".limits\" with no arguments for a list.\n\0"
                                as *const u8 as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                    } else {
                        if nArg == 3 as libc::c_int {
                            sqlite3_limit(
                                (*p).db,
                                aLimit[iLimit as usize].limitCode,
                                integerValue(azArg[2 as libc::c_int as usize])
                                    as libc::c_int,
                            );
                        }
                        printf(
                            b"%20s %d\n\0" as *const u8 as *const libc::c_char,
                            aLimit[iLimit as usize].zLimitName,
                            sqlite3_limit(
                                (*p).db,
                                aLimit[iLimit as usize].limitCode,
                                -(1 as libc::c_int),
                            ),
                        );
                    }
                }
            }
        }
    } else if c == 'l' as i32 && n > 2 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"lint\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        lintDotCommand(p, azArg.as_mut_ptr(), nArg);
    } else if c == 'l' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"load\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zFile_2: *const libc::c_char = 0 as *const libc::c_char;
        let mut zProc: *const libc::c_char = 0 as *const libc::c_char;
        let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        failIfSafeMode(
            p,
            b"cannot run .load in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg < 2 as libc::c_int
            || *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == 0 as libc::c_int
        {
            fprintf(
                stderr,
                b"Usage: .load FILE ?ENTRYPOINT?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            zFile_2 = azArg[1 as libc::c_int as usize];
            zProc = if nArg >= 3 as libc::c_int {
                azArg[2 as libc::c_int as usize]
            } else {
                0 as *mut libc::c_char
            };
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_load_extension((*p).db, zFile_2, zProc, &mut zErrMsg);
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                    zErrMsg,
                );
                sqlite3_free(zErrMsg as *mut libc::c_void);
                rc = 1 as libc::c_int;
            }
        }
    } else if c == 'l' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"log\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .log FILENAME\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            let mut zFile_3: *const libc::c_char = azArg[1 as libc::c_int as usize];
            if (*p).bSafeMode as libc::c_int != 0
                && cli_strcmp(zFile_3, b"on\0" as *const u8 as *const libc::c_char)
                    != 0 as libc::c_int
                && cli_strcmp(zFile_3, b"off\0" as *const u8 as *const libc::c_char)
                    != 0 as libc::c_int
            {
                fprintf(
                    stdout,
                    b"cannot set .log to anything other than \"on\" or \"off\"\n\0"
                        as *const u8 as *const libc::c_char,
                );
                zFile_3 = b"off\0" as *const u8 as *const libc::c_char;
            }
            output_file_close((*p).pLog);
            if cli_strcmp(zFile_3, b"on\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                zFile_3 = b"stdout\0" as *const u8 as *const libc::c_char;
            }
            (*p).pLog = output_file_open(zFile_3, 0 as libc::c_int);
        }
    } else if c == 'm' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"mode\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zMode: *const libc::c_char = 0 as *const libc::c_char;
        let mut zTabname: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_8: libc::c_int = 0;
        let mut n2_1: libc::c_int = 0;
        let mut cmOpts: ColModeOpts = {
            let init = ColModeOpts {
                iWrap: 60 as libc::c_int,
                bQuote: 0 as libc::c_int as u8_0,
                bWordWrap: 0 as libc::c_int as u8_0,
            };
            init
        };
        i_8 = 1 as libc::c_int;
        loop {
            if !(i_8 < nArg) {
                current_block = 140018458177187763;
                break;
            }
            let z_5: *const libc::c_char = azArg[i_8 as usize];
            if optionMatch(z_5, b"wrap\0" as *const u8 as *const libc::c_char) != 0
                && (i_8 + 1 as libc::c_int) < nArg
            {
                i_8 += 1;
                cmOpts.iWrap = integerValue(azArg[i_8 as usize]) as libc::c_int;
            } else if optionMatch(z_5, b"ww\0" as *const u8 as *const libc::c_char) != 0
            {
                cmOpts.bWordWrap = 1 as libc::c_int as u8_0;
            } else if optionMatch(z_5, b"wordwrap\0" as *const u8 as *const libc::c_char)
                != 0 && (i_8 + 1 as libc::c_int) < nArg
            {
                i_8 += 1;
                cmOpts.bWordWrap = booleanValue(azArg[i_8 as usize]) as u8_0;
            } else if optionMatch(z_5, b"quote\0" as *const u8 as *const libc::c_char)
                != 0
            {
                cmOpts.bQuote = 1 as libc::c_int as u8_0;
            } else if optionMatch(z_5, b"noquote\0" as *const u8 as *const libc::c_char)
                != 0
            {
                cmOpts.bQuote = 0 as libc::c_int as u8_0;
            } else if zMode.is_null() {
                zMode = z_5;
                if cli_strcmp(z_5, b"qbox\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    let cmo: ColModeOpts = {
                        let init = ColModeOpts {
                            iWrap: 60 as libc::c_int,
                            bQuote: 1 as libc::c_int as u8_0,
                            bWordWrap: 0 as libc::c_int as u8_0,
                        };
                        init
                    };
                    zMode = b"box\0" as *const u8 as *const libc::c_char;
                    cmOpts = cmo;
                }
            } else if zTabname.is_null() {
                zTabname = z_5;
            } else if *z_5.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                    z_5,
                );
                fprintf(
                    stderr,
                    b"options:\n  --noquote\n  --quote\n  --wordwrap on/off\n  --wrap N\n  --ww\n\0"
                        as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            } else {
                fprintf(
                    stderr,
                    b"extra argument: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    z_5,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            }
            i_8 += 1;
            i_8;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if zMode.is_null() {
                    if (*p).mode == 1 as libc::c_int
                        || (*p).mode >= 14 as libc::c_int
                            && (*p).mode <= 16 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"current output mode: %s --wrap %d --wordwrap %s --%squote\n\0"
                                as *const u8 as *const libc::c_char,
                            modeDescr[(*p).mode as usize],
                            (*p).cmOpts.iWrap,
                            if (*p).cmOpts.bWordWrap as libc::c_int != 0 {
                                b"on\0" as *const u8 as *const libc::c_char
                            } else {
                                b"off\0" as *const u8 as *const libc::c_char
                            },
                            if (*p).cmOpts.bQuote as libc::c_int != 0 {
                                b"\0" as *const u8 as *const libc::c_char
                            } else {
                                b"no\0" as *const u8 as *const libc::c_char
                            },
                        );
                    } else {
                        fprintf(
                            (*p).out,
                            b"current output mode: %s\n\0" as *const u8
                                as *const libc::c_char,
                            modeDescr[(*p).mode as usize],
                        );
                    }
                    zMode = modeDescr[(*p).mode as usize];
                }
                n2_1 = strlen30(zMode);
                if cli_strncmp(
                    zMode,
                    b"lines\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 0 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"columns\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 1 as libc::c_int;
                    if (*p).shellFlgs & 0x80 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        (*p).showHeader = 1 as libc::c_int;
                    }
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"list\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"|\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"html\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 4 as libc::c_int;
                } else if cli_strncmp(
                    zMode,
                    b"tcl\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 7 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b" \0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"csv\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 8 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b",\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\r\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"tabs\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"\t\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"insert\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 5 as libc::c_int;
                    set_table_name(
                        p,
                        if !zTabname.is_null() {
                            zTabname
                        } else {
                            b"table\0" as *const u8 as *const libc::c_char
                        },
                    );
                } else if cli_strncmp(
                    zMode,
                    b"quote\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 6 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b",\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\n\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"ascii\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 10 as libc::c_int;
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).colSeparator).as_mut_ptr(),
                        b"\x1F\0" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                            as libc::c_int,
                        ((*p).rowSeparator).as_mut_ptr(),
                        b"\x1E\0" as *const u8 as *const libc::c_char,
                    );
                } else if cli_strncmp(
                    zMode,
                    b"markdown\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 14 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"table\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 15 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"box\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 16 as libc::c_int;
                    (*p).cmOpts = cmOpts;
                } else if cli_strncmp(
                    zMode,
                    b"count\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 17 as libc::c_int;
                } else if cli_strncmp(
                    zMode,
                    b"off\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 18 as libc::c_int;
                } else if cli_strncmp(
                    zMode,
                    b"json\0" as *const u8 as *const libc::c_char,
                    n2_1 as size_t,
                ) == 0 as libc::c_int
                {
                    (*p).mode = 13 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Error: mode should be one of: ascii box column csv html insert json line list markdown qbox quote table tabs tcl\n\0"
                            as *const u8 as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                }
                (*p).cMode = (*p).mode;
            }
        }
    } else if c == 'n' as i32
        && cli_strcmp(
            azArg[0 as libc::c_int as usize],
            b"nonce\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .nonce NONCE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else if ((*p).zNonce).is_null()
            || cli_strcmp(azArg[1 as libc::c_int as usize], (*p).zNonce)
                != 0 as libc::c_int
        {
            fprintf(
                stderr,
                b"line %d: incorrect nonce: \"%s\"\n\0" as *const u8
                    as *const libc::c_char,
                (*p).lineno,
                azArg[1 as libc::c_int as usize],
            );
            exit(1 as libc::c_int);
        } else {
            (*p).bSafeMode = 0 as libc::c_int as u8_0;
            return 0 as libc::c_int;
        }
    } else if c == 'n' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"nullvalue\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).nullValue).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .nullvalue STRING\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 'o' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"open\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int && n >= 2 as libc::c_int
    {
        let mut zFN: *const libc::c_char = 0 as *const libc::c_char;
        let mut zNewFilename: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut iName: libc::c_int = 1 as libc::c_int;
        let mut newFlag: libc::c_int = 0 as libc::c_int;
        let mut openMode: libc::c_int = 0 as libc::c_int;
        iName = 1 as libc::c_int;
        loop {
            if !(iName < nArg) {
                current_block = 1762637988685937496;
                break;
            }
            let z_6: *const libc::c_char = azArg[iName as usize];
            if optionMatch(z_6, b"new\0" as *const u8 as *const libc::c_char) != 0 {
                newFlag = 1 as libc::c_int;
            } else if optionMatch(z_6, b"zip\0" as *const u8 as *const libc::c_char) != 0
            {
                openMode = 3 as libc::c_int;
            } else if optionMatch(z_6, b"append\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 2 as libc::c_int;
            } else if optionMatch(z_6, b"readonly\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 4 as libc::c_int;
            } else if optionMatch(z_6, b"nofollow\0" as *const u8 as *const libc::c_char)
                != 0
            {
                (*p).openFlags |= 0x1000000 as libc::c_int;
            } else if optionMatch(
                z_6,
                b"deserialize\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                openMode = 5 as libc::c_int;
            } else if optionMatch(z_6, b"hexdb\0" as *const u8 as *const libc::c_char)
                != 0
            {
                openMode = 6 as libc::c_int;
            } else if optionMatch(z_6, b"maxsize\0" as *const u8 as *const libc::c_char)
                != 0 && (iName + 1 as libc::c_int) < nArg
            {
                iName += 1;
                (*p).szMax = integerValue(azArg[iName as usize]);
            } else if *z_6.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"unknown option: %s\n\0" as *const u8 as *const libc::c_char,
                    z_6,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            } else if !zFN.is_null() {
                fprintf(
                    stderr,
                    b"extra argument: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    z_6,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            } else {
                zFN = z_6;
            }
            iName += 1;
            iName;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                close_db((*p).db);
                (*p).db = 0 as *mut sqlite3;
                (*(*p).pAuxDb).zDbFilename = 0 as *const libc::c_char;
                sqlite3_free((*(*p).pAuxDb).zFreeOnClose as *mut libc::c_void);
                (*(*p).pAuxDb).zFreeOnClose = 0 as *mut libc::c_char;
                (*p).openMode = openMode as u8_0;
                (*p).openFlags = 0 as libc::c_int;
                (*p).szMax = 0 as libc::c_int as sqlite3_int64;
                if !zFN.is_null() || (*p).openMode as libc::c_int == 6 as libc::c_int {
                    if newFlag != 0 && !zFN.is_null() && (*p).bSafeMode == 0 {
                        shellDeleteFile(zFN);
                    }
                    if (*p).bSafeMode as libc::c_int != 0
                        && (*p).openMode as libc::c_int != 6 as libc::c_int
                        && !zFN.is_null()
                        && cli_strcmp(
                            zFN,
                            b":memory:\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                    {
                        failIfSafeMode(
                            p,
                            b"cannot open disk-based database files in safe mode\0"
                                as *const u8 as *const libc::c_char,
                        );
                    }
                    if !zFN.is_null() {
                        zNewFilename = sqlite3_mprintf(
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFN,
                        );
                        shell_check_oom(zNewFilename as *const libc::c_void);
                    } else {
                        zNewFilename = 0 as *mut libc::c_char;
                    }
                    (*(*p).pAuxDb).zDbFilename = zNewFilename;
                    open_db(p, 0x1 as libc::c_int);
                    if ((*p).db).is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open '%s'\n\0" as *const u8
                                as *const libc::c_char,
                            zNewFilename,
                        );
                        sqlite3_free(zNewFilename as *mut libc::c_void);
                    } else {
                        (*(*p).pAuxDb).zFreeOnClose = zNewFilename;
                    }
                }
                if ((*p).db).is_null() {
                    (*(*p).pAuxDb).zDbFilename = 0 as *const libc::c_char;
                    open_db(p, 0 as libc::c_int);
                }
            }
        }
    } else if c == 'o' as i32
        && (cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"output\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
            || cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"once\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int)
        || c == 'e' as i32 && n == 5 as libc::c_int
            && cli_strcmp(
                azArg[0 as libc::c_int as usize],
                b"excel\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
    {
        let mut zFile_4: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut bTxtMode: libc::c_int = 0 as libc::c_int;
        let mut i_9: libc::c_int = 0;
        let mut eMode: libc::c_int = 0 as libc::c_int;
        let mut bOnce: libc::c_int = 0 as libc::c_int;
        let mut zBOM: [libc::c_uchar; 4] = [0; 4];
        zBOM[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        if c == 'e' as i32 {
            eMode = 'x' as i32;
            bOnce = 2 as libc::c_int;
        } else if cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"once\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        {
            bOnce = 1 as libc::c_int;
        }
        i_9 = 1 as libc::c_int;
        loop {
            if !(i_9 < nArg) {
                current_block = 7484443043640631417;
                break;
            }
            let mut z_7: *mut libc::c_char = azArg[i_9 as usize];
            if *z_7.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if *z_7.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_7 = z_7.offset(1);
                    z_7;
                }
                if cli_strcmp(z_7, b"-bom\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zBOM[0 as libc::c_int
                        as usize] = 0xef as libc::c_int as libc::c_uchar;
                    zBOM[1 as libc::c_int
                        as usize] = 0xbb as libc::c_int as libc::c_uchar;
                    zBOM[2 as libc::c_int
                        as usize] = 0xbf as libc::c_int as libc::c_uchar;
                    zBOM[3 as libc::c_int as usize] = 0 as libc::c_int as libc::c_uchar;
                } else if c != 'e' as i32
                    && cli_strcmp(z_7, b"-x\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    eMode = 'x' as i32;
                } else if c != 'e' as i32
                    && cli_strcmp(z_7, b"-e\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    eMode = 'e' as i32;
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: unknown option: \"%s\".  Usage:\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_9 as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    current_block = 16476549346120425317;
                    break;
                }
            } else if zFile_4.is_null() && eMode != 'e' as i32 && eMode != 'x' as i32 {
                zFile_4 = sqlite3_mprintf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    z_7,
                );
                if !zFile_4.is_null()
                    && *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int
                        == '|' as i32
                {
                    while (i_9 + 1 as libc::c_int) < nArg {
                        i_9 += 1;
                        zFile_4 = sqlite3_mprintf(
                            b"%z %s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                            azArg[i_9 as usize],
                        );
                    }
                    current_block = 7484443043640631417;
                    break;
                }
            } else {
                fprintf(
                    (*p).out,
                    b"ERROR: extra parameter: \"%s\".  Usage:\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[i_9 as usize],
                );
                showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                rc = 1 as libc::c_int;
                sqlite3_free(zFile_4 as *mut libc::c_void);
                current_block = 16476549346120425317;
                break;
            }
            i_9 += 1;
            i_9;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if zFile_4.is_null() {
                    zFile_4 = sqlite3_mprintf(
                        b"stdout\0" as *const u8 as *const libc::c_char,
                    );
                }
                if bOnce != 0 {
                    (*p).outCount = 2 as libc::c_int;
                } else {
                    (*p).outCount = 0 as libc::c_int;
                }
                output_reset(p);
                if eMode == 'e' as i32 || eMode == 'x' as i32 {
                    (*p).doXdgOpen = 1 as libc::c_int as u8_0;
                    outputModePush(p);
                    if eMode == 'x' as i32 {
                        newTempFile(p, b"csv\0" as *const u8 as *const libc::c_char);
                        (*p).shellFlgs &= !(0x40 as libc::c_int) as libc::c_uint;
                        (*p).mode = 8 as libc::c_int;
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                as libc::c_int,
                            ((*p).colSeparator).as_mut_ptr(),
                            b",\0" as *const u8 as *const libc::c_char,
                        );
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                as libc::c_int,
                            ((*p).rowSeparator).as_mut_ptr(),
                            b"\r\n\0" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        newTempFile(p, b"txt\0" as *const u8 as *const libc::c_char);
                        bTxtMode = 1 as libc::c_int;
                    }
                    sqlite3_free(zFile_4 as *mut libc::c_void);
                    zFile_4 = sqlite3_mprintf(
                        b"%s\0" as *const u8 as *const libc::c_char,
                        (*p).zTempFile,
                    );
                }
                shell_check_oom(zFile_4 as *const libc::c_void);
                if *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int
                    == '|' as i32
                {
                    (*p)
                        .out = popen(
                        zFile_4.offset(1 as libc::c_int as isize),
                        b"w\0" as *const u8 as *const libc::c_char,
                    );
                    if ((*p).out).is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open pipe \"%s\"\n\0" as *const u8
                                as *const libc::c_char,
                            zFile_4.offset(1 as libc::c_int as isize),
                        );
                        (*p).out = stdout;
                        rc = 1 as libc::c_int;
                    } else {
                        if zBOM[0 as libc::c_int as usize] != 0 {
                            fwrite(
                                zBOM.as_mut_ptr() as *const libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                3 as libc::c_int as libc::c_ulong,
                                (*p).out,
                            );
                        }
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 4096]>()
                                as libc::c_ulong as libc::c_int,
                            ((*p).outfile).as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                        );
                    }
                } else {
                    (*p).out = output_file_open(zFile_4, bTxtMode);
                    if ((*p).out).is_null() {
                        if cli_strcmp(
                            zFile_4,
                            b"off\0" as *const u8 as *const libc::c_char,
                        ) != 0 as libc::c_int
                        {
                            fprintf(
                                stderr,
                                b"Error: cannot write to \"%s\"\n\0" as *const u8
                                    as *const libc::c_char,
                                zFile_4,
                            );
                        }
                        (*p).out = stdout;
                        rc = 1 as libc::c_int;
                    } else {
                        if zBOM[0 as libc::c_int as usize] != 0 {
                            fwrite(
                                zBOM.as_mut_ptr() as *const libc::c_void,
                                1 as libc::c_int as libc::c_ulong,
                                3 as libc::c_int as libc::c_ulong,
                                (*p).out,
                            );
                        }
                        sqlite3_snprintf(
                            ::core::mem::size_of::<[libc::c_char; 4096]>()
                                as libc::c_ulong as libc::c_int,
                            ((*p).outfile).as_mut_ptr(),
                            b"%s\0" as *const u8 as *const libc::c_char,
                            zFile_4,
                        );
                    }
                }
                sqlite3_free(zFile_4 as *mut libc::c_void);
            }
        }
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"parameter\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let current_block_1109: u64;
        open_db(p, 0 as libc::c_int);
        if nArg <= 1 as libc::c_int {
            current_block_1109 = 5408801321946008241;
        } else if nArg == 2 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"clear\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            sqlite3_exec(
                (*p).db,
                b"DROP TABLE IF EXISTS temp.sqlite_parameters;\0" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            current_block_1109 = 1283957829954624633;
        } else if nArg == 2 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"list\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut pStmt_3: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut rx: libc::c_int = 0;
            let mut len: libc::c_int = 0 as libc::c_int;
            rx = sqlite3_prepare_v2(
                (*p).db,
                b"SELECT max(length(key)) FROM temp.sqlite_parameters;\0" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
                &mut pStmt_3,
                0 as *mut *const libc::c_char,
            );
            if rx == 0 as libc::c_int && sqlite3_step(pStmt_3) == 100 as libc::c_int {
                len = sqlite3_column_int(pStmt_3, 0 as libc::c_int);
                if len > 40 as libc::c_int {
                    len = 40 as libc::c_int;
                }
            }
            sqlite3_finalize(pStmt_3);
            pStmt_3 = 0 as *mut sqlite3_stmt;
            if len != 0 {
                rx = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT key, quote(value) FROM temp.sqlite_parameters;\0"
                        as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_3,
                    0 as *mut *const libc::c_char,
                );
                while rx == 0 as libc::c_int
                    && sqlite3_step(pStmt_3) == 100 as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"%-*s %s\n\0" as *const u8 as *const libc::c_char,
                        len,
                        sqlite3_column_text(pStmt_3, 0 as libc::c_int),
                        sqlite3_column_text(pStmt_3, 1 as libc::c_int),
                    );
                }
                sqlite3_finalize(pStmt_3);
            }
            current_block_1109 = 1283957829954624633;
        } else if nArg == 2 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"init\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            bind_table_init(p);
            current_block_1109 = 1283957829954624633;
        } else if nArg == 4 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"set\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let mut rx_0: libc::c_int = 0;
            let mut zSql_2: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut pStmt_4: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let zKey: *const libc::c_char = azArg[2 as libc::c_int as usize];
            let zValue: *const libc::c_char = azArg[3 as libc::c_int as usize];
            bind_table_init(p);
            zSql_2 = sqlite3_mprintf(
                b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\0"
                    as *const u8 as *const libc::c_char,
                zKey,
                zValue,
            );
            shell_check_oom(zSql_2 as *const libc::c_void);
            pStmt_4 = 0 as *mut sqlite3_stmt;
            rx_0 = sqlite3_prepare_v2(
                (*p).db,
                zSql_2,
                -(1 as libc::c_int),
                &mut pStmt_4,
                0 as *mut *const libc::c_char,
            );
            sqlite3_free(zSql_2 as *mut libc::c_void);
            if rx_0 != 0 as libc::c_int {
                sqlite3_finalize(pStmt_4);
                pStmt_4 = 0 as *mut sqlite3_stmt;
                zSql_2 = sqlite3_mprintf(
                    b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\0"
                        as *const u8 as *const libc::c_char,
                    zKey,
                    zValue,
                );
                shell_check_oom(zSql_2 as *const libc::c_void);
                rx_0 = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_2,
                    -(1 as libc::c_int),
                    &mut pStmt_4,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_2 as *mut libc::c_void);
                if rx_0 != 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    sqlite3_finalize(pStmt_4);
                    pStmt_4 = 0 as *mut sqlite3_stmt;
                    rc = 1 as libc::c_int;
                }
            }
            sqlite3_step(pStmt_4);
            sqlite3_finalize(pStmt_4);
            current_block_1109 = 1283957829954624633;
        } else if nArg == 3 as libc::c_int
            && cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"unset\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            let zSql_3: *mut libc::c_char = sqlite3_mprintf(
                b"DELETE FROM temp.sqlite_parameters WHERE key=%Q\0" as *const u8
                    as *const libc::c_char,
                azArg[2 as libc::c_int as usize],
            );
            shell_check_oom(zSql_3 as *const libc::c_void);
            sqlite3_exec(
                (*p).db,
                zSql_3,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql_3 as *mut libc::c_void);
            current_block_1109 = 1283957829954624633;
        } else {
            current_block_1109 = 5408801321946008241;
        }
        match current_block_1109 {
            5408801321946008241 => {
                showHelp((*p).out, b"parameter\0" as *const u8 as *const libc::c_char);
            }
            _ => {}
        }
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"print\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut i_10: libc::c_int = 0;
        i_10 = 1 as libc::c_int;
        while i_10 < nArg {
            if i_10 > 1 as libc::c_int {
                fprintf((*p).out, b" \0" as *const u8 as *const libc::c_char);
            }
            fprintf(
                (*p).out,
                b"%s\0" as *const u8 as *const libc::c_char,
                azArg[i_10 as usize],
            );
            i_10 += 1;
            i_10;
        }
        fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
    } else if c == 'p' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"progress\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut i_11: libc::c_int = 0;
        let mut nn: libc::c_int = 0 as libc::c_int;
        (*p).flgProgress = 0 as libc::c_int as libc::c_uint;
        (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
        (*p).nProgress = 0 as libc::c_int as libc::c_uint;
        i_11 = 1 as libc::c_int;
        loop {
            if !(i_11 < nArg) {
                current_block = 18407369695945059008;
                break;
            }
            let mut z_8: *const libc::c_char = azArg[i_11 as usize];
            if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_8 = z_8.offset(1);
                z_8;
                if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_8 = z_8.offset(1);
                    z_8;
                }
                if cli_strcmp(z_8, b"quiet\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    || cli_strcmp(z_8, b"q\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x1 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_8, b"reset\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x2 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_8, b"once\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    (*p).flgProgress |= 0x4 as libc::c_int as libc::c_uint;
                } else if cli_strcmp(z_8, b"limit\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    if i_11 + 1 as libc::c_int >= nArg {
                        fprintf(
                            stderr,
                            b"Error: missing argument on --limit\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 16476549346120425317;
                        break;
                    } else {
                        i_11 += 1;
                        (*p)
                            .mxProgress = integerValue(azArg[i_11 as usize])
                            as libc::c_int as libc::c_uint;
                    }
                } else {
                    fprintf(
                        stderr,
                        b"Error: unknown option: \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_11 as usize],
                    );
                    rc = 1 as libc::c_int;
                    current_block = 16476549346120425317;
                    break;
                }
            } else {
                nn = integerValue(z_8) as libc::c_int;
            }
            i_11 += 1;
            i_11;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                open_db(p, 0 as libc::c_int);
                sqlite3_progress_handler(
                    (*p).db,
                    nn,
                    Some(
                        progress_handler
                            as unsafe extern "C" fn(*mut libc::c_void) -> libc::c_int,
                    ),
                    p as *mut libc::c_void,
                );
            }
        }
    } else if c == 'p' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"prompt\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg >= 2 as libc::c_int {
            shell_strncpy(
                mainPrompt.as_mut_ptr(),
                azArg[1 as libc::c_int as usize],
                ((::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int) as size_t,
            );
        }
        if nArg >= 3 as libc::c_int {
            shell_strncpy(
                continuePrompt.as_mut_ptr(),
                azArg[2 as libc::c_int as usize],
                ((::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int) as size_t,
            );
        }
    } else if c == 'q' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"quit\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        rc = 2 as libc::c_int;
    } else if c == 'r' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"read\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let inSaved: *mut FILE = (*p).in_0;
        let savedLineno: libc::c_int = (*p).lineno;
        failIfSafeMode(
            p,
            b"cannot run .read in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg != 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .read FILE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            if *(azArg[1 as libc::c_int as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == '|' as i32
            {
                (*p)
                    .in_0 = popen(
                    (azArg[1 as libc::c_int as usize]).offset(1 as libc::c_int as isize),
                    b"r\0" as *const u8 as *const libc::c_char,
                );
                if ((*p).in_0).is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                } else {
                    rc = process_input(p);
                    pclose((*p).in_0);
                }
            } else {
                (*p).in_0 = openChrSource(azArg[1 as libc::c_int as usize]);
                if ((*p).in_0).is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int;
                } else {
                    rc = process_input(p);
                    fclose((*p).in_0);
                }
            }
            (*p).in_0 = inSaved;
            (*p).lineno = savedLineno;
        }
    } else if c == 'r' as i32 && n >= 3 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"restore\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zSrcFile: *const libc::c_char = 0 as *const libc::c_char;
        let mut zDb_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut pSrc: *mut sqlite3 = 0 as *mut sqlite3;
        let mut pBackup_0: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
        let mut nTimeout: libc::c_int = 0 as libc::c_int;
        failIfSafeMode(
            p,
            b"cannot run .restore in safe mode\0" as *const u8 as *const libc::c_char,
        );
        if nArg == 2 as libc::c_int {
            zSrcFile = azArg[1 as libc::c_int as usize];
            zDb_0 = b"main\0" as *const u8 as *const libc::c_char;
            current_block = 12130449034757903526;
        } else if nArg == 3 as libc::c_int {
            zSrcFile = azArg[2 as libc::c_int as usize];
            zDb_0 = azArg[1 as libc::c_int as usize];
            current_block = 12130449034757903526;
        } else {
            fprintf(
                stderr,
                b"Usage: .restore ?DB? FILE\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
            current_block = 16476549346120425317;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                rc = sqlite3_open(zSrcFile, &mut pSrc);
                if rc != 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        zSrcFile,
                    );
                    close_db(pSrc);
                    return 1 as libc::c_int;
                }
                open_db(p, 0 as libc::c_int);
                pBackup_0 = sqlite3_backup_init(
                    (*p).db,
                    zDb_0,
                    pSrc,
                    b"main\0" as *const u8 as *const libc::c_char,
                );
                if pBackup_0.is_null() {
                    fprintf(
                        stderr,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    close_db(pSrc);
                    return 1 as libc::c_int;
                }
                loop {
                    rc = sqlite3_backup_step(pBackup_0, 100 as libc::c_int);
                    if !(rc == 0 as libc::c_int || rc == 5 as libc::c_int) {
                        break;
                    }
                    if !(rc == 5 as libc::c_int) {
                        continue;
                    }
                    let fresh123 = nTimeout;
                    nTimeout = nTimeout + 1;
                    if fresh123 >= 3 as libc::c_int {
                        break;
                    }
                    sqlite3_sleep(100 as libc::c_int);
                }
                sqlite3_backup_finish(pBackup_0);
                if rc == 101 as libc::c_int {
                    rc = 0 as libc::c_int;
                } else if rc == 5 as libc::c_int || rc == 6 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: source database is busy\n\0" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_errmsg((*p).db),
                    );
                    rc = 1 as libc::c_int;
                }
                close_db(pSrc);
            }
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"scanstats\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"vm\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).scanstatsOn = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"est\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).scanstatsOn = 2 as libc::c_int as u8_0;
            } else {
                (*p)
                    .scanstatsOn = booleanValue(azArg[1 as libc::c_int as usize])
                    as u8_0;
            }
            open_db(p, 0 as libc::c_int);
            sqlite3_db_config(
                (*p).db,
                1018 as libc::c_int,
                (*p).scanstatsOn as libc::c_int,
                0 as *mut libc::c_int,
            );
            fprintf(
                stderr,
                b"Warning: .scanstats not available in this build.\n\0" as *const u8
                    as *const libc::c_char,
            );
        } else {
            fprintf(
                stderr,
                b"Usage: .scanstats on|off|est\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"schema\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut sSelect: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut data_0: ShellState = ShellState {
            db: 0 as *mut sqlite3,
            autoExplain: 0,
            autoEQP: 0,
            autoEQPtest: 0,
            autoEQPtrace: 0,
            scanstatsOn: 0,
            openMode: 0,
            doXdgOpen: 0,
            nEqpLevel: 0,
            eTraceType: 0,
            bSafeMode: 0,
            bSafeModePersist: 0,
            cmOpts: ColModeOpts {
                iWrap: 0,
                bQuote: 0,
                bWordWrap: 0,
            },
            statsOn: 0,
            mEqpLines: 0,
            inputNesting: 0,
            outCount: 0,
            cnt: 0,
            lineno: 0,
            openFlags: 0,
            in_0: 0 as *mut FILE,
            out: 0 as *mut FILE,
            traceOut: 0 as *mut FILE,
            nErr: 0,
            mode: 0,
            modePrior: 0,
            cMode: 0,
            normalMode: 0,
            writableSchema: 0,
            showHeader: 0,
            nCheck: 0,
            nProgress: 0,
            mxProgress: 0,
            flgProgress: 0,
            shellFlgs: 0,
            priorShFlgs: 0,
            szMax: 0,
            zDestTable: 0 as *mut libc::c_char,
            zTempFile: 0 as *mut libc::c_char,
            zTestcase: [0; 30],
            colSeparator: [0; 20],
            rowSeparator: [0; 20],
            colSepPrior: [0; 20],
            rowSepPrior: [0; 20],
            colWidth: 0 as *mut libc::c_int,
            actualWidth: 0 as *mut libc::c_int,
            nWidth: 0,
            nullValue: [0; 20],
            outfile: [0; 4096],
            pStmt: 0 as *mut sqlite3_stmt,
            pLog: 0 as *mut FILE,
            aAuxDb: [AuxDb {
                db: 0 as *mut sqlite3,
                zDbFilename: 0 as *const libc::c_char,
                zFreeOnClose: 0 as *mut libc::c_char,
            }; 5],
            pAuxDb: 0 as *mut AuxDb,
            aiIndent: 0 as *mut libc::c_int,
            nIndent: 0,
            iIndent: 0,
            zNonce: 0 as *mut libc::c_char,
            sGraph: EQPGraph {
                pRow: 0 as *mut EQPGraphRow,
                pLast: 0 as *mut EQPGraphRow,
                zPrefix: [0; 100],
            },
            expert: ExpertInfo {
                pExpert: 0 as *mut sqlite3expert,
                bVerbose: 0,
            },
        };
        let mut zErrMsg_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zDiv: *const libc::c_char = b"(\0" as *const u8 as *const libc::c_char;
        let mut zName: *const libc::c_char = 0 as *const libc::c_char;
        let mut iSchema: libc::c_int = 0 as libc::c_int;
        let mut bDebug: libc::c_int = 0 as libc::c_int;
        let mut bNoSystemTabs: libc::c_int = 0 as libc::c_int;
        let mut ii_0: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        memcpy(
            &mut data_0 as *mut ShellState as *mut libc::c_void,
            p as *const libc::c_void,
            ::core::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        data_0.showHeader = 0 as libc::c_int;
        data_0.mode = 3 as libc::c_int;
        data_0.cMode = data_0.mode;
        initText(&mut sSelect);
        ii_0 = 1 as libc::c_int;
        loop {
            if !(ii_0 < nArg) {
                current_block = 12612561415879851009;
                break;
            }
            if optionMatch(
                azArg[ii_0 as usize],
                b"indent\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                data_0.mode = 11 as libc::c_int;
                data_0.cMode = data_0.mode;
            } else if optionMatch(
                azArg[ii_0 as usize],
                b"debug\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                bDebug = 1 as libc::c_int;
            } else if optionMatch(
                azArg[ii_0 as usize],
                b"nosys\0" as *const u8 as *const libc::c_char,
            ) != 0
            {
                bNoSystemTabs = 1 as libc::c_int;
            } else if *(azArg[ii_0 as usize]).offset(0 as libc::c_int as isize)
                as libc::c_int == '-' as i32
            {
                fprintf(
                    stderr,
                    b"Unknown option: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    azArg[ii_0 as usize],
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            } else if zName.is_null() {
                zName = azArg[ii_0 as usize];
            } else {
                fprintf(
                    stderr,
                    b"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\n\0"
                        as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            }
            ii_0 += 1;
            ii_0;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if !zName.is_null() {
                    let isSchema: libc::c_int = (sqlite3_strlike(
                        zName,
                        b"sqlite_master\0" as *const u8 as *const libc::c_char,
                        '\\' as i32 as libc::c_uint,
                    ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_schema\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_temp_master\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            zName,
                            b"sqlite_temp_schema\0" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int) as libc::c_int;
                    if isSchema != 0 {
                        let mut new_argv: [*mut libc::c_char; 2] = [0
                            as *mut libc::c_char; 2];
                        let mut new_colv: [*mut libc::c_char; 2] = [0
                            as *mut libc::c_char; 2];
                        new_argv[0 as libc::c_int
                            as usize] = sqlite3_mprintf(
                            b"CREATE TABLE %s (\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)\0"
                                as *const u8 as *const libc::c_char,
                            zName,
                        );
                        shell_check_oom(
                            new_argv[0 as libc::c_int as usize] as *const libc::c_void,
                        );
                        new_argv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                        new_colv[0 as libc::c_int
                            as usize] = b"sql\0" as *const u8 as *const libc::c_char
                            as *mut libc::c_char;
                        new_colv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                        callback(
                            &mut data_0 as *mut ShellState as *mut libc::c_void,
                            1 as libc::c_int,
                            new_argv.as_mut_ptr(),
                            new_colv.as_mut_ptr(),
                        );
                        sqlite3_free(
                            new_argv[0 as libc::c_int as usize] as *mut libc::c_void,
                        );
                    }
                }
                if !zDiv.is_null() {
                    let mut pStmt_5: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    rc = sqlite3_prepare_v2(
                        (*p).db,
                        b"SELECT name FROM pragma_database_list\0" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pStmt_5,
                        0 as *mut *const libc::c_char,
                    );
                    if rc != 0 {
                        fprintf(
                            stderr,
                            b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                            sqlite3_errmsg((*p).db),
                        );
                        sqlite3_finalize(pStmt_5);
                        rc = 1 as libc::c_int;
                        current_block = 16476549346120425317;
                    } else {
                        appendText(
                            &mut sSelect,
                            b"SELECT sql FROM\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        iSchema = 0 as libc::c_int;
                        while sqlite3_step(pStmt_5) == 100 as libc::c_int {
                            let zDb_1: *const libc::c_char = sqlite3_column_text(
                                pStmt_5,
                                0 as libc::c_int,
                            ) as *const libc::c_char;
                            let mut zScNum: [libc::c_char; 30] = [0; 30];
                            iSchema += 1;
                            sqlite3_snprintf(
                                ::core::mem::size_of::<[libc::c_char; 30]>()
                                    as libc::c_ulong as libc::c_int,
                                zScNum.as_mut_ptr(),
                                b"%d\0" as *const u8 as *const libc::c_char,
                                iSchema,
                            );
                            appendText(
                                &mut sSelect,
                                zDiv,
                                0 as libc::c_int as libc::c_char,
                            );
                            zDiv = b" UNION ALL \0" as *const u8 as *const libc::c_char;
                            appendText(
                                &mut sSelect,
                                b"SELECT shell_add_schema(sql,\0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            if sqlite3_stricmp(
                                zDb_1,
                                b"main\0" as *const u8 as *const libc::c_char,
                            ) != 0 as libc::c_int
                            {
                                appendText(
                                    &mut sSelect,
                                    zDb_1,
                                    '\'' as i32 as libc::c_char,
                                );
                            } else {
                                appendText(
                                    &mut sSelect,
                                    b"NULL\0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b",name) AS sql, type, tbl_name, name, rowid,\0"
                                    as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                zScNum.as_mut_ptr(),
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                b" AS snum, \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sSelect, zDb_1, '\'' as i32 as libc::c_char);
                            appendText(
                                &mut sSelect,
                                b" AS sname FROM \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sSelect, zDb_1, quoteChar(zDb_1));
                            appendText(
                                &mut sSelect,
                                b".sqlite_schema\0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        sqlite3_finalize(pStmt_5);
                        if !zName.is_null() {
                            appendText(
                                &mut sSelect,
                                b" UNION ALL SELECT shell_module_schema(name), 'table', name, name, name, 9e+99, 'main' FROM pragma_module_list\0"
                                    as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(
                            &mut sSelect,
                            b") WHERE \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if !zName.is_null() {
                            let zQarg: *mut libc::c_char = sqlite3_mprintf(
                                b"%Q\0" as *const u8 as *const libc::c_char,
                                zName,
                            );
                            let mut bGlob: libc::c_int = 0;
                            shell_check_oom(zQarg as *const libc::c_void);
                            bGlob = (!(strchr(zName, '*' as i32)).is_null()
                                || !(strchr(zName, '?' as i32)).is_null()
                                || !(strchr(zName, '[' as i32)).is_null()) as libc::c_int;
                            if !(strchr(zName, '.' as i32)).is_null() {
                                appendText(
                                    &mut sSelect,
                                    b"lower(printf('%s.%s',sname,tbl_name))\0" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            } else {
                                appendText(
                                    &mut sSelect,
                                    b"lower(tbl_name)\0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                if bGlob != 0 {
                                    b" GLOB \0" as *const u8 as *const libc::c_char
                                } else {
                                    b" LIKE \0" as *const u8 as *const libc::c_char
                                },
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(
                                &mut sSelect,
                                zQarg,
                                0 as libc::c_int as libc::c_char,
                            );
                            if bGlob == 0 {
                                appendText(
                                    &mut sSelect,
                                    b" ESCAPE '\\' \0" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b" AND \0" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            sqlite3_free(zQarg as *mut libc::c_void);
                        }
                        if bNoSystemTabs != 0 {
                            appendText(
                                &mut sSelect,
                                b"name NOT LIKE 'sqlite_%%' AND \0" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(
                            &mut sSelect,
                            b"sql IS NOT NULL ORDER BY snum, rowid\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if bDebug != 0 {
                            fprintf(
                                (*p).out,
                                b"SQL: %s;\n\0" as *const u8 as *const libc::c_char,
                                sSelect.z,
                            );
                        } else {
                            rc = sqlite3_exec(
                                (*p).db,
                                sSelect.z,
                                Some(
                                    callback
                                        as unsafe extern "C" fn(
                                            *mut libc::c_void,
                                            libc::c_int,
                                            *mut *mut libc::c_char,
                                            *mut *mut libc::c_char,
                                        ) -> libc::c_int,
                                ),
                                &mut data_0 as *mut ShellState as *mut libc::c_void,
                                &mut zErrMsg_0,
                            );
                        }
                        freeText(&mut sSelect);
                        current_block = 18128435683113922995;
                    }
                } else {
                    current_block = 18128435683113922995;
                }
                match current_block {
                    16476549346120425317 => {}
                    _ => {
                        if !zErrMsg_0.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                zErrMsg_0,
                            );
                            sqlite3_free(zErrMsg_0 as *mut libc::c_void);
                            rc = 1 as libc::c_int;
                        } else if rc != 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: querying schema information\n\0" as *const u8
                                    as *const libc::c_char,
                            );
                            rc = 1 as libc::c_int;
                        } else {
                            rc = 0 as libc::c_int;
                        }
                    }
                }
            }
        }
    } else if c == 's' as i32 && n == 11 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"selecttrace\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        || c == 't' as i32 && n == 9 as libc::c_int
            && cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"treetrace\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int
    {
        let mut x_3: libc::c_uint = if nArg >= 2 as libc::c_int {
            integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
        } else {
            0xffffffff as libc::c_uint
        };
        sqlite3_test_control(
            31 as libc::c_int,
            1 as libc::c_int,
            &mut x_3 as *mut libc::c_uint,
        );
    } else if c == 's' as i32 && n >= 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"selftest\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut bIsInit: libc::c_int = 0 as libc::c_int;
        let mut bVerbose: libc::c_int = 0 as libc::c_int;
        let mut bSelftestExists: libc::c_int = 0;
        let mut i_12: libc::c_int = 0;
        let mut k: libc::c_int = 0;
        let mut nTest: libc::c_int = 0 as libc::c_int;
        let mut nErr: libc::c_int = 0 as libc::c_int;
        let mut str: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut pStmt_6: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        open_db(p, 0 as libc::c_int);
        i_12 = 1 as libc::c_int;
        loop {
            if !(i_12 < nArg) {
                current_block = 13124292477636358238;
                break;
            }
            let mut z_9: *const libc::c_char = azArg[i_12 as usize];
            if *z_9.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *z_9.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
            {
                z_9 = z_9.offset(1);
                z_9;
            }
            if cli_strcmp(z_9, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bIsInit = 1 as libc::c_int;
            } else if cli_strcmp(z_9, b"-v\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                bVerbose += 1;
                bVerbose;
            } else {
                fprintf(
                    stderr,
                    b"Unknown option \"%s\" on \"%s\"\n\0" as *const u8
                        as *const libc::c_char,
                    azArg[i_12 as usize],
                    azArg[0 as libc::c_int as usize],
                );
                fprintf(
                    stderr,
                    b"Should be one of: --init -v\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            }
            i_12 += 1;
            i_12;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if sqlite3_table_column_metadata(
                    (*p).db,
                    b"main\0" as *const u8 as *const libc::c_char,
                    b"selftest\0" as *const u8 as *const libc::c_char,
                    0 as *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut *const libc::c_char,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                    0 as *mut libc::c_int,
                ) != 0 as libc::c_int
                {
                    bSelftestExists = 0 as libc::c_int;
                } else {
                    bSelftestExists = 1 as libc::c_int;
                }
                if bIsInit != 0 {
                    createSelftestTable(p);
                    bSelftestExists = 1 as libc::c_int;
                }
                initText(&mut str);
                appendText(
                    &mut str,
                    b"x\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                k = bSelftestExists;
                loop {
                    if !(k >= 0 as libc::c_int) {
                        current_block = 11383450317299595114;
                        break;
                    }
                    if k == 1 as libc::c_int {
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\0"
                                as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_6,
                            0 as *mut *const libc::c_char,
                        );
                    } else {
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"VALUES(0,'memo','Missing SELFTEST table - default checks only',''),      (1,'run','PRAGMA integrity_check','ok')\0"
                                as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_6,
                            0 as *mut *const libc::c_char,
                        );
                    }
                    if rc != 0 {
                        fprintf(
                            stderr,
                            b"Error querying the selftest table\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        sqlite3_finalize(pStmt_6);
                        current_block = 16476549346120425317;
                        break;
                    } else {
                        i_12 = 1 as libc::c_int;
                        while sqlite3_step(pStmt_6) == 100 as libc::c_int {
                            let tno: libc::c_int = sqlite3_column_int(
                                pStmt_6,
                                0 as libc::c_int,
                            );
                            let zOp: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                1 as libc::c_int,
                            ) as *const libc::c_char;
                            let zSql_4: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                2 as libc::c_int,
                            ) as *const libc::c_char;
                            let zAns: *const libc::c_char = sqlite3_column_text(
                                pStmt_6,
                                3 as libc::c_int,
                            ) as *const libc::c_char;
                            if !zOp.is_null() {
                                if !zSql_4.is_null() {
                                    if !zAns.is_null() {
                                        k = 0 as libc::c_int;
                                        if bVerbose > 0 as libc::c_int {
                                            printf(
                                                b"%d: %s %s\n\0" as *const u8 as *const libc::c_char,
                                                tno,
                                                zOp,
                                                zSql_4,
                                            );
                                        }
                                        if cli_strcmp(
                                            zOp,
                                            b"memo\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                        {
                                            fprintf(
                                                (*p).out,
                                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                                zSql_4,
                                            );
                                        } else if cli_strcmp(
                                            zOp,
                                            b"run\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                        {
                                            let mut zErrMsg_1: *mut libc::c_char = 0
                                                as *mut libc::c_char;
                                            str.n = 0 as libc::c_int;
                                            *(str.z)
                                                .offset(
                                                    0 as libc::c_int as isize,
                                                ) = 0 as libc::c_int as libc::c_char;
                                            rc = sqlite3_exec(
                                                (*p).db,
                                                zSql_4,
                                                Some(
                                                    captureOutputCallback
                                                        as unsafe extern "C" fn(
                                                            *mut libc::c_void,
                                                            libc::c_int,
                                                            *mut *mut libc::c_char,
                                                            *mut *mut libc::c_char,
                                                        ) -> libc::c_int,
                                                ),
                                                &mut str as *mut ShellText as *mut libc::c_void,
                                                &mut zErrMsg_1,
                                            );
                                            nTest += 1;
                                            nTest;
                                            if bVerbose != 0 {
                                                fprintf(
                                                    (*p).out,
                                                    b"Result: %s\n\0" as *const u8 as *const libc::c_char,
                                                    str.z,
                                                );
                                            }
                                            if rc != 0 || !zErrMsg_1.is_null() {
                                                nErr += 1;
                                                nErr;
                                                rc = 1 as libc::c_int;
                                                fprintf(
                                                    (*p).out,
                                                    b"%d: error-code-%d: %s\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    rc,
                                                    zErrMsg_1,
                                                );
                                                sqlite3_free(zErrMsg_1 as *mut libc::c_void);
                                            } else if cli_strcmp(zAns, str.z) != 0 as libc::c_int {
                                                nErr += 1;
                                                nErr;
                                                rc = 1 as libc::c_int;
                                                fprintf(
                                                    (*p).out,
                                                    b"%d: Expected: [%s]\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    zAns,
                                                );
                                                fprintf(
                                                    (*p).out,
                                                    b"%d:      Got: [%s]\n\0" as *const u8
                                                        as *const libc::c_char,
                                                    tno,
                                                    str.z,
                                                );
                                            }
                                        } else {
                                            fprintf(
                                                stderr,
                                                b"Unknown operation \"%s\" on selftest line %d\n\0"
                                                    as *const u8 as *const libc::c_char,
                                                zOp,
                                                tno,
                                            );
                                            rc = 1 as libc::c_int;
                                            break;
                                        }
                                    }
                                }
                            }
                            i_12 += 1;
                            i_12;
                        }
                        sqlite3_finalize(pStmt_6);
                        k -= 1;
                        k;
                    }
                }
                match current_block {
                    16476549346120425317 => {}
                    _ => {
                        freeText(&mut str);
                        fprintf(
                            (*p).out,
                            b"%d errors out of %d tests\n\0" as *const u8
                                as *const libc::c_char,
                            nErr,
                            nTest,
                        );
                    }
                }
            }
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"separator\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg < 2 as libc::c_int || nArg > 3 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .separator COL ?ROW?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
        if nArg >= 2 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).colSeparator).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int,
                azArg[1 as libc::c_int as usize],
            );
        }
        if nArg >= 3 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).rowSeparator).as_mut_ptr(),
                b"%.*s\0" as *const u8 as *const libc::c_char,
                (::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int - 1 as libc::c_int,
                azArg[2 as libc::c_int as usize],
            );
        }
    } else if c == 's' as i32 && n >= 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"sha3sum\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut zLike_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_13: libc::c_int = 0;
        let mut bSchema: libc::c_int = 0 as libc::c_int;
        let mut bSeparate: libc::c_int = 0 as libc::c_int;
        let mut iSize: libc::c_int = 224 as libc::c_int;
        let mut bDebug_0: libc::c_int = 0 as libc::c_int;
        let mut pStmt_7: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zSql_5: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zSep_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut sSql: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        let mut sQuery: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        open_db(p, 0 as libc::c_int);
        i_13 = 1 as libc::c_int;
        loop {
            if !(i_13 < nArg) {
                current_block = 10467608912112767940;
                break;
            }
            let mut z_10: *const libc::c_char = azArg[i_13 as usize];
            if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_10 = z_10.offset(1);
                z_10;
                if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_10 = z_10.offset(1);
                    z_10;
                }
                if cli_strcmp(z_10, b"schema\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bSchema = 1 as libc::c_int;
                } else if cli_strcmp(
                    z_10,
                    b"sha3-224\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                    || cli_strcmp(
                        z_10,
                        b"sha3-256\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    || cli_strcmp(
                        z_10,
                        b"sha3-384\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    || cli_strcmp(
                        z_10,
                        b"sha3-512\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                {
                    iSize = atoi(&*z_10.offset(5 as libc::c_int as isize));
                } else if cli_strcmp(
                    z_10,
                    b"debug\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    bDebug_0 = 1 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \"%s\"\n\0" as *const u8
                            as *const libc::c_char,
                        azArg[i_13 as usize],
                        azArg[0 as libc::c_int as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    current_block = 16476549346120425317;
                    break;
                }
            } else if !zLike_0.is_null() {
                fprintf(
                    stderr,
                    b"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n\0" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 16476549346120425317;
                break;
            } else {
                zLike_0 = z_10;
                bSeparate = 1 as libc::c_int;
                if sqlite3_strlike(
                    b"sqlite\\_%\0" as *const u8 as *const libc::c_char,
                    zLike_0,
                    '\\' as i32 as libc::c_uint,
                ) == 0 as libc::c_int
                {
                    bSchema = 1 as libc::c_int;
                }
            }
            i_13 += 1;
            i_13;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if bSchema != 0 {
                    zSql_5 = b"SELECT lower(name) as tname FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 UNION ALL SELECT 'sqlite_schema' ORDER BY 1 collate nocase\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                } else {
                    zSql_5 = b"SELECT lower(name) as tname FROM sqlite_schema WHERE type='table' AND coalesce(rootpage,0)>1 AND name NOT LIKE 'sqlite_%' ORDER BY 1 collate nocase\0"
                        as *const u8 as *const libc::c_char as *mut libc::c_char;
                }
                sqlite3_prepare_v2(
                    (*p).db,
                    zSql_5,
                    -(1 as libc::c_int),
                    &mut pStmt_7,
                    0 as *mut *const libc::c_char,
                );
                initText(&mut sQuery);
                initText(&mut sSql);
                appendText(
                    &mut sSql,
                    b"WITH [sha3sum$query](a,b) AS(\0" as *const u8
                        as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                zSep_0 = b"VALUES(\0" as *const u8 as *const libc::c_char
                    as *mut libc::c_char;
                while 100 as libc::c_int == sqlite3_step(pStmt_7) {
                    let zTab: *const libc::c_char = sqlite3_column_text(
                        pStmt_7,
                        0 as libc::c_int,
                    ) as *const libc::c_char;
                    if zTab.is_null() {
                        continue;
                    }
                    if !zLike_0.is_null()
                        && sqlite3_strlike(
                            zLike_0,
                            zTab,
                            0 as libc::c_int as libc::c_uint,
                        ) != 0 as libc::c_int
                    {
                        continue;
                    }
                    if cli_strncmp(
                        zTab,
                        b"sqlite_\0" as *const u8 as *const libc::c_char,
                        7 as libc::c_int as size_t,
                    ) != 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT * FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sQuery, zTab, '"' as i32 as libc::c_char);
                        appendText(
                            &mut sQuery,
                            b" NOT INDEXED;\0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_schema\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_sequence\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT name,seq FROM sqlite_sequence ORDER BY name;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_stat1\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else if cli_strcmp(
                        zTab,
                        b"sqlite_stat4\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut sQuery,
                            b"SELECT * FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sQuery, zTab, 0 as libc::c_int as libc::c_char);
                        appendText(
                            &mut sQuery,
                            b" ORDER BY tbl, idx, rowid;\n\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    appendText(&mut sSql, zSep_0, 0 as libc::c_int as libc::c_char);
                    appendText(&mut sSql, sQuery.z, '\'' as i32 as libc::c_char);
                    sQuery.n = 0 as libc::c_int;
                    appendText(
                        &mut sSql,
                        b",\0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    appendText(&mut sSql, zTab, '\'' as i32 as libc::c_char);
                    zSep_0 = b"),(\0" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                }
                sqlite3_finalize(pStmt_7);
                if bSeparate != 0 {
                    zSql_5 = sqlite3_mprintf(
                        b"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\0"
                            as *const u8 as *const libc::c_char,
                        sSql.z,
                        iSize,
                    );
                } else {
                    zSql_5 = sqlite3_mprintf(
                        b"%s)) SELECT lower(hex(sha3_query(group_concat(a,''),%d))) AS hash   FROM [sha3sum$query]\0"
                            as *const u8 as *const libc::c_char,
                        sSql.z,
                        iSize,
                    );
                }
                shell_check_oom(zSql_5 as *const libc::c_void);
                freeText(&mut sQuery);
                freeText(&mut sSql);
                if bDebug_0 != 0 {
                    fprintf(
                        (*p).out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        zSql_5,
                    );
                } else {
                    shell_exec(p, zSql_5, 0 as *mut *mut libc::c_char);
                }
                let mut lrc: libc::c_int = 0;
                let mut zRevText: *mut libc::c_char = b"SELECT lower(name) as tname FROM sqlite_schema\nWHERE type='table' AND coalesce(rootpage,0)>1\nAND name NOT LIKE 'sqlite_%%'%s\nORDER BY 1 collate nocase\0"
                    as *const u8 as *const libc::c_char as *mut libc::c_char;
                zRevText = sqlite3_mprintf(
                    zRevText,
                    if !zLike_0.is_null() {
                        b" AND name LIKE $tspec\0" as *const u8 as *const libc::c_char
                    } else {
                        b"\0" as *const u8 as *const libc::c_char
                    },
                );
                zRevText = sqlite3_mprintf(
                    b"with tabcols as materialized(\nselect tname, cname\nfrom ( select printf('\"%%w\"',ss.tname) as tname, printf('\"%%w\"',ti.name) as cname\n from (%z) ss\n inner join pragma_table_info(tname) ti))\nselect 'SELECT total(bad_text_count) AS bad_text_count\nFROM ('||group_concat(query, ' UNION ALL ')||')' as btc_query\n from (select 'SELECT COUNT(*) AS bad_text_count\nFROM '||tname||' WHERE '\n||group_concat('CAST(CAST('||cname||' AS BLOB) AS TEXT)<>'||cname\n|| ' AND typeof('||cname||')=''text'' ',\n' OR ') as query, tname from tabcols group by tname)\0"
                        as *const u8 as *const libc::c_char,
                    zRevText,
                );
                shell_check_oom(zRevText as *const libc::c_void);
                if bDebug_0 != 0 {
                    fprintf(
                        (*p).out,
                        b"%s\n\0" as *const u8 as *const libc::c_char,
                        zRevText,
                    );
                }
                lrc = sqlite3_prepare_v2(
                    (*p).db,
                    zRevText,
                    -(1 as libc::c_int),
                    &mut pStmt_7,
                    0 as *mut *const libc::c_char,
                );
                if lrc != 0 as libc::c_int {
                    rc = 1 as libc::c_int;
                } else {
                    if !zLike_0.is_null() {
                        sqlite3_bind_text(
                            pStmt_7,
                            1 as libc::c_int,
                            zLike_0,
                            -(1 as libc::c_int),
                            None,
                        );
                    }
                    lrc = (100 as libc::c_int == sqlite3_step(pStmt_7)) as libc::c_int;
                    if lrc != 0 {
                        let zGenQuery: *const libc::c_char = sqlite3_column_text(
                            pStmt_7,
                            0 as libc::c_int,
                        ) as *mut libc::c_char;
                        let mut pCheckStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                        lrc = sqlite3_prepare_v2(
                            (*p).db,
                            zGenQuery,
                            -(1 as libc::c_int),
                            &mut pCheckStmt,
                            0 as *mut *const libc::c_char,
                        );
                        if bDebug_0 != 0 {
                            fprintf(
                                (*p).out,
                                b"%s\n\0" as *const u8 as *const libc::c_char,
                                zGenQuery,
                            );
                        }
                        if lrc != 0 as libc::c_int {
                            rc = 1 as libc::c_int;
                        } else {
                            if 100 as libc::c_int == sqlite3_step(pCheckStmt) {
                                let countIrreversible: libc::c_double = sqlite3_column_double(
                                    pCheckStmt,
                                    0 as libc::c_int,
                                );
                                if countIrreversible > 0 as libc::c_int as libc::c_double {
                                    let sz: libc::c_int = (countIrreversible + 0.5f64)
                                        as libc::c_int;
                                    fprintf(
                                        stderr,
                                        b"Digest includes %d invalidly encoded text field%s.\n\0"
                                            as *const u8 as *const libc::c_char,
                                        sz,
                                        if sz > 1 as libc::c_int {
                                            b"s\0" as *const u8 as *const libc::c_char
                                        } else {
                                            b"\0" as *const u8 as *const libc::c_char
                                        },
                                    );
                                }
                            }
                            sqlite3_finalize(pCheckStmt);
                        }
                        sqlite3_finalize(pStmt_7);
                    }
                }
                if rc != 0 {
                    fprintf(
                        stderr,
                        b".sha3sum failed.\n\0" as *const u8 as *const libc::c_char,
                    );
                }
                sqlite3_free(zRevText as *mut libc::c_void);
                sqlite3_free(zSql_5 as *mut libc::c_void);
            }
        }
    } else if c == 's' as i32
        && (cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"shell\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
            || cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"system\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int)
    {
        let mut zCmd_0: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut i_14: libc::c_int = 0;
        let mut x_4: libc::c_int = 0;
        failIfSafeMode(
            p,
            b"cannot run .%s in safe mode\0" as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        if nArg < 2 as libc::c_int {
            fprintf(
                stderr,
                b"Usage: .system COMMAND\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        } else {
            zCmd_0 = sqlite3_mprintf(
                if (strchr(azArg[1 as libc::c_int as usize], ' ' as i32)).is_null() {
                    b"%s\0" as *const u8 as *const libc::c_char
                } else {
                    b"\"%s\"\0" as *const u8 as *const libc::c_char
                },
                azArg[1 as libc::c_int as usize],
            );
            i_14 = 2 as libc::c_int;
            while i_14 < nArg && !zCmd_0.is_null() {
                zCmd_0 = sqlite3_mprintf(
                    if (strchr(azArg[i_14 as usize], ' ' as i32)).is_null() {
                        b"%z %s\0" as *const u8 as *const libc::c_char
                    } else {
                        b"%z \"%s\"\0" as *const u8 as *const libc::c_char
                    },
                    zCmd_0,
                    azArg[i_14 as usize],
                );
                i_14 += 1;
                i_14;
            }
            x_4 = if !zCmd_0.is_null() { system(zCmd_0) } else { 1 as libc::c_int };
            sqlite3_free(zCmd_0 as *mut libc::c_void);
            if x_4 != 0 {
                fprintf(
                    stderr,
                    b"System command returns %d\n\0" as *const u8 as *const libc::c_char,
                    x_4,
                );
            }
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"show\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut azBool: [*const libc::c_char; 4] = [
            b"off\0" as *const u8 as *const libc::c_char,
            b"on\0" as *const u8 as *const libc::c_char,
            b"trigger\0" as *const u8 as *const libc::c_char,
            b"full\0" as *const u8 as *const libc::c_char,
        ];
        let mut zOut: *const libc::c_char = 0 as *const libc::c_char;
        let mut i_15: libc::c_int = 0;
        if nArg != 1 as libc::c_int {
            fprintf(stderr, b"Usage: .show\n\0" as *const u8 as *const libc::c_char);
            rc = 1 as libc::c_int;
        } else {
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"echo\0" as *const u8 as *const libc::c_char,
                azBool[((*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint) as libc::c_int as usize],
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"eqp\0" as *const u8 as *const libc::c_char,
                azBool[((*p).autoEQP as libc::c_int & 3 as libc::c_int) as usize],
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"explain\0" as *const u8 as *const libc::c_char,
                if (*p).mode == 9 as libc::c_int {
                    b"on\0" as *const u8 as *const libc::c_char
                } else if (*p).autoExplain as libc::c_int != 0 {
                    b"auto\0" as *const u8 as *const libc::c_char
                } else {
                    b"off\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"headers\0" as *const u8 as *const libc::c_char,
                azBool[((*p).showHeader != 0 as libc::c_int) as libc::c_int as usize],
            );
            if (*p).mode == 1 as libc::c_int
                || (*p).mode >= 14 as libc::c_int && (*p).mode <= 16 as libc::c_int
            {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s --wrap %d --wordwrap %s --%squote\n\0" as *const u8
                        as *const libc::c_char,
                    b"mode\0" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                    (*p).cmOpts.iWrap,
                    if (*p).cmOpts.bWordWrap as libc::c_int != 0 {
                        b"on\0" as *const u8 as *const libc::c_char
                    } else {
                        b"off\0" as *const u8 as *const libc::c_char
                    },
                    if (*p).cmOpts.bQuote as libc::c_int != 0 {
                        b"\0" as *const u8 as *const libc::c_char
                    } else {
                        b"no\0" as *const u8 as *const libc::c_char
                    },
                );
            } else {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                    b"mode\0" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                );
            }
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"nullvalue\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).nullValue).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"output\0" as *const u8 as *const libc::c_char,
                if strlen30(((*p).outfile).as_mut_ptr()) != 0 {
                    ((*p).outfile).as_mut_ptr() as *const libc::c_char
                } else {
                    b"stdout\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"colseparator\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).colSeparator).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"rowseparator\0" as *const u8 as *const libc::c_char,
            );
            output_c_string((*p).out, ((*p).rowSeparator).as_mut_ptr());
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            match (*p).statsOn {
                0 => {
                    zOut = b"off\0" as *const u8 as *const libc::c_char;
                }
                2 => {
                    zOut = b"stmt\0" as *const u8 as *const libc::c_char;
                }
                3 => {
                    zOut = b"vmstep\0" as *const u8 as *const libc::c_char;
                }
                _ => {
                    zOut = b"on\0" as *const u8 as *const libc::c_char;
                }
            }
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"stats\0" as *const u8 as *const libc::c_char,
                zOut,
            );
            fprintf(
                (*p).out,
                b"%12.12s: \0" as *const u8 as *const libc::c_char,
                b"width\0" as *const u8 as *const libc::c_char,
            );
            i_15 = 0 as libc::c_int;
            while i_15 < (*p).nWidth {
                fprintf(
                    (*p).out,
                    b"%d \0" as *const u8 as *const libc::c_char,
                    *((*p).colWidth).offset(i_15 as isize),
                );
                i_15 += 1;
                i_15;
            }
            fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
            fprintf(
                (*p).out,
                b"%12.12s: %s\n\0" as *const u8 as *const libc::c_char,
                b"filename\0" as *const u8 as *const libc::c_char,
                if !((*(*p).pAuxDb).zDbFilename).is_null() {
                    (*(*p).pAuxDb).zDbFilename
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
        }
    } else if c == 's' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"stats\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"stmt\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).statsOn = 2 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(
                azArg[1 as libc::c_int as usize],
                b"vmstep\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                (*p).statsOn = 3 as libc::c_int as libc::c_uint;
            } else {
                (*p)
                    .statsOn = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0
                    as libc::c_uint;
            }
        } else if nArg == 1 as libc::c_int {
            display_stats((*p).db, p, 0 as libc::c_int);
        } else {
            fprintf(
                stderr,
                b"Usage: .stats ?on|off|stmt|vmstep?\n\0" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 't' as i32 && n > 1 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"tables\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
        || c == 'i' as i32
            && (cli_strncmp(
                azArg[0 as libc::c_int as usize],
                b"indices\0" as *const u8 as *const libc::c_char,
                n as size_t,
            ) == 0 as libc::c_int
                || cli_strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"indexes\0" as *const u8 as *const libc::c_char,
                    n as size_t,
                ) == 0 as libc::c_int)
    {
        let mut pStmt_8: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut azResult: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
        let mut nRow: libc::c_int = 0;
        let mut nAlloc: libc::c_int = 0;
        let mut ii_1: libc::c_int = 0;
        let mut s: ShellText = ShellText {
            z: 0 as *mut libc::c_char,
            n: 0,
            nAlloc: 0,
        };
        initText(&mut s);
        open_db(p, 0 as libc::c_int);
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"PRAGMA database_list\0" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt_8,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            sqlite3_finalize(pStmt_8);
            return shellDatabaseError((*p).db);
        }
        if nArg > 2 as libc::c_int && c == 'i' as i32 {
            fprintf(
                stderr,
                b"Usage: .indexes ?LIKE-PATTERN?\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
            sqlite3_finalize(pStmt_8);
        } else {
            ii_1 = 0 as libc::c_int;
            while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                let zDbName: *const libc::c_char = sqlite3_column_text(
                    pStmt_8,
                    1 as libc::c_int,
                ) as *const libc::c_char;
                if !zDbName.is_null() {
                    if !(s.z).is_null()
                        && *(s.z).offset(0 as libc::c_int as isize) as libc::c_int != 0
                    {
                        appendText(
                            &mut s,
                            b" UNION ALL \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    if sqlite3_stricmp(
                        zDbName,
                        b"main\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        appendText(
                            &mut s,
                            b"SELECT name FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else {
                        appendText(
                            &mut s,
                            b"SELECT \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut s, zDbName, '\'' as i32 as libc::c_char);
                        appendText(
                            &mut s,
                            b"||'.'||name FROM \0" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    appendText(&mut s, zDbName, '"' as i32 as libc::c_char);
                    appendText(
                        &mut s,
                        b".sqlite_schema \0" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    if c == 't' as i32 {
                        appendText(
                            &mut s,
                            b" WHERE type IN ('table','view')   AND name NOT LIKE 'sqlite_%'   AND name LIKE ?1\0"
                                as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    } else {
                        appendText(
                            &mut s,
                            b" WHERE type='index'   AND tbl_name LIKE ?1\0" as *const u8
                                as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                }
                ii_1 += 1;
                ii_1;
            }
            rc = sqlite3_finalize(pStmt_8);
            if rc == 0 as libc::c_int {
                appendText(
                    &mut s,
                    b" ORDER BY 1\0" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    s.z,
                    -(1 as libc::c_int),
                    &mut pStmt_8,
                    0 as *mut *const libc::c_char,
                );
            }
            freeText(&mut s);
            if rc != 0 {
                return shellDatabaseError((*p).db);
            }
            nAlloc = 0 as libc::c_int;
            nRow = nAlloc;
            azResult = 0 as *mut *mut libc::c_char;
            if nArg > 1 as libc::c_int {
                sqlite3_bind_text(
                    pStmt_8,
                    1 as libc::c_int,
                    azArg[1 as libc::c_int as usize],
                    -(1 as libc::c_int),
                    ::core::mem::transmute::<
                        libc::intptr_t,
                        sqlite3_destructor_type,
                    >(-(1 as libc::c_int) as libc::intptr_t),
                );
            } else {
                sqlite3_bind_text(
                    pStmt_8,
                    1 as libc::c_int,
                    b"%\0" as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                    None,
                );
            }
            while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                if nRow >= nAlloc {
                    let mut azNew: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
                    let n2_2: libc::c_int = nAlloc * 2 as libc::c_int
                        + 10 as libc::c_int;
                    azNew = sqlite3_realloc64(
                        azResult as *mut libc::c_void,
                        (::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                            .wrapping_mul(n2_2 as libc::c_ulong) as sqlite3_uint64,
                    ) as *mut *mut libc::c_char;
                    shell_check_oom(azNew as *const libc::c_void);
                    nAlloc = n2_2;
                    azResult = azNew;
                }
                let ref mut fresh124 = *azResult.offset(nRow as isize);
                *fresh124 = sqlite3_mprintf(
                    b"%s\0" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pStmt_8, 0 as libc::c_int),
                );
                shell_check_oom(*azResult.offset(nRow as isize) as *const libc::c_void);
                nRow += 1;
                nRow;
            }
            if sqlite3_finalize(pStmt_8) != 0 as libc::c_int {
                rc = shellDatabaseError((*p).db);
            }
            if rc == 0 as libc::c_int && nRow > 0 as libc::c_int {
                let mut len_0: libc::c_int = 0;
                let mut maxlen: libc::c_int = 0 as libc::c_int;
                let mut i_16: libc::c_int = 0;
                let mut j_1: libc::c_int = 0;
                let mut nPrintCol: libc::c_int = 0;
                let mut nPrintRow: libc::c_int = 0;
                i_16 = 0 as libc::c_int;
                while i_16 < nRow {
                    len_0 = strlen30(*azResult.offset(i_16 as isize));
                    if len_0 > maxlen {
                        maxlen = len_0;
                    }
                    i_16 += 1;
                    i_16;
                }
                nPrintCol = 80 as libc::c_int / (maxlen + 2 as libc::c_int);
                if nPrintCol < 1 as libc::c_int {
                    nPrintCol = 1 as libc::c_int;
                }
                nPrintRow = (nRow + nPrintCol - 1 as libc::c_int) / nPrintCol;
                i_16 = 0 as libc::c_int;
                while i_16 < nPrintRow {
                    j_1 = i_16;
                    while j_1 < nRow {
                        let zSp: *mut libc::c_char = (if j_1 < nPrintRow {
                            b"\0" as *const u8 as *const libc::c_char
                        } else {
                            b"  \0" as *const u8 as *const libc::c_char
                        }) as *mut libc::c_char;
                        fprintf(
                            (*p).out,
                            b"%s%-*s\0" as *const u8 as *const libc::c_char,
                            zSp,
                            maxlen,
                            if !(*azResult.offset(j_1 as isize)).is_null() {
                                *azResult.offset(j_1 as isize) as *const libc::c_char
                            } else {
                                b"\0" as *const u8 as *const libc::c_char
                            },
                        );
                        j_1 += nPrintRow;
                    }
                    fprintf((*p).out, b"\n\0" as *const u8 as *const libc::c_char);
                    i_16 += 1;
                    i_16;
                }
            }
            ii_1 = 0 as libc::c_int;
            while ii_1 < nRow {
                sqlite3_free(*azResult.offset(ii_1 as isize) as *mut libc::c_void);
                ii_1 += 1;
                ii_1;
            }
            sqlite3_free(azResult as *mut libc::c_void);
        }
    } else if c == 't' as i32
        && cli_strcmp(
            azArg[0 as libc::c_int as usize],
            b"testcase\0" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
    {
        output_reset(p);
        (*p)
            .out = output_file_open(
            b"testcase-out.txt\0" as *const u8 as *const libc::c_char,
            0 as libc::c_int,
        );
        if ((*p).out).is_null() {
            fprintf(
                stderr,
                b"Error: cannot open 'testcase-out.txt'\n\0" as *const u8
                    as *const libc::c_char,
            );
        }
        if nArg >= 2 as libc::c_int {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).zTestcase).as_mut_ptr(),
                b"%s\0" as *const u8 as *const libc::c_char,
                azArg[1 as libc::c_int as usize],
            );
        } else {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                    as libc::c_int,
                ((*p).zTestcase).as_mut_ptr(),
                b"?\0" as *const u8 as *const libc::c_char,
            );
        }
    } else if c == 't' as i32 && n >= 8 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"testctrl\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        static mut aCtrl_0: [C2RustUnnamed_19; 17] = [
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"always\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 13 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"assert\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 12 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"byteorder\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 22 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"extra_schema_checks\0" as *const u8
                        as *const libc::c_char,
                    ctrlCode: 29 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"imposter\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 25 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"SCHEMA ON/OFF ROOTPAGE\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"internal_functions\0" as *const u8
                        as *const libc::c_char,
                    ctrlCode: 17 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"localtime_fault\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 18 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"never_corrupt\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 20 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"BOOLEAN\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"optimizations\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 15 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"DISABLE-MASK\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"pending_byte\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 11 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"OFFSET  \0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_restore\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 6 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_save\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 5 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"prng_seed\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 28 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"SEED ?db?\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"seek_count\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 30 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"sorter_mmap\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 24 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"NMAX\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"tune\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 32 as libc::c_int,
                    unSafe: 1 as libc::c_int,
                    zUsage: b"ID VALUE\0" as *const u8 as *const libc::c_char,
                };
                init
            },
            {
                let init = C2RustUnnamed_19 {
                    zCtrlName: b"uselongdouble\0" as *const u8 as *const libc::c_char,
                    ctrlCode: 34 as libc::c_int,
                    unSafe: 0 as libc::c_int,
                    zUsage: b"?BOOLEAN|\"default\"?\0" as *const u8
                        as *const libc::c_char,
                };
                init
            },
        ];
        let mut testctrl: libc::c_int = -(1 as libc::c_int);
        let mut iCtrl_0: libc::c_int = -(1 as libc::c_int);
        let mut rc2: libc::c_int = 0 as libc::c_int;
        let mut isOk_0: libc::c_int = 0 as libc::c_int;
        let mut i_17: libc::c_int = 0;
        let mut n2_3: libc::c_int = 0;
        let mut zCmd_1: *const libc::c_char = 0 as *const libc::c_char;
        open_db(p, 0 as libc::c_int);
        zCmd_1 = if nArg >= 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"help\0" as *const u8 as *const libc::c_char
        };
        if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
        {
            zCmd_1 = zCmd_1.offset(1);
            zCmd_1;
            if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd_1 = zCmd_1.offset(1);
                zCmd_1;
            }
        }
        if cli_strcmp(zCmd_1, b"help\0" as *const u8 as *const libc::c_char)
            == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"Available test-controls:\n\0" as *const u8 as *const libc::c_char,
            );
            i_17 = 0 as libc::c_int;
            while i_17
                < (::core::mem::size_of::<[C2RustUnnamed_19; 17]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong,
                    ) as libc::c_int
            {
                if !(aCtrl_0[i_17 as usize].unSafe != 0
                    && !((*p).shellFlgs & 0x400 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint))
                {
                    fprintf(
                        (*p).out,
                        b"  .testctrl %s %s\n\0" as *const u8 as *const libc::c_char,
                        aCtrl_0[i_17 as usize].zCtrlName,
                        aCtrl_0[i_17 as usize].zUsage,
                    );
                }
                i_17 += 1;
                i_17;
            }
            rc = 1 as libc::c_int;
        } else {
            n2_3 = strlen30(zCmd_1);
            i_17 = 0 as libc::c_int;
            loop {
                if !(i_17
                    < (::core::mem::size_of::<[C2RustUnnamed_19; 17]>() as libc::c_ulong)
                        .wrapping_div(
                            ::core::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong,
                        ) as libc::c_int)
                {
                    current_block = 10527046273561820631;
                    break;
                }
                if !(aCtrl_0[i_17 as usize].unSafe != 0
                    && !((*p).shellFlgs & 0x400 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint))
                {
                    if cli_strncmp(
                        zCmd_1,
                        aCtrl_0[i_17 as usize].zCtrlName,
                        n2_3 as size_t,
                    ) == 0 as libc::c_int
                    {
                        if testctrl < 0 as libc::c_int {
                            testctrl = aCtrl_0[i_17 as usize].ctrlCode;
                            iCtrl_0 = i_17;
                        } else {
                            fprintf(
                                stderr,
                                b"Error: ambiguous test-control: \"%s\"\nUse \".testctrl --help\" for help\n\0"
                                    as *const u8 as *const libc::c_char,
                                zCmd_1,
                            );
                            rc = 1 as libc::c_int;
                            current_block = 16476549346120425317;
                            break;
                        }
                    }
                }
                i_17 += 1;
                i_17;
            }
            match current_block {
                16476549346120425317 => {}
                _ => {
                    if testctrl < 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: unknown test-control: %s\nUse \".testctrl --help\" for help\n\0"
                                as *const u8 as *const libc::c_char,
                            zCmd_1,
                        );
                    } else {
                        match testctrl {
                            15 => {
                                if nArg == 3 as libc::c_int {
                                    let opt: libc::c_uint = strtol(
                                        azArg[2 as libc::c_int as usize],
                                        0 as *mut *mut libc::c_char,
                                        0 as libc::c_int,
                                    ) as libc::c_uint;
                                    rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            5 | 6 | 22 => {
                                if nArg == 2 as libc::c_int {
                                    rc2 = sqlite3_test_control(testctrl);
                                    isOk_0 = if testctrl == 22 as libc::c_int {
                                        1 as libc::c_int
                                    } else {
                                        3 as libc::c_int
                                    };
                                }
                            }
                            11 => {
                                if nArg == 3 as libc::c_int {
                                    let opt_0: libc::c_uint = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_uint;
                                    rc2 = sqlite3_test_control(testctrl, opt_0);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            28 => {
                                if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int {
                                    let mut ii_2: libc::c_int = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_int;
                                    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                    if ii_2 == 0 as libc::c_int
                                        && cli_strcmp(
                                            azArg[2 as libc::c_int as usize],
                                            b"random\0" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                    {
                                        sqlite3_randomness(
                                            ::core::mem::size_of::<libc::c_int>() as libc::c_ulong
                                                as libc::c_int,
                                            &mut ii_2 as *mut libc::c_int as *mut libc::c_void,
                                        );
                                        printf(
                                            b"-- random seed: %d\n\0" as *const u8
                                                as *const libc::c_char,
                                            ii_2,
                                        );
                                    }
                                    if nArg == 3 as libc::c_int {
                                        db = 0 as *mut sqlite3;
                                    } else {
                                        db = (*p).db;
                                        sqlite3_table_column_metadata(
                                            db,
                                            0 as *const libc::c_char,
                                            b"x\0" as *const u8 as *const libc::c_char,
                                            0 as *const libc::c_char,
                                            0 as *mut *const libc::c_char,
                                            0 as *mut *const libc::c_char,
                                            0 as *mut libc::c_int,
                                            0 as *mut libc::c_int,
                                            0 as *mut libc::c_int,
                                        );
                                    }
                                    rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            12 | 13 => {
                                if nArg == 3 as libc::c_int {
                                    let opt_1: libc::c_int = booleanValue(
                                        azArg[2 as libc::c_int as usize],
                                    );
                                    rc2 = sqlite3_test_control(testctrl, opt_1);
                                    isOk_0 = 1 as libc::c_int;
                                }
                            }
                            18 | 20 => {
                                if nArg == 3 as libc::c_int {
                                    let opt_2: libc::c_int = booleanValue(
                                        azArg[2 as libc::c_int as usize],
                                    );
                                    rc2 = sqlite3_test_control(testctrl, opt_2);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            34 => {
                                let mut opt_3: libc::c_int = -(1 as libc::c_int);
                                if nArg == 3 as libc::c_int {
                                    if cli_strcmp(
                                        azArg[2 as libc::c_int as usize],
                                        b"default\0" as *const u8 as *const libc::c_char,
                                    ) == 0 as libc::c_int
                                    {
                                        opt_3 = 2 as libc::c_int;
                                    } else {
                                        opt_3 = booleanValue(azArg[2 as libc::c_int as usize]);
                                    }
                                }
                                rc2 = sqlite3_test_control(testctrl, opt_3);
                                isOk_0 = 1 as libc::c_int;
                            }
                            17 => {
                                rc2 = sqlite3_test_control(testctrl, (*p).db);
                                isOk_0 = 3 as libc::c_int;
                            }
                            25 => {
                                if nArg == 5 as libc::c_int {
                                    rc2 = sqlite3_test_control(
                                        testctrl,
                                        (*p).db,
                                        azArg[2 as libc::c_int as usize],
                                        integerValue(azArg[3 as libc::c_int as usize]),
                                        integerValue(azArg[4 as libc::c_int as usize]),
                                    );
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            30 => {
                                let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                rc2 = sqlite3_test_control(
                                    testctrl,
                                    (*p).db,
                                    &mut x_5 as *mut u64_0,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%llu\n\0" as *const u8 as *const libc::c_char,
                                    x_5,
                                );
                                isOk_0 = 3 as libc::c_int;
                            }
                            24 => {
                                if nArg == 3 as libc::c_int {
                                    let opt_4: libc::c_int = integerValue(
                                        azArg[2 as libc::c_int as usize],
                                    ) as libc::c_uint as libc::c_int;
                                    rc2 = sqlite3_test_control(testctrl, (*p).db, opt_4);
                                    isOk_0 = 3 as libc::c_int;
                                }
                            }
                            _ => {}
                        }
                    }
                    if isOk_0 == 0 as libc::c_int && iCtrl_0 >= 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Usage: .testctrl %s %s\n\0" as *const u8
                                as *const libc::c_char,
                            zCmd_1,
                            aCtrl_0[iCtrl_0 as usize].zUsage,
                        );
                        rc = 1 as libc::c_int;
                    } else if isOk_0 == 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%d\n\0" as *const u8 as *const libc::c_char,
                            rc2,
                        );
                    } else if isOk_0 == 2 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"0x%08x\n\0" as *const u8 as *const libc::c_char,
                            rc2,
                        );
                    }
                }
            }
        }
    } else if c == 't' as i32 && n > 4 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"timeout\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        open_db(p, 0 as libc::c_int);
        sqlite3_busy_timeout(
            (*p).db,
            if nArg >= 2 as libc::c_int {
                integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int
            } else {
                0 as libc::c_int
            },
        );
    } else if c == 't' as i32 && n >= 5 as libc::c_int
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"timer\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        if nArg == 2 as libc::c_int {
            enableTimer = booleanValue(azArg[1 as libc::c_int as usize]);
            if enableTimer != 0 && 1 as libc::c_int == 0 {
                fprintf(
                    stderr,
                    b"Error: timer not available on this system.\n\0" as *const u8
                        as *const libc::c_char,
                );
                enableTimer = 0 as libc::c_int;
            }
        } else {
            fprintf(
                stderr,
                b"Usage: .timer on|off\n\0" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int;
        }
    } else if c == 't' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"trace\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut mType: libc::c_int = 0 as libc::c_int;
        let mut jj: libc::c_int = 0;
        open_db(p, 0 as libc::c_int);
        jj = 1 as libc::c_int;
        loop {
            if !(jj < nArg) {
                current_block = 14753126557259981112;
                break;
            }
            let z_11: *const libc::c_char = azArg[jj as usize];
            if *z_11.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                if optionMatch(z_11, b"expanded\0" as *const u8 as *const libc::c_char)
                    != 0
                {
                    (*p).eTraceType = 1 as libc::c_int as u8_0;
                } else if optionMatch(
                    z_11,
                    b"plain\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    (*p).eTraceType = 0 as libc::c_int as u8_0;
                } else if optionMatch(
                    z_11,
                    b"profile\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x2 as libc::c_int;
                } else if optionMatch(z_11, b"row\0" as *const u8 as *const libc::c_char)
                    != 0
                {
                    mType |= 0x4 as libc::c_int;
                } else if optionMatch(
                    z_11,
                    b"stmt\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x1 as libc::c_int;
                } else if optionMatch(
                    z_11,
                    b"close\0" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    mType |= 0x8 as libc::c_int;
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \".trace\"\n\0" as *const u8
                            as *const libc::c_char,
                        z_11,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 16476549346120425317;
                    break;
                }
            } else {
                output_file_close((*p).traceOut);
                (*p).traceOut = output_file_open(z_11, 0 as libc::c_int);
            }
            jj += 1;
            jj;
        }
        match current_block {
            16476549346120425317 => {}
            _ => {
                if ((*p).traceOut).is_null() {
                    sqlite3_trace_v2(
                        (*p).db,
                        0 as libc::c_int as libc::c_uint,
                        None,
                        0 as *mut libc::c_void,
                    );
                } else {
                    if mType == 0 as libc::c_int {
                        mType = 0x1 as libc::c_int;
                    }
                    sqlite3_trace_v2(
                        (*p).db,
                        mType as libc::c_uint,
                        Some(
                            sql_trace_callback
                                as unsafe extern "C" fn(
                                    libc::c_uint,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                    *mut libc::c_void,
                                ) -> libc::c_int,
                        ),
                        p as *mut libc::c_void,
                    );
                }
            }
        }
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"version\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let zPtrSz: *mut libc::c_char = (if ::core::mem::size_of::<
            *mut libc::c_void,
        >() as libc::c_ulong == 8 as libc::c_int as libc::c_ulong
        {
            b"64-bit\0" as *const u8 as *const libc::c_char
        } else {
            b"32-bit\0" as *const u8 as *const libc::c_char
        }) as *mut libc::c_char;
        fprintf(
            (*p).out,
            b"SQLite %s %s\n\0" as *const u8 as *const libc::c_char,
            sqlite3_libversion(),
            sqlite3_sourceid(),
        );
        fprintf(
            (*p).out,
            b"zlib version %s\n\0" as *const u8 as *const libc::c_char,
            zlibVersion(),
        );
        fprintf(
            (*p).out,
            b"clang-10.0.0 (%s)\n\0" as *const u8 as *const libc::c_char,
            zPtrSz,
        );
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfsinfo\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let zDbName_0: *const libc::c_char = if nArg == 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        };
        let mut pVfs: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                zDbName_0,
                27 as libc::c_int,
                &mut pVfs as *mut *mut sqlite3_vfs as *mut libc::c_void,
            );
            if !pVfs.is_null() {
                fprintf(
                    (*p).out,
                    b"vfs.zName      = \"%s\"\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).zName,
                );
                fprintf(
                    (*p).out,
                    b"vfs.iVersion   = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).iVersion,
                );
                fprintf(
                    (*p).out,
                    b"vfs.szOsFile   = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).szOsFile,
                );
                fprintf(
                    (*p).out,
                    b"vfs.mxPathname = %d\n\0" as *const u8 as *const libc::c_char,
                    (*pVfs).mxPathname,
                );
            }
        }
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfslist\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut pVfs_0: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        let mut pCurrent: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                b"main\0" as *const u8 as *const libc::c_char,
                27 as libc::c_int,
                &mut pCurrent as *mut *mut sqlite3_vfs as *mut libc::c_void,
            );
        }
        pVfs_0 = sqlite3_vfs_find(0 as *const libc::c_char);
        while !pVfs_0.is_null() {
            fprintf(
                (*p).out,
                b"vfs.zName      = \"%s\"%s\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).zName,
                if pVfs_0 == pCurrent {
                    b"  <--- CURRENT\0" as *const u8 as *const libc::c_char
                } else {
                    b"\0" as *const u8 as *const libc::c_char
                },
            );
            fprintf(
                (*p).out,
                b"vfs.iVersion   = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).iVersion,
            );
            fprintf(
                (*p).out,
                b"vfs.szOsFile   = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).szOsFile,
            );
            fprintf(
                (*p).out,
                b"vfs.mxPathname = %d\n\0" as *const u8 as *const libc::c_char,
                (*pVfs_0).mxPathname,
            );
            if !((*pVfs_0).pNext).is_null() {
                fprintf(
                    (*p).out,
                    b"-----------------------------------\n\0" as *const u8
                        as *const libc::c_char,
                );
            }
            pVfs_0 = (*pVfs_0).pNext;
        }
    } else if c == 'v' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"vfsname\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let zDbName_1: *const libc::c_char = if nArg == 2 as libc::c_int {
            azArg[1 as libc::c_int as usize] as *const libc::c_char
        } else {
            b"main\0" as *const u8 as *const libc::c_char
        };
        let mut zVfsName: *mut libc::c_char = 0 as *mut libc::c_char;
        if !((*p).db).is_null() {
            sqlite3_file_control(
                (*p).db,
                zDbName_1,
                12 as libc::c_int,
                &mut zVfsName as *mut *mut libc::c_char as *mut libc::c_void,
            );
            if !zVfsName.is_null() {
                fprintf(
                    (*p).out,
                    b"%s\n\0" as *const u8 as *const libc::c_char,
                    zVfsName,
                );
                sqlite3_free(zVfsName as *mut libc::c_void);
            }
        }
    } else if c == 'w' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"wheretrace\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut x_6: libc::c_uint = if nArg >= 2 as libc::c_int {
            integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
        } else {
            0xffffffff as libc::c_uint
        };
        sqlite3_test_control(
            31 as libc::c_int,
            3 as libc::c_int,
            &mut x_6 as *mut libc::c_uint,
        );
    } else if c == 'w' as i32
        && cli_strncmp(
            azArg[0 as libc::c_int as usize],
            b"width\0" as *const u8 as *const libc::c_char,
            n as size_t,
        ) == 0 as libc::c_int
    {
        let mut j_2: libc::c_int = 0;
        if nArg
            <= (::core::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                .wrapping_div(
                    ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                ) as libc::c_int
        {} else {
            __assert_fail(
                b"nArg<=ArraySize(azArg)\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                27160 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 42],
                    &[libc::c_char; 42],
                >(b"int do_meta_command(char *, ShellState *)\0"))
                    .as_ptr(),
            );
        }
        'c_100853: {
            if nArg
                <= (::core::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                    .wrapping_div(
                        ::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong,
                    ) as libc::c_int
            {} else {
                __assert_fail(
                    b"nArg<=ArraySize(azArg)\0" as *const u8 as *const libc::c_char,
                    b"shell.c\0" as *const u8 as *const libc::c_char,
                    27160 as libc::c_int as libc::c_uint,
                    (*::core::mem::transmute::<
                        &[u8; 42],
                        &[libc::c_char; 42],
                    >(b"int do_meta_command(char *, ShellState *)\0"))
                        .as_ptr(),
                );
            }
        };
        (*p).nWidth = nArg - 1 as libc::c_int;
        (*p)
            .colWidth = realloc(
            (*p).colWidth as *mut libc::c_void,
            (((*p).nWidth + 1 as libc::c_int) as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong),
        ) as *mut libc::c_int;
        if ((*p).colWidth).is_null() && (*p).nWidth > 0 as libc::c_int {
            shell_out_of_memory();
        }
        if (*p).nWidth != 0 {
            (*p)
                .actualWidth = &mut *((*p).colWidth).offset((*p).nWidth as isize)
                as *mut libc::c_int;
        }
        j_2 = 1 as libc::c_int;
        while j_2 < nArg {
            *((*p).colWidth)
                .offset(
                    (j_2 - 1 as libc::c_int) as isize,
                ) = integerValue(azArg[j_2 as usize]) as libc::c_int;
            j_2 += 1;
            j_2;
        }
    } else {
        fprintf(
            stderr,
            b"Error: unknown command or invalid arguments:  \"%s\". Enter \".help\" for help\n\0"
                as *const u8 as *const libc::c_char,
            azArg[0 as libc::c_int as usize],
        );
        rc = 1 as libc::c_int;
    }
    if (*p).outCount != 0 {
        (*p).outCount -= 1;
        (*p).outCount;
        if (*p).outCount == 0 as libc::c_int {
            output_reset(p);
        }
    }
    (*p).bSafeMode = (*p).bSafeModePersist;
    return rc;
}
unsafe extern "C" fn quickscan(
    mut zLine: *mut libc::c_char,
    mut qss: QuickScanState,
    pst: t_DynaPromptRef,
) -> QuickScanState {
    let mut current_block: u64;
    let mut cin: libc::c_char = 0;
    let mut cWait: libc::c_char = qss as libc::c_char;
    if cWait as libc::c_int == 0 as libc::c_int {
        current_block = 4966540918510056006;
    } else {
        current_block = 5689316957504528238;
    }
    '_PlainScan: loop {
        match current_block {
            4966540918510056006 => {
                if cWait as libc::c_int == 0 as libc::c_int {} else {
                    __assert_fail(
                        b"cWait==0\0" as *const u8 as *const libc::c_char,
                        b"shell.c\0" as *const u8 as *const libc::c_char,
                        27212 as libc::c_int as libc::c_uint,
                        (*::core::mem::transmute::<
                            &[u8; 66],
                            &[libc::c_char; 66],
                        >(
                            b"QuickScanState quickscan(char *, QuickScanState, t_DynaPromptRef)\0",
                        ))
                            .as_ptr(),
                    );
                }
                'c_128954: {
                    if cWait as libc::c_int == 0 as libc::c_int {} else {
                        __assert_fail(
                            b"cWait==0\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            27212 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 66],
                                &[libc::c_char; 66],
                            >(
                                b"QuickScanState quickscan(char *, QuickScanState, t_DynaPromptRef)\0",
                            ))
                                .as_ptr(),
                        );
                    }
                };
                's_14: loop {
                    let fresh125 = zLine;
                    zLine = zLine.offset(1);
                    cin = *fresh125;
                    if !(cin as libc::c_int != 0 as libc::c_int) {
                        break '_PlainScan;
                    }
                    if *(*__ctype_b_loc())
                        .offset(cin as libc::c_uchar as libc::c_int as isize)
                        as libc::c_int
                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
                    {
                        continue;
                    }
                    match cin as libc::c_int {
                        45 => {
                            if *zLine as libc::c_int != '-' as i32 {
                                current_block = 15925075030174552612;
                            } else {
                                loop {
                                    zLine = zLine.offset(1);
                                    cin = *zLine;
                                    if !(cin as libc::c_int != 0 as libc::c_int) {
                                        break;
                                    }
                                    if cin as libc::c_int == '\n' as i32 {
                                        current_block = 4966540918510056006;
                                        break 's_14;
                                    }
                                }
                                return qss;
                            }
                        }
                        59 => {
                            qss = ::core::mem::transmute::<
                                libc::c_uint,
                                QuickScanState,
                            >(
                                qss as libc::c_uint
                                    | QSS_EndingSemi as libc::c_int as libc::c_uint,
                            );
                            continue;
                        }
                        47 => {
                            if *zLine as libc::c_int == '*' as i32 {
                                zLine = zLine.offset(1);
                                zLine;
                                cWait = '*' as i32 as libc::c_char;
                                if !pst.is_null() && stdin_is_interactive != 0 {
                                    setLexemeOpen(
                                        pst,
                                        b"/*\0" as *const u8 as *const libc::c_char
                                            as *mut libc::c_char,
                                        0 as libc::c_int as libc::c_char,
                                    );
                                }
                                qss = (cWait as libc::c_uint
                                    | qss as libc::c_uint
                                        & QSS_ScanMask as libc::c_int as libc::c_uint)
                                    as QuickScanState;
                                current_block = 5689316957504528238;
                                break;
                            } else {
                                current_block = 15925075030174552612;
                            }
                        }
                        91 => {
                            cin = ']' as i32 as libc::c_char;
                            current_block = 12146134187116208131;
                        }
                        96 | 39 | 34 => {
                            current_block = 12146134187116208131;
                        }
                        40 => {
                            if !pst.is_null() && stdin_is_interactive != 0 {
                                trackParenLevel(pst, 1 as libc::c_int);
                            }
                            current_block = 15925075030174552612;
                        }
                        41 => {
                            if !pst.is_null() && stdin_is_interactive != 0 {
                                trackParenLevel(pst, -(1 as libc::c_int));
                            }
                            current_block = 15925075030174552612;
                        }
                        _ => {
                            current_block = 15925075030174552612;
                        }
                    }
                    match current_block {
                        15925075030174552612 => {
                            qss = (qss as libc::c_uint
                                & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                                | QSS_HasDark as libc::c_int as libc::c_uint)
                                as QuickScanState;
                        }
                        _ => {
                            cWait = cin;
                            qss = (QSS_HasDark as libc::c_int | cWait as libc::c_int)
                                as QuickScanState;
                            if !pst.is_null() && stdin_is_interactive != 0 {
                                setLexemeOpen(pst, 0 as *mut libc::c_char, cin);
                            }
                            current_block = 5689316957504528238;
                            break;
                        }
                    }
                }
            }
            _ => {
                let fresh126 = zLine;
                zLine = zLine.offset(1);
                cin = *fresh126;
                if !(cin as libc::c_int != 0 as libc::c_int) {
                    break;
                }
                if !(cin as libc::c_int == cWait as libc::c_int) {
                    current_block = 5689316957504528238;
                    continue;
                }
                match cWait as libc::c_int {
                    42 => {
                        if *zLine as libc::c_int != '/' as i32 {
                            current_block = 5689316957504528238;
                            continue;
                        }
                        zLine = zLine.offset(1);
                        zLine;
                        cWait = 0 as libc::c_int as libc::c_char;
                        if !pst.is_null() && stdin_is_interactive != 0 {
                            setLexemeOpen(
                                pst,
                                0 as *mut libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        qss = (0 as libc::c_int as libc::c_uint
                            | qss as libc::c_uint
                                & QSS_ScanMask as libc::c_int as libc::c_uint)
                            as QuickScanState;
                        current_block = 4966540918510056006;
                        continue;
                    }
                    96 | 39 | 34 => {
                        if *zLine as libc::c_int == cWait as libc::c_int {
                            zLine = zLine.offset(1);
                            zLine;
                            current_block = 5689316957504528238;
                            continue;
                        }
                    }
                    93 => {}
                    _ => {
                        __assert_fail(
                            b"0\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            27280 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 66],
                                &[libc::c_char; 66],
                            >(
                                b"QuickScanState quickscan(char *, QuickScanState, t_DynaPromptRef)\0",
                            ))
                                .as_ptr(),
                        );
                        'c_128922: {
                            __assert_fail(
                                b"0\0" as *const u8 as *const libc::c_char,
                                b"shell.c\0" as *const u8 as *const libc::c_char,
                                27280 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 66],
                                    &[libc::c_char; 66],
                                >(
                                    b"QuickScanState quickscan(char *, QuickScanState, t_DynaPromptRef)\0",
                                ))
                                    .as_ptr(),
                            );
                        };
                        current_block = 5689316957504528238;
                        continue;
                    }
                }
                cWait = 0 as libc::c_int as libc::c_char;
                if !pst.is_null() && stdin_is_interactive != 0 {
                    setLexemeOpen(
                        pst,
                        0 as *mut libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                }
                qss = (0 as libc::c_int as libc::c_uint
                    | qss as libc::c_uint & QSS_ScanMask as libc::c_int as libc::c_uint)
                    as QuickScanState;
                current_block = 4966540918510056006;
            }
        }
    }
    return qss;
}
unsafe extern "C" fn line_is_command_terminator(
    mut zLine: *mut libc::c_char,
) -> libc::c_int {
    while *(*__ctype_b_loc())
        .offset(
            *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                as isize,
        ) as libc::c_int & _ISspace as libc::c_int as libc::c_ushort as libc::c_int != 0
    {
        zLine = zLine.offset(1);
        zLine;
    }
    if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        zLine = zLine.offset(1 as libc::c_int as isize);
    } else if ({
        let mut __res: libc::c_int = 0;
        if ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
            > 1 as libc::c_int as libc::c_ulong
        {
            if 0 != 0 {
                let mut __c: libc::c_int = *zLine.offset(0 as libc::c_int as isize)
                    as libc::c_uchar as libc::c_int;
                __res = if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                    __c
                } else {
                    *(*__ctype_tolower_loc()).offset(__c as isize)
                };
            } else {
                __res = tolower(
                    *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int,
                );
            }
        } else {
            __res = *(*__ctype_tolower_loc())
                .offset(
                    *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize,
                );
        }
        __res
    }) as libc::c_char as libc::c_int == 'g' as i32
        && ({
            let mut __res: libc::c_int = 0;
            if ::core::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                > 1 as libc::c_int as libc::c_ulong
            {
                if 0 != 0 {
                    let mut __c: libc::c_int = *zLine.offset(1 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int;
                    __res = if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                        __c
                    } else {
                        *(*__ctype_tolower_loc()).offset(__c as isize)
                    };
                } else {
                    __res = tolower(
                        *zLine.offset(1 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int,
                    );
                }
            } else {
                __res = *(*__ctype_tolower_loc())
                    .offset(
                        *zLine.offset(1 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize,
                    );
            }
            __res
        }) as libc::c_char as libc::c_int == 'o' as i32
    {
        zLine = zLine.offset(2 as libc::c_int as isize);
    } else {
        return 0 as libc::c_int
    }
    return (quickscan(zLine, QSS_Start, 0 as t_DynaPromptRef) as libc::c_uint
        == QSS_Start as libc::c_int as libc::c_uint) as libc::c_int;
}
unsafe extern "C" fn line_is_complete(
    zSql: *mut libc::c_char,
    nSql: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if zSql.is_null() {
        return 1 as libc::c_int;
    }
    *zSql.offset(nSql as isize) = ';' as i32 as libc::c_char;
    *zSql.offset((nSql + 1 as libc::c_int) as isize) = 0 as libc::c_int as libc::c_char;
    rc = sqlite3_complete(zSql);
    *zSql.offset(nSql as isize) = 0 as libc::c_int as libc::c_char;
    return rc;
}
unsafe extern "C" fn runOneSqlLine(
    p: *mut ShellState,
    zSql: *mut libc::c_char,
    in_0: *mut FILE,
    startline: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    open_db(p, 0 as libc::c_int);
    if (*p).shellFlgs & 0x4 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        resolve_backslashes(zSql);
    }
    if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
        (*p).nProgress = 0 as libc::c_int as libc::c_uint;
    }
    beginTimer();
    rc = shell_exec(p, zSql, &mut zErrMsg);
    endTimer();
    if rc != 0 || !zErrMsg.is_null() {
        let mut zPrefix: [libc::c_char; 100] = [0; 100];
        let mut zErrorTail: *const libc::c_char = 0 as *const libc::c_char;
        let mut zErrorType: *const libc::c_char = 0 as *const libc::c_char;
        if zErrMsg.is_null() {
            zErrorType = b"Error\0" as *const u8 as *const libc::c_char;
            zErrorTail = sqlite3_errmsg((*p).db);
        } else if cli_strncmp(
            zErrMsg,
            b"in prepare, \0" as *const u8 as *const libc::c_char,
            12 as libc::c_int as size_t,
        ) == 0 as libc::c_int
        {
            zErrorType = b"Parse error\0" as *const u8 as *const libc::c_char;
            zErrorTail = &mut *zErrMsg.offset(12 as libc::c_int as isize)
                as *mut libc::c_char;
        } else if cli_strncmp(
            zErrMsg,
            b"stepping, \0" as *const u8 as *const libc::c_char,
            10 as libc::c_int as size_t,
        ) == 0 as libc::c_int
        {
            zErrorType = b"Runtime error\0" as *const u8 as *const libc::c_char;
            zErrorTail = &mut *zErrMsg.offset(10 as libc::c_int as isize)
                as *mut libc::c_char;
        } else {
            zErrorType = b"Error\0" as *const u8 as *const libc::c_char;
            zErrorTail = zErrMsg;
        }
        if !in_0.is_null() || stdin_is_interactive == 0 {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"%s near line %d:\0" as *const u8 as *const libc::c_char,
                zErrorType,
                startline,
            );
        } else {
            sqlite3_snprintf(
                ::core::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                    as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"%s:\0" as *const u8 as *const libc::c_char,
                zErrorType,
            );
        }
        fprintf(
            stderr,
            b"%s %s\n\0" as *const u8 as *const libc::c_char,
            zPrefix.as_mut_ptr(),
            zErrorTail,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
        zErrMsg = 0 as *mut libc::c_char;
        return 1 as libc::c_int;
    } else if (*p).shellFlgs & 0x20 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        let mut zLineBuf: [libc::c_char; 2000] = [0; 2000];
        sqlite3_snprintf(
            ::core::mem::size_of::<[libc::c_char; 2000]>() as libc::c_ulong
                as libc::c_int,
            zLineBuf.as_mut_ptr(),
            b"changes: %lld   total_changes: %lld\0" as *const u8 as *const libc::c_char,
            sqlite3_changes64((*p).db),
            sqlite3_total_changes64((*p).db),
        );
        fprintf(
            (*p).out,
            b"%s\n\0" as *const u8 as *const libc::c_char,
            zLineBuf.as_mut_ptr(),
        );
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn echo_group_input(
    p: *mut ShellState,
    zDo: *const libc::c_char,
) {
    if (*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint
    {
        fprintf((*p).out, b"%s\n\0" as *const u8 as *const libc::c_char, zDo);
    }
}
unsafe extern "C" fn process_input(p: *mut ShellState) -> libc::c_int {
    let mut zLine: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nLine: i64_0 = 0;
    let mut nSql: i64_0 = 0 as libc::c_int as i64_0;
    let mut nAlloc: i64_0 = 0 as libc::c_int as i64_0;
    let mut rc: libc::c_int = 0;
    let mut errCnt: libc::c_int = 0 as libc::c_int;
    let mut startline: i64_0 = 0 as libc::c_int as i64_0;
    let mut qss: QuickScanState = QSS_Start;
    if (*p).inputNesting == 25 as libc::c_int {
        fprintf(
            stderr,
            b"Input nesting limit (%d) reached at line %d. Check recursion.\n\0"
                as *const u8 as *const libc::c_char,
            25 as libc::c_int,
            (*p).lineno,
        );
        return 1 as libc::c_int;
    }
    (*p).inputNesting += 1;
    (*p).inputNesting;
    (*p).lineno = 0 as libc::c_int;
    setLexemeOpen(
        &mut dynPrompt,
        0 as *mut libc::c_char,
        0 as libc::c_int as libc::c_char,
    );
    trackParenLevel(&mut dynPrompt, 0 as libc::c_int);
    while errCnt == 0 as libc::c_int || bail_on_error == 0
        || ((*p).in_0).is_null() && stdin_is_interactive != 0
    {
        fflush((*p).out);
        zLine = one_input_line(
            (*p).in_0,
            zLine,
            (nSql > 0 as libc::c_int as libc::c_longlong) as libc::c_int,
        );
        if zLine.is_null() {
            if ((*p).in_0).is_null() && stdin_is_interactive != 0 {
                printf(b"\n\0" as *const u8 as *const libc::c_char);
            }
            break;
        } else {
            if seenInterrupt != 0 {
                if !((*p).in_0).is_null() {
                    break;
                }
                ::core::ptr::write_volatile(
                    &mut seenInterrupt as *mut libc::c_int,
                    0 as libc::c_int,
                );
            }
            (*p).lineno += 1;
            (*p).lineno;
            if qss as libc::c_uint & QSS_CharMask as libc::c_int as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && line_is_command_terminator(zLine) != 0
                && line_is_complete(zSql, nSql as libc::c_int) != 0
            {
                memcpy(
                    zLine as *mut libc::c_void,
                    b";\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            }
            qss = quickscan(zLine, qss, &mut dynPrompt);
            if qss as libc::c_uint & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && nSql == 0 as libc::c_int as libc::c_longlong
            {
                echo_group_input(p, zLine);
                qss = QSS_Start;
            } else if !zLine.is_null()
                && (*zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                    || *zLine.offset(0 as libc::c_int as isize) as libc::c_int
                        == '#' as i32) && nSql == 0 as libc::c_int as libc::c_longlong
            {
                setLexemeOpen(
                    &mut dynPrompt,
                    0 as *mut libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                trackParenLevel(&mut dynPrompt, 0 as libc::c_int);
                echo_group_input(p, zLine);
                if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                {
                    rc = do_meta_command(zLine, p);
                    if rc == 2 as libc::c_int {
                        break;
                    }
                    if rc != 0 {
                        errCnt += 1;
                        errCnt;
                    }
                }
                qss = QSS_Start;
            } else {
                nLine = strlen(zLine) as i64_0;
                if nSql + nLine + 2 as libc::c_int as libc::c_longlong >= nAlloc {
                    nAlloc = nSql + (nSql >> 1 as libc::c_int) + nLine
                        + 100 as libc::c_int as libc::c_longlong;
                    zSql = realloc(zSql as *mut libc::c_void, nAlloc as libc::c_ulong)
                        as *mut libc::c_char;
                    shell_check_oom(zSql as *const libc::c_void);
                }
                if nSql == 0 as libc::c_int as libc::c_longlong {
                    let mut i: i64_0 = 0;
                    i = 0 as libc::c_int as i64_0;
                    while *zLine.offset(i as isize) as libc::c_int != 0
                        && *(*__ctype_b_loc())
                            .offset(
                                *zLine.offset(i as isize) as libc::c_uchar as libc::c_int
                                    as isize,
                            ) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        i += 1;
                        i;
                    }
                    if nAlloc > 0 as libc::c_int as libc::c_longlong && !zSql.is_null()
                    {} else {
                        __assert_fail(
                            b"nAlloc>0 && zSql!=0\0" as *const u8 as *const libc::c_char,
                            b"shell.c\0" as *const u8 as *const libc::c_char,
                            27492 as libc::c_int as libc::c_uint,
                            (*::core::mem::transmute::<
                                &[u8; 32],
                                &[libc::c_char; 32],
                            >(b"int process_input(ShellState *)\0"))
                                .as_ptr(),
                        );
                    }
                    'c_100273: {
                        if nAlloc > 0 as libc::c_int as libc::c_longlong
                            && !zSql.is_null()
                        {} else {
                            __assert_fail(
                                b"nAlloc>0 && zSql!=0\0" as *const u8
                                    as *const libc::c_char,
                                b"shell.c\0" as *const u8 as *const libc::c_char,
                                27492 as libc::c_int as libc::c_uint,
                                (*::core::mem::transmute::<
                                    &[u8; 32],
                                    &[libc::c_char; 32],
                                >(b"int process_input(ShellState *)\0"))
                                    .as_ptr(),
                            );
                        }
                    };
                    memcpy(
                        zSql as *mut libc::c_void,
                        zLine.offset(i as isize) as *const libc::c_void,
                        (nLine + 1 as libc::c_int as libc::c_longlong - i)
                            as libc::c_ulong,
                    );
                    startline = (*p).lineno as i64_0;
                    nSql = nLine - i;
                } else {
                    let fresh127 = nSql;
                    nSql = nSql + 1;
                    *zSql.offset(fresh127 as isize) = '\n' as i32 as libc::c_char;
                    memcpy(
                        zSql.offset(nSql as isize) as *mut libc::c_void,
                        zLine as *const libc::c_void,
                        (nLine + 1 as libc::c_int as libc::c_longlong) as libc::c_ulong,
                    );
                    nSql += nLine;
                }
                if nSql != 0
                    && qss as libc::c_uint
                        & !(QSS_HasDark as libc::c_int) as libc::c_uint
                        == QSS_EndingSemi as libc::c_int as libc::c_uint
                    && sqlite3_complete(zSql) != 0
                {
                    echo_group_input(p, zSql);
                    errCnt
                        += runOneSqlLine(p, zSql, (*p).in_0, startline as libc::c_int);
                    setLexemeOpen(
                        &mut dynPrompt,
                        0 as *mut libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    trackParenLevel(&mut dynPrompt, 0 as libc::c_int);
                    nSql = 0 as libc::c_int as i64_0;
                    if (*p).outCount != 0 {
                        output_reset(p);
                        (*p).outCount = 0 as libc::c_int;
                    } else {
                        clearTempFile(p);
                    }
                    (*p).bSafeMode = (*p).bSafeModePersist;
                    qss = QSS_Start;
                } else if nSql != 0
                    && qss as libc::c_uint
                        & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                        == QSS_Start as libc::c_int as libc::c_uint
                {
                    echo_group_input(p, zSql);
                    nSql = 0 as libc::c_int as i64_0;
                    qss = QSS_Start;
                }
            }
        }
    }
    if nSql != 0 {
        echo_group_input(p, zSql);
        errCnt += runOneSqlLine(p, zSql, (*p).in_0, startline as libc::c_int);
        setLexemeOpen(
            &mut dynPrompt,
            0 as *mut libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
        trackParenLevel(&mut dynPrompt, 0 as libc::c_int);
    }
    free(zSql as *mut libc::c_void);
    free(zLine as *mut libc::c_void);
    (*p).inputNesting -= 1;
    (*p).inputNesting;
    return (errCnt > 0 as libc::c_int) as libc::c_int;
}
unsafe extern "C" fn find_home_dir(clearFlag: libc::c_int) -> *mut libc::c_char {
    static mut home_dir: *mut libc::c_char = 0 as *const libc::c_char
        as *mut libc::c_char;
    if clearFlag != 0 {
        free(home_dir as *mut libc::c_void);
        home_dir = 0 as *mut libc::c_char;
        return 0 as *mut libc::c_char;
    }
    if !home_dir.is_null() {
        return home_dir;
    }
    let mut pwent: *mut passwd = 0 as *mut passwd;
    let uid: uid_t = getuid();
    pwent = getpwuid(uid);
    if !pwent.is_null() {
        home_dir = (*pwent).pw_dir;
    }
    if home_dir.is_null() {
        home_dir = getenv(b"HOME\0" as *const u8 as *const libc::c_char);
    }
    if !home_dir.is_null() {
        let n: i64_0 = (strlen(home_dir))
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as i64_0;
        let z: *mut libc::c_char = malloc(n as libc::c_ulong) as *mut libc::c_char;
        if !z.is_null() {
            memcpy(
                z as *mut libc::c_void,
                home_dir as *const libc::c_void,
                n as libc::c_ulong,
            );
        }
        home_dir = z;
    }
    return home_dir;
}
unsafe extern "C" fn find_xdg_config() -> *const libc::c_char {
    static mut alreadyTried: libc::c_int = 0 as libc::c_int;
    static mut zConfig: *mut libc::c_char = 0 as *const libc::c_char
        as *mut libc::c_char;
    let mut zXdgHome: *const libc::c_char = 0 as *const libc::c_char;
    if alreadyTried != 0 as libc::c_int {
        return zConfig;
    }
    alreadyTried = 1 as libc::c_int;
    zXdgHome = getenv(b"XDG_CONFIG_HOME\0" as *const u8 as *const libc::c_char);
    if zXdgHome.is_null() {
        return 0 as *const libc::c_char;
    }
    zConfig = sqlite3_mprintf(
        b"%s/sqlite3/sqliterc\0" as *const u8 as *const libc::c_char,
        zXdgHome,
    );
    shell_check_oom(zConfig as *const libc::c_void);
    if access(zConfig, 0 as libc::c_int) != 0 as libc::c_int {
        sqlite3_free(zConfig as *mut libc::c_void);
        zConfig = 0 as *mut libc::c_char;
    }
    return zConfig;
}
unsafe extern "C" fn process_sqliterc(
    p: *mut ShellState,
    sqliterc_override: *const libc::c_char,
) {
    let mut home_dir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sqliterc: *const libc::c_char = sqliterc_override;
    let mut zBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let inSaved: *mut FILE = (*p).in_0;
    let savedLineno: libc::c_int = (*p).lineno;
    if sqliterc.is_null() {
        sqliterc = find_xdg_config();
    }
    if sqliterc.is_null() {
        home_dir = find_home_dir(0 as libc::c_int);
        if home_dir.is_null() {
            fprintf(
                stderr,
                b"-- warning: cannot find home directory; cannot read ~/.sqliterc\n\0"
                    as *const u8 as *const libc::c_char,
            );
            return;
        }
        zBuf = sqlite3_mprintf(
            b"%s/.sqliterc\0" as *const u8 as *const libc::c_char,
            home_dir,
        );
        shell_check_oom(zBuf as *const libc::c_void);
        sqliterc = zBuf;
    }
    (*p).in_0 = fopen(sqliterc, b"rb\0" as *const u8 as *const libc::c_char);
    if !((*p).in_0).is_null() {
        if stdin_is_interactive != 0 {
            fprintf(
                stderr,
                b"-- Loading resources from %s\n\0" as *const u8 as *const libc::c_char,
                sqliterc,
            );
        }
        if process_input(p) != 0 && bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
        fclose((*p).in_0);
    } else if !sqliterc_override.is_null() {
        fprintf(
            stderr,
            b"cannot open: \"%s\"\n\0" as *const u8 as *const libc::c_char,
            sqliterc,
        );
        if bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
    }
    (*p).in_0 = inSaved;
    (*p).lineno = savedLineno;
    sqlite3_free(zBuf as *mut libc::c_void);
}
static mut zOptions: [libc::c_char; 2340] = unsafe {
    *::core::mem::transmute::<
        &[u8; 2340],
        &[libc::c_char; 2340],
    >(
        b"   --                   treat no subsequent arguments as options\n   -A ARGS...           run \".archive ARGS\" and exit\n   -append              append the database to the end of the file\n   -ascii               set output mode to 'ascii'\n   -bail                stop after hitting an error\n   -batch               force batch I/O\n   -box                 set output mode to 'box'\n   -column              set output mode to 'column'\n   -cmd COMMAND         run \"COMMAND\" before reading stdin\n   -csv                 set output mode to 'csv'\n   -deserialize         open the database using sqlite3_deserialize()\n   -echo                print inputs before execution\n   -init FILENAME       read/process named file\n   -[no]header          turn headers on or off\n   -help                show this message\n   -html                set output mode to HTML\n   -interactive         force interactive I/O\n   -json                set output mode to 'json'\n   -line                set output mode to 'line'\n   -list                set output mode to 'list'\n   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n   -markdown            set output mode to 'markdown'\n   -maxsize N           maximum size for a --deserialize database\n   -memtrace            trace all memory allocations and deallocations\n   -mmap N              default mmap size set to N\n   -newline SEP         set output row separator. Default: '\\n'\n   -nofollow            refuse to open symbolic links to database files\n   -nonce STRING        set the safe-mode escape nonce\n   -nullvalue TEXT      set text string for NULL values. Default ''\n   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n   -pcachetrace         trace all page cache operations\n   -quote               set output mode to 'quote'\n   -readonly            open the database read-only\n   -safe                enable safe-mode\n   -separator SEP       set output column separator. Default: '|'\n   -stats               print memory stats before each finalize\n   -table               set output mode to 'table'\n   -tabs                set output mode to 'tabs'\n   -unsafe-testing      allow unsafe commands and modes for testing\n   -version             show SQLite version\n   -vfs NAME            use NAME as the default VFS\n   -zip                 open the file as a ZIP Archive\n\0",
    )
};
unsafe extern "C" fn usage(showDetail: libc::c_int) {
    fprintf(
        stderr,
        b"Usage: %s [OPTIONS] [FILENAME [SQL]]\nFILENAME is the name of an SQLite database. A new database is created\nif the file does not previously exist. Defaults to :memory:.\n\0"
            as *const u8 as *const libc::c_char,
        Argv0,
    );
    if showDetail != 0 {
        fprintf(
            stderr,
            b"OPTIONS include:\n%s\0" as *const u8 as *const libc::c_char,
            zOptions.as_ptr(),
        );
    } else {
        fprintf(
            stderr,
            b"Use the -help option for additional information\n\0" as *const u8
                as *const libc::c_char,
        );
    }
    exit(1 as libc::c_int);
}
unsafe extern "C" fn verify_uninitialized() {
    if sqlite3_config(-(1 as libc::c_int)) == 21 as libc::c_int {
        fprintf(
            stdout,
            b"WARNING: attempt to configure SQLite after initialization.\n\0"
                as *const u8 as *const libc::c_char,
        );
    }
}
unsafe extern "C" fn main_init(data: *mut ShellState) {
    memset(
        data as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    (*data).mode = 2 as libc::c_int;
    (*data).cMode = (*data).mode;
    (*data).normalMode = (*data).cMode;
    (*data).autoExplain = 1 as libc::c_int as u8_0;
    (*data)
        .pAuxDb = &mut *((*data).aAuxDb).as_mut_ptr().offset(0 as libc::c_int as isize)
        as *mut AuxDb;
    memcpy(
        ((*data).colSeparator).as_mut_ptr() as *mut libc::c_void,
        b"|\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    memcpy(
        ((*data).rowSeparator).as_mut_ptr() as *mut libc::c_void,
        b"\n\0" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    (*data).showHeader = 0 as libc::c_int;
    (*data).shellFlgs = 0x2 as libc::c_int as libc::c_uint;
    sqlite3_config(
        16 as libc::c_int,
        Some(
            shellLog
                as unsafe extern "C" fn(
                    *mut libc::c_void,
                    libc::c_int,
                    *const libc::c_char,
                ) -> (),
        ),
        data,
    );
    verify_uninitialized();
    sqlite3_config(17 as libc::c_int, 1 as libc::c_int);
    sqlite3_config(2 as libc::c_int);
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        mainPrompt.as_mut_ptr(),
        b"sqlite> \0" as *const u8 as *const libc::c_char,
    );
    sqlite3_snprintf(
        ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        continuePrompt.as_mut_ptr(),
        b"   ...> \0" as *const u8 as *const libc::c_char,
    );
}
unsafe extern "C" fn printBold(zText: *const libc::c_char) {
    printf(b"\x1B[1m%s\x1B[0m\0" as *const u8 as *const libc::c_char, zText);
}
unsafe extern "C" fn cmdline_option_value(
    argc: libc::c_int,
    argv: *mut *mut libc::c_char,
    i: libc::c_int,
) -> *mut libc::c_char {
    if i == argc {
        fprintf(
            stderr,
            b"%s: Error: missing argument to %s\n\0" as *const u8 as *const libc::c_char,
            *argv.offset(0 as libc::c_int as isize),
            *argv.offset((argc - 1 as libc::c_int) as isize),
        );
        exit(1 as libc::c_int);
    }
    return *argv.offset(i as isize);
}
unsafe extern "C" fn sayAbnormalExit() {
    if seenInterrupt != 0 {
        fprintf(stderr, b"Program interrupted.\n\0" as *const u8 as *const libc::c_char);
    }
}
unsafe fn main_0(
    argc: libc::c_int,
    argv: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data: ShellState = ShellState {
        db: 0 as *mut sqlite3,
        autoExplain: 0,
        autoEQP: 0,
        autoEQPtest: 0,
        autoEQPtrace: 0,
        scanstatsOn: 0,
        openMode: 0,
        doXdgOpen: 0,
        nEqpLevel: 0,
        eTraceType: 0,
        bSafeMode: 0,
        bSafeModePersist: 0,
        cmOpts: ColModeOpts {
            iWrap: 0,
            bQuote: 0,
            bWordWrap: 0,
        },
        statsOn: 0,
        mEqpLines: 0,
        inputNesting: 0,
        outCount: 0,
        cnt: 0,
        lineno: 0,
        openFlags: 0,
        in_0: 0 as *mut FILE,
        out: 0 as *mut FILE,
        traceOut: 0 as *mut FILE,
        nErr: 0,
        mode: 0,
        modePrior: 0,
        cMode: 0,
        normalMode: 0,
        writableSchema: 0,
        showHeader: 0,
        nCheck: 0,
        nProgress: 0,
        mxProgress: 0,
        flgProgress: 0,
        shellFlgs: 0,
        priorShFlgs: 0,
        szMax: 0,
        zDestTable: 0 as *mut libc::c_char,
        zTempFile: 0 as *mut libc::c_char,
        zTestcase: [0; 30],
        colSeparator: [0; 20],
        rowSeparator: [0; 20],
        colSepPrior: [0; 20],
        rowSepPrior: [0; 20],
        colWidth: 0 as *mut libc::c_int,
        actualWidth: 0 as *mut libc::c_int,
        nWidth: 0,
        nullValue: [0; 20],
        outfile: [0; 4096],
        pStmt: 0 as *mut sqlite3_stmt,
        pLog: 0 as *mut FILE,
        aAuxDb: [AuxDb {
            db: 0 as *mut sqlite3,
            zDbFilename: 0 as *const libc::c_char,
            zFreeOnClose: 0 as *mut libc::c_char,
        }; 5],
        pAuxDb: 0 as *mut AuxDb,
        aiIndent: 0 as *mut libc::c_int,
        nIndent: 0,
        iIndent: 0,
        zNonce: 0 as *mut libc::c_char,
        sGraph: EQPGraph {
            pRow: 0 as *mut EQPGraphRow,
            pLast: 0 as *mut EQPGraphRow,
            zPrefix: [0; 100],
        },
        expert: ExpertInfo {
            pExpert: 0 as *mut sqlite3expert,
            bVerbose: 0,
        },
    };
    let mut zInitFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut warnInmemoryDb: libc::c_int = 0 as libc::c_int;
    let mut readStdin: libc::c_int = 1 as libc::c_int;
    let mut nCmd: libc::c_int = 0 as libc::c_int;
    let mut nOptsEnd: libc::c_int = argc;
    let mut azCmd: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
    setvbuf(
        stderr,
        0 as *mut libc::c_char,
        2 as libc::c_int,
        0 as libc::c_int as size_t,
    );
    stdin_is_interactive = isatty(0 as libc::c_int);
    stdout_is_console = isatty(1 as libc::c_int);
    atexit(Some(sayAbnormalExit as unsafe extern "C" fn() -> ()));
    if !(getenv(b"SQLITE_DEBUG_BREAK\0" as *const u8 as *const libc::c_char)).is_null() {
        if isatty(0 as libc::c_int) != 0 && isatty(2 as libc::c_int) != 0 {
            fprintf(
                stderr,
                b"attach debugger to process %d and press any key to continue.\n\0"
                    as *const u8 as *const libc::c_char,
                getpid(),
            );
            fgetc(stdin);
        } else {
            raise(5 as libc::c_int);
        }
    }
    signal(
        2 as libc::c_int,
        Some(interrupt_handler as unsafe extern "C" fn(libc::c_int) -> ()),
    );
    if cli_strncmp(
        sqlite3_sourceid(),
        b"2023-09-11 12:01:27 2d3a40c05c49e1a49264912b1a05bc2143ac0e7c3df588276ce80a4cbc9bd1b0\0"
            as *const u8 as *const libc::c_char,
        60 as libc::c_int as size_t,
    ) != 0 as libc::c_int
    {
        fprintf(
            stderr,
            b"SQLite header and source version mismatch\n%s\n%s\n\0" as *const u8
                as *const libc::c_char,
            sqlite3_sourceid(),
            b"2023-09-11 12:01:27 2d3a40c05c49e1a49264912b1a05bc2143ac0e7c3df588276ce80a4cbc9bd1b0\0"
                as *const u8 as *const libc::c_char,
        );
        exit(1 as libc::c_int);
    }
    main_init(&mut data);
    if argc >= 1 as libc::c_int && !argv.is_null()
        && !(*argv.offset(0 as libc::c_int as isize)).is_null()
    {} else {
        __assert_fail(
            b"argc>=1 && argv && argv[0]\0" as *const u8 as *const libc::c_char,
            b"shell.c\0" as *const u8 as *const libc::c_char,
            27960 as libc::c_int as libc::c_uint,
            (*::core::mem::transmute::<
                &[u8; 23],
                &[libc::c_char; 23],
            >(b"int main(int, char **)\0"))
                .as_ptr(),
        );
    }
    'c_133593: {
        if argc >= 1 as libc::c_int && !argv.is_null()
            && !(*argv.offset(0 as libc::c_int as isize)).is_null()
        {} else {
            __assert_fail(
                b"argc>=1 && argv && argv[0]\0" as *const u8 as *const libc::c_char,
                b"shell.c\0" as *const u8 as *const libc::c_char,
                27960 as libc::c_int as libc::c_uint,
                (*::core::mem::transmute::<
                    &[u8; 23],
                    &[libc::c_char; 23],
                >(b"int main(int, char **)\0"))
                    .as_ptr(),
            );
        }
    };
    Argv0 = *argv.offset(0 as libc::c_int as isize);
    verify_uninitialized();
    i = 1 as libc::c_int;
    while i < argc {
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        z = *argv.offset(i as isize);
        if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
            || i > nOptsEnd
        {
            if ((*(data.aAuxDb).as_mut_ptr()).zDbFilename).is_null() {
                let ref mut fresh128 = (*(data.aAuxDb).as_mut_ptr()).zDbFilename;
                *fresh128 = z;
            } else {
                readStdin = 0 as libc::c_int;
                nCmd += 1;
                nCmd;
                azCmd = realloc(
                    azCmd as *mut libc::c_void,
                    (::core::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                        .wrapping_mul(nCmd as libc::c_ulong),
                ) as *mut *mut libc::c_char;
                shell_check_oom(azCmd as *const libc::c_void);
                let ref mut fresh129 = *azCmd.offset((nCmd - 1 as libc::c_int) as isize);
                *fresh129 = z;
            }
        } else {
            if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z = z.offset(1);
                z;
            }
            if cli_strcmp(z, b"-\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                nOptsEnd = i;
            } else if cli_strcmp(z, b"-separator\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
                || cli_strcmp(z, b"-nullvalue\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                || cli_strcmp(z, b"-newline\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                || cli_strcmp(z, b"-cmd\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
            {
                i += 1;
                cmdline_option_value(argc, argv, i);
            } else if cli_strcmp(z, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                zInitFile = cmdline_option_value(argc, argv, i);
            } else if cli_strcmp(z, b"-batch\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                stdin_is_interactive = 0 as libc::c_int;
            } else if cli_strcmp(z, b"-heap\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                cmdline_option_value(argc, argv, i);
            } else if cli_strcmp(z, b"-pagecache\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                let mut n: sqlite3_int64 = 0;
                let mut sz: sqlite3_int64 = 0;
                i += 1;
                sz = integerValue(cmdline_option_value(argc, argv, i));
                if sz > 70000 as libc::c_int as libc::c_longlong {
                    sz = 70000 as libc::c_int as sqlite3_int64;
                }
                if sz < 0 as libc::c_int as libc::c_longlong {
                    sz = 0 as libc::c_int as sqlite3_int64;
                }
                i += 1;
                n = integerValue(cmdline_option_value(argc, argv, i));
                if sz > 0 as libc::c_int as libc::c_longlong
                    && n > 0 as libc::c_int as libc::c_longlong
                    && 0xffffffffffff as libc::c_longlong / sz < n
                {
                    n = 0xffffffffffff as libc::c_longlong / sz;
                }
                verify_uninitialized();
                sqlite3_config(
                    7 as libc::c_int,
                    if n > 0 as libc::c_int as libc::c_longlong
                        && sz > 0 as libc::c_int as libc::c_longlong
                    {
                        malloc((n * sz) as libc::c_ulong)
                    } else {
                        0 as *mut libc::c_void
                    },
                    sz,
                    n,
                );
                data.shellFlgs |= 0x1 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z, b"-lookaside\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                let mut n_0: libc::c_int = 0;
                let mut sz_0: libc::c_int = 0;
                i += 1;
                sz_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
                if sz_0 < 0 as libc::c_int {
                    sz_0 = 0 as libc::c_int;
                }
                i += 1;
                n_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
                if n_0 < 0 as libc::c_int {
                    n_0 = 0 as libc::c_int;
                }
                verify_uninitialized();
                sqlite3_config(13 as libc::c_int, sz_0, n_0);
                if sz_0 * n_0 == 0 as libc::c_int {
                    data.shellFlgs &= !(0x2 as libc::c_int) as libc::c_uint;
                }
            } else if cli_strcmp(z, b"-threadsafe\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                let mut n_1: libc::c_int = 0;
                i += 1;
                n_1 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
                verify_uninitialized();
                match n_1 {
                    0 => {
                        sqlite3_config(1 as libc::c_int);
                    }
                    2 => {
                        sqlite3_config(2 as libc::c_int);
                    }
                    _ => {
                        sqlite3_config(3 as libc::c_int);
                    }
                }
            } else if cli_strcmp(z, b"-mmap\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                let sz_1: sqlite3_int64 = integerValue(
                    cmdline_option_value(argc, argv, i),
                );
                verify_uninitialized();
                sqlite3_config(22 as libc::c_int, sz_1, sz_1);
            } else if cli_strcmp(z, b"-vfs\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                zVfs = cmdline_option_value(argc, argv, i);
            } else if cli_strcmp(z, b"-zip\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(z, b"-append\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 2 as libc::c_int as u8_0;
            } else if cli_strcmp(
                z,
                b"-deserialize\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.openMode = 5 as libc::c_int as u8_0;
            } else if cli_strcmp(z, b"-maxsize\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && (i + 1 as libc::c_int) < argc
            {
                i += 1;
                data.szMax = integerValue(*argv.offset(i as isize));
            } else if cli_strcmp(z, b"-readonly\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 4 as libc::c_int as u8_0;
            } else if cli_strcmp(z, b"-nofollow\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openFlags = 0x1000000 as libc::c_int;
            } else {
                if cli_strncmp(
                    z,
                    b"-A\0" as *const u8 as *const libc::c_char,
                    2 as libc::c_int as size_t,
                ) == 0 as libc::c_int
                {
                    break;
                }
                if cli_strcmp(z, b"-memtrace\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    sqlite3MemTraceActivate(stderr);
                } else if cli_strcmp(
                    z,
                    b"-pcachetrace\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    sqlite3PcacheTraceActivate(stderr);
                } else if cli_strcmp(z, b"-bail\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bail_on_error = 1 as libc::c_int;
                } else if cli_strcmp(z, b"-nonce\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    free(data.zNonce as *mut libc::c_void);
                    i += 1;
                    data.zNonce = strdup(cmdline_option_value(argc, argv, i));
                } else if cli_strcmp(
                    z,
                    b"-unsafe-testing\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    data.shellFlgs |= 0x400 as libc::c_int as libc::c_uint;
                } else {
                    cli_strcmp(z, b"-safe\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int;
                }
            }
        }
        i += 1;
        i;
    }
    verify_uninitialized();
    sqlite3_initialize();
    if !zVfs.is_null() {
        let pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(zVfs);
        if !pVfs.is_null() {
            sqlite3_vfs_register(pVfs, 1 as libc::c_int);
        } else {
            fprintf(
                stderr,
                b"no such VFS: \"%s\"\n\0" as *const u8 as *const libc::c_char,
                zVfs,
            );
            exit(1 as libc::c_int);
        }
    }
    if ((*data.pAuxDb).zDbFilename).is_null() {
        (*data.pAuxDb).zDbFilename = b":memory:\0" as *const u8 as *const libc::c_char;
        warnInmemoryDb = (argc == 1 as libc::c_int) as libc::c_int;
    }
    data.out = stdout;
    sqlite3_appendvfs_init(
        0 as *mut sqlite3,
        0 as *mut *mut libc::c_char,
        0 as *const sqlite3_api_routines,
    );
    if access((*data.pAuxDb).zDbFilename, 0 as libc::c_int) == 0 as libc::c_int {
        open_db(&mut data, 0 as libc::c_int);
    }
    process_sqliterc(&mut data, zInitFile);
    i = 1 as libc::c_int;
    while i < argc {
        let mut z_0: *mut libc::c_char = *argv.offset(i as isize);
        if !(*z_0.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
            || i >= nOptsEnd)
        {
            if *z_0.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z_0 = z_0.offset(1);
                z_0;
            }
            if cli_strcmp(z_0, b"-init\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                i;
            } else if cli_strcmp(z_0, b"-html\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 4 as libc::c_int;
            } else if cli_strcmp(z_0, b"-list\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 2 as libc::c_int;
            } else if cli_strcmp(z_0, b"-quote\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 6 as libc::c_int;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b",\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            } else if cli_strcmp(z_0, b"-line\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 0 as libc::c_int;
            } else if cli_strcmp(z_0, b"-column\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 1 as libc::c_int;
            } else if cli_strcmp(z_0, b"-json\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 13 as libc::c_int;
            } else if cli_strcmp(z_0, b"-markdown\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 14 as libc::c_int;
            } else if cli_strcmp(z_0, b"-table\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 15 as libc::c_int;
            } else if cli_strcmp(z_0, b"-box\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 16 as libc::c_int;
            } else if cli_strcmp(z_0, b"-csv\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 8 as libc::c_int;
                memcpy(
                    (data.colSeparator).as_mut_ptr() as *mut libc::c_void,
                    b",\0" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            } else if cli_strcmp(z_0, b"-zip\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-append\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 2 as libc::c_int as u8_0;
            } else if cli_strcmp(
                z_0,
                b"-deserialize\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.openMode = 5 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-maxsize\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int && (i + 1 as libc::c_int) < argc
            {
                i += 1;
                data.szMax = integerValue(*argv.offset(i as isize));
            } else if cli_strcmp(z_0, b"-readonly\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 4 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-nofollow\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openFlags |= 0x1000000 as libc::c_int;
            } else if cli_strcmp(z_0, b"-ascii\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 10 as libc::c_int;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"\x1F\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\x1E\0" as *const u8 as *const libc::c_char,
                );
            } else if cli_strcmp(z_0, b"-tabs\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.mode = 2 as libc::c_int;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"\t\0" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"\n\0" as *const u8 as *const libc::c_char,
                );
            } else if cli_strcmp(
                z_0,
                b"-separator\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.colSeparator).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if cli_strcmp(z_0, b"-newline\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.rowSeparator).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if cli_strcmp(
                z_0,
                b"-nullvalue\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                i += 1;
                sqlite3_snprintf(
                    ::core::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                        as libc::c_int,
                    (data.nullValue).as_mut_ptr(),
                    b"%s\0" as *const u8 as *const libc::c_char,
                    cmdline_option_value(argc, argv, i),
                );
            } else if cli_strcmp(z_0, b"-header\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.showHeader = 1 as libc::c_int;
                data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z_0, b"-noheader\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.showHeader = 0 as libc::c_int;
                data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z_0, b"-echo\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.shellFlgs |= 0x40 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(z_0, b"-eqp\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.autoEQP = 1 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-eqpfull\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.autoEQP = 3 as libc::c_int as u8_0;
            } else if cli_strcmp(z_0, b"-stats\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.statsOn = 1 as libc::c_int as libc::c_uint;
            } else if cli_strcmp(
                z_0,
                b"-scanstats\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.scanstatsOn = 1 as libc::c_int as u8_0;
            } else if cli_strcmp(
                z_0,
                b"-backslash\0" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
            {
                data.shellFlgs |= 0x4 as libc::c_int as libc::c_uint;
            } else if !(cli_strcmp(z_0, b"-bail\0" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int)
            {
                if cli_strcmp(z_0, b"-version\0" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    printf(
                        b"%s %s (%d-bit)\n\0" as *const u8 as *const libc::c_char,
                        sqlite3_libversion(),
                        sqlite3_sourceid(),
                        8 as libc::c_int
                            * ::core::mem::size_of::<*mut libc::c_char>()
                                as libc::c_ulong as libc::c_int,
                    );
                    return 0 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-interactive\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    stdin_is_interactive = 1 as libc::c_int;
                } else if cli_strcmp(
                    z_0,
                    b"-batch\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    stdin_is_interactive = 0 as libc::c_int;
                } else if !(cli_strcmp(
                    z_0,
                    b"-utf8\0" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int)
                {
                    if cli_strcmp(z_0, b"-heap\0" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 1;
                        i;
                    } else if cli_strcmp(
                        z_0,
                        b"-pagecache\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int;
                    } else if cli_strcmp(
                        z_0,
                        b"-lookaside\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int;
                    } else if cli_strcmp(
                        z_0,
                        b"-threadsafe\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int;
                    } else if cli_strcmp(
                        z_0,
                        b"-nonce\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int;
                    } else if cli_strcmp(
                        z_0,
                        b"-mmap\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 1;
                        i;
                    } else if cli_strcmp(
                        z_0,
                        b"-memtrace\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 1;
                        i;
                    } else if cli_strcmp(
                        z_0,
                        b"-pcachetrace\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 1;
                        i;
                    } else if cli_strcmp(
                        z_0,
                        b"-vfs\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        i += 1;
                        i;
                    } else if cli_strcmp(
                        z_0,
                        b"-help\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        usage(1 as libc::c_int);
                    } else if cli_strcmp(
                        z_0,
                        b"-cmd\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        if i == argc - 1 as libc::c_int {
                            break;
                        }
                        i += 1;
                        z_0 = cmdline_option_value(argc, argv, i);
                        if *z_0.offset(0 as libc::c_int as isize) as libc::c_int
                            == '.' as i32
                        {
                            rc = do_meta_command(z_0, &mut data);
                            if rc != 0 && bail_on_error != 0 {
                                return if rc == 2 as libc::c_int {
                                    0 as libc::c_int
                                } else {
                                    rc
                                };
                            }
                        } else {
                            open_db(&mut data, 0 as libc::c_int);
                            rc = shell_exec(&mut data, z_0, &mut zErrMsg);
                            if !zErrMsg.is_null() {
                                fprintf(
                                    stderr,
                                    b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                                    zErrMsg,
                                );
                                if bail_on_error != 0 {
                                    return if rc != 0 as libc::c_int {
                                        rc
                                    } else {
                                        1 as libc::c_int
                                    };
                                }
                            } else if rc != 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: unable to process SQL \"%s\"\n\0" as *const u8
                                        as *const libc::c_char,
                                    z_0,
                                );
                                if bail_on_error != 0 {
                                    return rc;
                                }
                            }
                        }
                    } else if cli_strncmp(
                        z_0,
                        b"-A\0" as *const u8 as *const libc::c_char,
                        2 as libc::c_int as size_t,
                    ) == 0 as libc::c_int
                    {
                        if nCmd > 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: cannot mix regular SQL or dot-commands with \"%s\"\n\0"
                                    as *const u8 as *const libc::c_char,
                                z_0,
                            );
                            return 1 as libc::c_int;
                        }
                        open_db(&mut data, 0x2 as libc::c_int);
                        if *z_0.offset(2 as libc::c_int as isize) != 0 {
                            let ref mut fresh130 = *argv.offset(i as isize);
                            *fresh130 = &mut *z_0.offset(2 as libc::c_int as isize)
                                as *mut libc::c_char;
                            arDotCommand(
                                &mut data,
                                1 as libc::c_int,
                                argv.offset((i - 1 as libc::c_int) as isize),
                                argc - (i - 1 as libc::c_int),
                            );
                        } else {
                            arDotCommand(
                                &mut data,
                                1 as libc::c_int,
                                argv.offset(i as isize),
                                argc - i,
                            );
                        }
                        readStdin = 0 as libc::c_int;
                        break;
                    } else if cli_strcmp(
                        z_0,
                        b"-safe\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        data.bSafeModePersist = 1 as libc::c_int as u8_0;
                        data.bSafeMode = data.bSafeModePersist;
                    } else if cli_strcmp(
                        z_0,
                        b"-unsafe-testing\0" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {} else {
                        fprintf(
                            stderr,
                            b"%s: Error: unknown option: %s\n\0" as *const u8
                                as *const libc::c_char,
                            Argv0,
                            z_0,
                        );
                        fprintf(
                            stderr,
                            b"Use -help for a list of options.\n\0" as *const u8
                                as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                }
            }
            data.cMode = data.mode;
        }
        i += 1;
        i;
    }
    if readStdin == 0 {
        i = 0 as libc::c_int;
        while i < nCmd {
            if *(*azCmd.offset(i as isize)).offset(0 as libc::c_int as isize)
                as libc::c_int == '.' as i32
            {
                rc = do_meta_command(*azCmd.offset(i as isize), &mut data);
                if rc != 0 {
                    free(azCmd as *mut libc::c_void);
                    return if rc == 2 as libc::c_int { 0 as libc::c_int } else { rc };
                }
            } else {
                open_db(&mut data, 0 as libc::c_int);
                echo_group_input(&mut data, *azCmd.offset(i as isize));
                rc = shell_exec(&mut data, *azCmd.offset(i as isize), &mut zErrMsg);
                if !zErrMsg.is_null() || rc != 0 {
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\n\0" as *const u8 as *const libc::c_char,
                            zErrMsg,
                        );
                    } else {
                        fprintf(
                            stderr,
                            b"Error: unable to process SQL: %s\n\0" as *const u8
                                as *const libc::c_char,
                            *azCmd.offset(i as isize),
                        );
                    }
                    sqlite3_free(zErrMsg as *mut libc::c_void);
                    free(azCmd as *mut libc::c_void);
                    return if rc != 0 as libc::c_int { rc } else { 1 as libc::c_int };
                }
            }
            i += 1;
            i;
        }
    } else if stdin_is_interactive != 0 {
        let mut zHome: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zHistory: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut nHistory: libc::c_int = 0;
        printf(
            b"SQLite version %s %.19s\nEnter \".help\" for usage hints.\n\0" as *const u8
                as *const libc::c_char,
            sqlite3_libversion(),
            sqlite3_sourceid(),
        );
        if warnInmemoryDb != 0 {
            printf(b"Connected to a \0" as *const u8 as *const libc::c_char);
            printBold(
                b"transient in-memory database\0" as *const u8 as *const libc::c_char,
            );
            printf(
                b".\nUse \".open FILENAME\" to reopen on a persistent database.\n\0"
                    as *const u8 as *const libc::c_char,
            );
        }
        zHistory = getenv(b"SQLITE_HISTORY\0" as *const u8 as *const libc::c_char);
        if !zHistory.is_null() {
            zHistory = strdup(zHistory);
        } else {
            zHome = find_home_dir(0 as libc::c_int);
            if !zHome.is_null() {
                nHistory = strlen30(zHome) + 20 as libc::c_int;
                zHistory = malloc(nHistory as libc::c_ulong) as *mut libc::c_char;
                if !zHistory.is_null() {
                    sqlite3_snprintf(
                        nHistory,
                        zHistory,
                        b"%s/.sqlite_history\0" as *const u8 as *const libc::c_char,
                        zHome,
                    );
                }
            }
        }
        if !zHistory.is_null() {
            read_history(zHistory);
        }
        rl_attempted_completion_function = Some(
            readline_completion
                as unsafe extern "C" fn(
                    *const libc::c_char,
                    libc::c_int,
                    libc::c_int,
                ) -> *mut *mut libc::c_char,
        );
        data.in_0 = 0 as *mut FILE;
        rc = process_input(&mut data);
        if !zHistory.is_null() {
            stifle_history(2000 as libc::c_int);
            write_history(zHistory);
            free(zHistory as *mut libc::c_void);
        }
    } else {
        data.in_0 = stdin;
        rc = process_input(&mut data);
    }
    free(azCmd as *mut libc::c_void);
    set_table_name(&mut data, 0 as *const libc::c_char);
    if !(data.db).is_null() {
        close_db(data.db);
    }
    i = 0 as libc::c_int;
    while i
        < (::core::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<AuxDb>() as libc::c_ulong)
            as libc::c_int
    {
        sqlite3_free(data.aAuxDb[i as usize].zFreeOnClose as *mut libc::c_void);
        if !(data.aAuxDb[i as usize].db).is_null() {
            close_db(data.aAuxDb[i as usize].db);
        }
        i += 1;
        i;
    }
    find_home_dir(1 as libc::c_int);
    output_reset(&mut data);
    data.doXdgOpen = 0 as libc::c_int as u8_0;
    clearTempFile(&mut data);
    free(data.colWidth as *mut libc::c_void);
    free(data.zNonce as *mut libc::c_void);
    memset(
        &mut data as *mut ShellState as *mut libc::c_void,
        0 as libc::c_int,
        ::core::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    return rc;
}
pub fn main() {
    let mut args: Vec::<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            (::std::ffi::CString::new(arg))
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::core::ptr::null_mut());
    unsafe {
        ::std::process::exit(
            main_0(
                (args.len() - 1) as libc::c_int,
                args.as_mut_ptr() as *mut *mut libc::c_char,
            ) as i32,
        )
    }
}
